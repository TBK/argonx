// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: stream.proto

#ifndef PROTOBUF_INCLUDED_stream_2eproto
#define PROTOBUF_INCLUDED_stream_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_stream_2eproto 

namespace protobuf_stream_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[72];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_stream_2eproto
class CAudioFormat;
class CAudioFormatDefaultTypeInternal;
extern CAudioFormatDefaultTypeInternal _CAudioFormat_default_instance_;
class CAuthenticationRequestMsg;
class CAuthenticationRequestMsgDefaultTypeInternal;
extern CAuthenticationRequestMsgDefaultTypeInternal _CAuthenticationRequestMsg_default_instance_;
class CAuthenticationResponseMsg;
class CAuthenticationResponseMsgDefaultTypeInternal;
extern CAuthenticationResponseMsgDefaultTypeInternal _CAuthenticationResponseMsg_default_instance_;
class CClientHandshakeMsg;
class CClientHandshakeMsgDefaultTypeInternal;
extern CClientHandshakeMsgDefaultTypeInternal _CClientHandshakeMsg_default_instance_;
class CDebugDumpMsg;
class CDebugDumpMsgDefaultTypeInternal;
extern CDebugDumpMsgDefaultTypeInternal _CDebugDumpMsg_default_instance_;
class CDeleteCursorMsg;
class CDeleteCursorMsgDefaultTypeInternal;
extern CDeleteCursorMsgDefaultTypeInternal _CDeleteCursorMsg_default_instance_;
class CDiscoveryPingRequest;
class CDiscoveryPingRequestDefaultTypeInternal;
extern CDiscoveryPingRequestDefaultTypeInternal _CDiscoveryPingRequest_default_instance_;
class CDiscoveryPingResponse;
class CDiscoveryPingResponseDefaultTypeInternal;
extern CDiscoveryPingResponseDefaultTypeInternal _CDiscoveryPingResponse_default_instance_;
class CFrameEvent;
class CFrameEventDefaultTypeInternal;
extern CFrameEventDefaultTypeInternal _CFrameEvent_default_instance_;
class CFrameStatAccumulatedValue;
class CFrameStatAccumulatedValueDefaultTypeInternal;
extern CFrameStatAccumulatedValueDefaultTypeInternal _CFrameStatAccumulatedValue_default_instance_;
class CFrameStats;
class CFrameStatsDefaultTypeInternal;
extern CFrameStatsDefaultTypeInternal _CFrameStats_default_instance_;
class CFrameStatsListMsg;
class CFrameStatsListMsgDefaultTypeInternal;
extern CFrameStatsListMsgDefaultTypeInternal _CFrameStatsListMsg_default_instance_;
class CGetCursorImageMsg;
class CGetCursorImageMsgDefaultTypeInternal;
extern CGetCursorImageMsgDefaultTypeInternal _CGetCursorImageMsg_default_instance_;
class CGetTouchConfigDataMsg;
class CGetTouchConfigDataMsgDefaultTypeInternal;
extern CGetTouchConfigDataMsgDefaultTypeInternal _CGetTouchConfigDataMsg_default_instance_;
class CGetTouchIconDataMsg;
class CGetTouchIconDataMsgDefaultTypeInternal;
extern CGetTouchIconDataMsgDefaultTypeInternal _CGetTouchIconDataMsg_default_instance_;
class CHideCursorMsg;
class CHideCursorMsgDefaultTypeInternal;
extern CHideCursorMsgDefaultTypeInternal _CHideCursorMsg_default_instance_;
class CInputKeyDownMsg;
class CInputKeyDownMsgDefaultTypeInternal;
extern CInputKeyDownMsgDefaultTypeInternal _CInputKeyDownMsg_default_instance_;
class CInputKeyUpMsg;
class CInputKeyUpMsgDefaultTypeInternal;
extern CInputKeyUpMsgDefaultTypeInternal _CInputKeyUpMsg_default_instance_;
class CInputLatencyTestMsg;
class CInputLatencyTestMsgDefaultTypeInternal;
extern CInputLatencyTestMsgDefaultTypeInternal _CInputLatencyTestMsg_default_instance_;
class CInputMouseDownMsg;
class CInputMouseDownMsgDefaultTypeInternal;
extern CInputMouseDownMsgDefaultTypeInternal _CInputMouseDownMsg_default_instance_;
class CInputMouseMotionMsg;
class CInputMouseMotionMsgDefaultTypeInternal;
extern CInputMouseMotionMsgDefaultTypeInternal _CInputMouseMotionMsg_default_instance_;
class CInputMouseUpMsg;
class CInputMouseUpMsgDefaultTypeInternal;
extern CInputMouseUpMsgDefaultTypeInternal _CInputMouseUpMsg_default_instance_;
class CInputMouseWheelMsg;
class CInputMouseWheelMsgDefaultTypeInternal;
extern CInputMouseWheelMsgDefaultTypeInternal _CInputMouseWheelMsg_default_instance_;
class CInputTextMsg;
class CInputTextMsgDefaultTypeInternal;
extern CInputTextMsgDefaultTypeInternal _CInputTextMsg_default_instance_;
class CKeepAliveMsg;
class CKeepAliveMsgDefaultTypeInternal;
extern CKeepAliveMsgDefaultTypeInternal _CKeepAliveMsg_default_instance_;
class CLogMsg;
class CLogMsgDefaultTypeInternal;
extern CLogMsgDefaultTypeInternal _CLogMsg_default_instance_;
class CLogUploadMsg;
class CLogUploadMsgDefaultTypeInternal;
extern CLogUploadMsgDefaultTypeInternal _CLogUploadMsg_default_instance_;
class CNegotiatedConfig;
class CNegotiatedConfigDefaultTypeInternal;
extern CNegotiatedConfigDefaultTypeInternal _CNegotiatedConfig_default_instance_;
class CNegotiationCompleteMsg;
class CNegotiationCompleteMsgDefaultTypeInternal;
extern CNegotiationCompleteMsgDefaultTypeInternal _CNegotiationCompleteMsg_default_instance_;
class CNegotiationInitMsg;
class CNegotiationInitMsgDefaultTypeInternal;
extern CNegotiationInitMsgDefaultTypeInternal _CNegotiationInitMsg_default_instance_;
class CNegotiationSetConfigMsg;
class CNegotiationSetConfigMsgDefaultTypeInternal;
extern CNegotiationSetConfigMsgDefaultTypeInternal _CNegotiationSetConfigMsg_default_instance_;
class COverlayEnabledMsg;
class COverlayEnabledMsgDefaultTypeInternal;
extern COverlayEnabledMsgDefaultTypeInternal _COverlayEnabledMsg_default_instance_;
class CQuitRequest;
class CQuitRequestDefaultTypeInternal;
extern CQuitRequestDefaultTypeInternal _CQuitRequest_default_instance_;
class CRemoteHIDMsg;
class CRemoteHIDMsgDefaultTypeInternal;
extern CRemoteHIDMsgDefaultTypeInternal _CRemoteHIDMsg_default_instance_;
class CSaveTouchConfigLayoutMsg;
class CSaveTouchConfigLayoutMsgDefaultTypeInternal;
extern CSaveTouchConfigLayoutMsgDefaultTypeInternal _CSaveTouchConfigLayoutMsg_default_instance_;
class CServerHandshakeMsg;
class CServerHandshakeMsgDefaultTypeInternal;
extern CServerHandshakeMsgDefaultTypeInternal _CServerHandshakeMsg_default_instance_;
class CSetActivityMsg;
class CSetActivityMsgDefaultTypeInternal;
extern CSetActivityMsgDefaultTypeInternal _CSetActivityMsg_default_instance_;
class CSetCursorImageMsg;
class CSetCursorImageMsgDefaultTypeInternal;
extern CSetCursorImageMsgDefaultTypeInternal _CSetCursorImageMsg_default_instance_;
class CSetCursorMsg;
class CSetCursorMsgDefaultTypeInternal;
extern CSetCursorMsgDefaultTypeInternal _CSetCursorMsg_default_instance_;
class CSetGammaRampMsg;
class CSetGammaRampMsgDefaultTypeInternal;
extern CSetGammaRampMsgDefaultTypeInternal _CSetGammaRampMsg_default_instance_;
class CSetIconMsg;
class CSetIconMsgDefaultTypeInternal;
extern CSetIconMsgDefaultTypeInternal _CSetIconMsg_default_instance_;
class CSetQoSMsg;
class CSetQoSMsgDefaultTypeInternal;
extern CSetQoSMsgDefaultTypeInternal _CSetQoSMsg_default_instance_;
class CSetSpectatorModeMsg;
class CSetSpectatorModeMsgDefaultTypeInternal;
extern CSetSpectatorModeMsgDefaultTypeInternal _CSetSpectatorModeMsg_default_instance_;
class CSetStreamingClientConfig;
class CSetStreamingClientConfigDefaultTypeInternal;
extern CSetStreamingClientConfigDefaultTypeInternal _CSetStreamingClientConfig_default_instance_;
class CSetTargetBitrateMsg;
class CSetTargetBitrateMsgDefaultTypeInternal;
extern CSetTargetBitrateMsgDefaultTypeInternal _CSetTargetBitrateMsg_default_instance_;
class CSetTargetFramerateMsg;
class CSetTargetFramerateMsgDefaultTypeInternal;
extern CSetTargetFramerateMsgDefaultTypeInternal _CSetTargetFramerateMsg_default_instance_;
class CSetTitleMsg;
class CSetTitleMsgDefaultTypeInternal;
extern CSetTitleMsgDefaultTypeInternal _CSetTitleMsg_default_instance_;
class CSetTouchConfigDataMsg;
class CSetTouchConfigDataMsgDefaultTypeInternal;
extern CSetTouchConfigDataMsgDefaultTypeInternal _CSetTouchConfigDataMsg_default_instance_;
class CSetTouchIconDataMsg;
class CSetTouchIconDataMsgDefaultTypeInternal;
extern CSetTouchIconDataMsgDefaultTypeInternal _CSetTouchIconDataMsg_default_instance_;
class CShowCursorMsg;
class CShowCursorMsgDefaultTypeInternal;
extern CShowCursorMsgDefaultTypeInternal _CShowCursorMsg_default_instance_;
class CStartAudioDataMsg;
class CStartAudioDataMsgDefaultTypeInternal;
extern CStartAudioDataMsgDefaultTypeInternal _CStartAudioDataMsg_default_instance_;
class CStartNetworkTestMsg;
class CStartNetworkTestMsgDefaultTypeInternal;
extern CStartNetworkTestMsgDefaultTypeInternal _CStartNetworkTestMsg_default_instance_;
class CStartVideoDataMsg;
class CStartVideoDataMsgDefaultTypeInternal;
extern CStartVideoDataMsgDefaultTypeInternal _CStartVideoDataMsg_default_instance_;
class CStopAudioDataMsg;
class CStopAudioDataMsgDefaultTypeInternal;
extern CStopAudioDataMsgDefaultTypeInternal _CStopAudioDataMsg_default_instance_;
class CStopVideoDataMsg;
class CStopVideoDataMsgDefaultTypeInternal;
extern CStopVideoDataMsgDefaultTypeInternal _CStopVideoDataMsg_default_instance_;
class CStreamDataLostMsg;
class CStreamDataLostMsgDefaultTypeInternal;
extern CStreamDataLostMsgDefaultTypeInternal _CStreamDataLostMsg_default_instance_;
class CStreamVideoMode;
class CStreamVideoModeDefaultTypeInternal;
extern CStreamVideoModeDefaultTypeInternal _CStreamVideoMode_default_instance_;
class CStreamingClientCaps;
class CStreamingClientCapsDefaultTypeInternal;
extern CStreamingClientCapsDefaultTypeInternal _CStreamingClientCaps_default_instance_;
class CStreamingClientConfig;
class CStreamingClientConfigDefaultTypeInternal;
extern CStreamingClientConfigDefaultTypeInternal _CStreamingClientConfig_default_instance_;
class CStreamingClientHandshakeInfo;
class CStreamingClientHandshakeInfoDefaultTypeInternal;
extern CStreamingClientHandshakeInfoDefaultTypeInternal _CStreamingClientHandshakeInfo_default_instance_;
class CStreamingServerConfig;
class CStreamingServerConfigDefaultTypeInternal;
extern CStreamingServerConfigDefaultTypeInternal _CStreamingServerConfig_default_instance_;
class CStreamingServerHandshakeInfo;
class CStreamingServerHandshakeInfoDefaultTypeInternal;
extern CStreamingServerHandshakeInfoDefaultTypeInternal _CStreamingServerHandshakeInfo_default_instance_;
class CStreamingSessionStats;
class CStreamingSessionStatsDefaultTypeInternal;
extern CStreamingSessionStatsDefaultTypeInternal _CStreamingSessionStats_default_instance_;
class CSystemSuspendMsg;
class CSystemSuspendMsgDefaultTypeInternal;
extern CSystemSuspendMsgDefaultTypeInternal _CSystemSuspendMsg_default_instance_;
class CTouchActionSetActiveMsg;
class CTouchActionSetActiveMsgDefaultTypeInternal;
extern CTouchActionSetActiveMsgDefaultTypeInternal _CTouchActionSetActiveMsg_default_instance_;
class CTouchConfigActiveMsg;
class CTouchConfigActiveMsgDefaultTypeInternal;
extern CTouchConfigActiveMsgDefaultTypeInternal _CTouchConfigActiveMsg_default_instance_;
class CVideoDecoderInfoMsg;
class CVideoDecoderInfoMsgDefaultTypeInternal;
extern CVideoDecoderInfoMsgDefaultTypeInternal _CVideoDecoderInfoMsg_default_instance_;
class CVideoEncoderInfoMsg;
class CVideoEncoderInfoMsgDefaultTypeInternal;
extern CVideoEncoderInfoMsgDefaultTypeInternal _CVideoEncoderInfoMsg_default_instance_;
class CVideoFormat;
class CVideoFormatDefaultTypeInternal;
extern CVideoFormatDefaultTypeInternal _CVideoFormat_default_instance_;
class CVirtualHereReadyMsg;
class CVirtualHereReadyMsgDefaultTypeInternal;
extern CVirtualHereReadyMsgDefaultTypeInternal _CVirtualHereReadyMsg_default_instance_;
class CVirtualHereRequestMsg;
class CVirtualHereRequestMsgDefaultTypeInternal;
extern CVirtualHereRequestMsgDefaultTypeInternal _CVirtualHereRequestMsg_default_instance_;
class CVirtualHereShareDeviceMsg;
class CVirtualHereShareDeviceMsgDefaultTypeInternal;
extern CVirtualHereShareDeviceMsgDefaultTypeInternal _CVirtualHereShareDeviceMsg_default_instance_;
namespace google {
namespace protobuf {
template<> ::CAudioFormat* Arena::CreateMaybeMessage<::CAudioFormat>(Arena*);
template<> ::CAuthenticationRequestMsg* Arena::CreateMaybeMessage<::CAuthenticationRequestMsg>(Arena*);
template<> ::CAuthenticationResponseMsg* Arena::CreateMaybeMessage<::CAuthenticationResponseMsg>(Arena*);
template<> ::CClientHandshakeMsg* Arena::CreateMaybeMessage<::CClientHandshakeMsg>(Arena*);
template<> ::CDebugDumpMsg* Arena::CreateMaybeMessage<::CDebugDumpMsg>(Arena*);
template<> ::CDeleteCursorMsg* Arena::CreateMaybeMessage<::CDeleteCursorMsg>(Arena*);
template<> ::CDiscoveryPingRequest* Arena::CreateMaybeMessage<::CDiscoveryPingRequest>(Arena*);
template<> ::CDiscoveryPingResponse* Arena::CreateMaybeMessage<::CDiscoveryPingResponse>(Arena*);
template<> ::CFrameEvent* Arena::CreateMaybeMessage<::CFrameEvent>(Arena*);
template<> ::CFrameStatAccumulatedValue* Arena::CreateMaybeMessage<::CFrameStatAccumulatedValue>(Arena*);
template<> ::CFrameStats* Arena::CreateMaybeMessage<::CFrameStats>(Arena*);
template<> ::CFrameStatsListMsg* Arena::CreateMaybeMessage<::CFrameStatsListMsg>(Arena*);
template<> ::CGetCursorImageMsg* Arena::CreateMaybeMessage<::CGetCursorImageMsg>(Arena*);
template<> ::CGetTouchConfigDataMsg* Arena::CreateMaybeMessage<::CGetTouchConfigDataMsg>(Arena*);
template<> ::CGetTouchIconDataMsg* Arena::CreateMaybeMessage<::CGetTouchIconDataMsg>(Arena*);
template<> ::CHideCursorMsg* Arena::CreateMaybeMessage<::CHideCursorMsg>(Arena*);
template<> ::CInputKeyDownMsg* Arena::CreateMaybeMessage<::CInputKeyDownMsg>(Arena*);
template<> ::CInputKeyUpMsg* Arena::CreateMaybeMessage<::CInputKeyUpMsg>(Arena*);
template<> ::CInputLatencyTestMsg* Arena::CreateMaybeMessage<::CInputLatencyTestMsg>(Arena*);
template<> ::CInputMouseDownMsg* Arena::CreateMaybeMessage<::CInputMouseDownMsg>(Arena*);
template<> ::CInputMouseMotionMsg* Arena::CreateMaybeMessage<::CInputMouseMotionMsg>(Arena*);
template<> ::CInputMouseUpMsg* Arena::CreateMaybeMessage<::CInputMouseUpMsg>(Arena*);
template<> ::CInputMouseWheelMsg* Arena::CreateMaybeMessage<::CInputMouseWheelMsg>(Arena*);
template<> ::CInputTextMsg* Arena::CreateMaybeMessage<::CInputTextMsg>(Arena*);
template<> ::CKeepAliveMsg* Arena::CreateMaybeMessage<::CKeepAliveMsg>(Arena*);
template<> ::CLogMsg* Arena::CreateMaybeMessage<::CLogMsg>(Arena*);
template<> ::CLogUploadMsg* Arena::CreateMaybeMessage<::CLogUploadMsg>(Arena*);
template<> ::CNegotiatedConfig* Arena::CreateMaybeMessage<::CNegotiatedConfig>(Arena*);
template<> ::CNegotiationCompleteMsg* Arena::CreateMaybeMessage<::CNegotiationCompleteMsg>(Arena*);
template<> ::CNegotiationInitMsg* Arena::CreateMaybeMessage<::CNegotiationInitMsg>(Arena*);
template<> ::CNegotiationSetConfigMsg* Arena::CreateMaybeMessage<::CNegotiationSetConfigMsg>(Arena*);
template<> ::COverlayEnabledMsg* Arena::CreateMaybeMessage<::COverlayEnabledMsg>(Arena*);
template<> ::CQuitRequest* Arena::CreateMaybeMessage<::CQuitRequest>(Arena*);
template<> ::CRemoteHIDMsg* Arena::CreateMaybeMessage<::CRemoteHIDMsg>(Arena*);
template<> ::CSaveTouchConfigLayoutMsg* Arena::CreateMaybeMessage<::CSaveTouchConfigLayoutMsg>(Arena*);
template<> ::CServerHandshakeMsg* Arena::CreateMaybeMessage<::CServerHandshakeMsg>(Arena*);
template<> ::CSetActivityMsg* Arena::CreateMaybeMessage<::CSetActivityMsg>(Arena*);
template<> ::CSetCursorImageMsg* Arena::CreateMaybeMessage<::CSetCursorImageMsg>(Arena*);
template<> ::CSetCursorMsg* Arena::CreateMaybeMessage<::CSetCursorMsg>(Arena*);
template<> ::CSetGammaRampMsg* Arena::CreateMaybeMessage<::CSetGammaRampMsg>(Arena*);
template<> ::CSetIconMsg* Arena::CreateMaybeMessage<::CSetIconMsg>(Arena*);
template<> ::CSetQoSMsg* Arena::CreateMaybeMessage<::CSetQoSMsg>(Arena*);
template<> ::CSetSpectatorModeMsg* Arena::CreateMaybeMessage<::CSetSpectatorModeMsg>(Arena*);
template<> ::CSetStreamingClientConfig* Arena::CreateMaybeMessage<::CSetStreamingClientConfig>(Arena*);
template<> ::CSetTargetBitrateMsg* Arena::CreateMaybeMessage<::CSetTargetBitrateMsg>(Arena*);
template<> ::CSetTargetFramerateMsg* Arena::CreateMaybeMessage<::CSetTargetFramerateMsg>(Arena*);
template<> ::CSetTitleMsg* Arena::CreateMaybeMessage<::CSetTitleMsg>(Arena*);
template<> ::CSetTouchConfigDataMsg* Arena::CreateMaybeMessage<::CSetTouchConfigDataMsg>(Arena*);
template<> ::CSetTouchIconDataMsg* Arena::CreateMaybeMessage<::CSetTouchIconDataMsg>(Arena*);
template<> ::CShowCursorMsg* Arena::CreateMaybeMessage<::CShowCursorMsg>(Arena*);
template<> ::CStartAudioDataMsg* Arena::CreateMaybeMessage<::CStartAudioDataMsg>(Arena*);
template<> ::CStartNetworkTestMsg* Arena::CreateMaybeMessage<::CStartNetworkTestMsg>(Arena*);
template<> ::CStartVideoDataMsg* Arena::CreateMaybeMessage<::CStartVideoDataMsg>(Arena*);
template<> ::CStopAudioDataMsg* Arena::CreateMaybeMessage<::CStopAudioDataMsg>(Arena*);
template<> ::CStopVideoDataMsg* Arena::CreateMaybeMessage<::CStopVideoDataMsg>(Arena*);
template<> ::CStreamDataLostMsg* Arena::CreateMaybeMessage<::CStreamDataLostMsg>(Arena*);
template<> ::CStreamVideoMode* Arena::CreateMaybeMessage<::CStreamVideoMode>(Arena*);
template<> ::CStreamingClientCaps* Arena::CreateMaybeMessage<::CStreamingClientCaps>(Arena*);
template<> ::CStreamingClientConfig* Arena::CreateMaybeMessage<::CStreamingClientConfig>(Arena*);
template<> ::CStreamingClientHandshakeInfo* Arena::CreateMaybeMessage<::CStreamingClientHandshakeInfo>(Arena*);
template<> ::CStreamingServerConfig* Arena::CreateMaybeMessage<::CStreamingServerConfig>(Arena*);
template<> ::CStreamingServerHandshakeInfo* Arena::CreateMaybeMessage<::CStreamingServerHandshakeInfo>(Arena*);
template<> ::CStreamingSessionStats* Arena::CreateMaybeMessage<::CStreamingSessionStats>(Arena*);
template<> ::CSystemSuspendMsg* Arena::CreateMaybeMessage<::CSystemSuspendMsg>(Arena*);
template<> ::CTouchActionSetActiveMsg* Arena::CreateMaybeMessage<::CTouchActionSetActiveMsg>(Arena*);
template<> ::CTouchConfigActiveMsg* Arena::CreateMaybeMessage<::CTouchConfigActiveMsg>(Arena*);
template<> ::CVideoDecoderInfoMsg* Arena::CreateMaybeMessage<::CVideoDecoderInfoMsg>(Arena*);
template<> ::CVideoEncoderInfoMsg* Arena::CreateMaybeMessage<::CVideoEncoderInfoMsg>(Arena*);
template<> ::CVideoFormat* Arena::CreateMaybeMessage<::CVideoFormat>(Arena*);
template<> ::CVirtualHereReadyMsg* Arena::CreateMaybeMessage<::CVirtualHereReadyMsg>(Arena*);
template<> ::CVirtualHereRequestMsg* Arena::CreateMaybeMessage<::CVirtualHereRequestMsg>(Arena*);
template<> ::CVirtualHereShareDeviceMsg* Arena::CreateMaybeMessage<::CVirtualHereShareDeviceMsg>(Arena*);
}  // namespace protobuf
}  // namespace google

enum CAuthenticationResponseMsg_AuthenticationResult {
  CAuthenticationResponseMsg_AuthenticationResult_SUCCEEDED = 0,
  CAuthenticationResponseMsg_AuthenticationResult_FAILED = 1
};
bool CAuthenticationResponseMsg_AuthenticationResult_IsValid(int value);
const CAuthenticationResponseMsg_AuthenticationResult CAuthenticationResponseMsg_AuthenticationResult_AuthenticationResult_MIN = CAuthenticationResponseMsg_AuthenticationResult_SUCCEEDED;
const CAuthenticationResponseMsg_AuthenticationResult CAuthenticationResponseMsg_AuthenticationResult_AuthenticationResult_MAX = CAuthenticationResponseMsg_AuthenticationResult_FAILED;
const int CAuthenticationResponseMsg_AuthenticationResult_AuthenticationResult_ARRAYSIZE = CAuthenticationResponseMsg_AuthenticationResult_AuthenticationResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* CAuthenticationResponseMsg_AuthenticationResult_descriptor();
inline const ::std::string& CAuthenticationResponseMsg_AuthenticationResult_Name(CAuthenticationResponseMsg_AuthenticationResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    CAuthenticationResponseMsg_AuthenticationResult_descriptor(), value);
}
inline bool CAuthenticationResponseMsg_AuthenticationResult_Parse(
    const ::std::string& name, CAuthenticationResponseMsg_AuthenticationResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CAuthenticationResponseMsg_AuthenticationResult>(
    CAuthenticationResponseMsg_AuthenticationResult_descriptor(), name, value);
}
enum EStreamChannel {
  k_EStreamChannelInvalid = -1,
  k_EStreamChannelDiscovery = 0,
  k_EStreamChannelControl = 1,
  k_EStreamChannelStats = 2,
  k_EStreamChannelDataChannelStart = 3
};
bool EStreamChannel_IsValid(int value);
const EStreamChannel EStreamChannel_MIN = k_EStreamChannelInvalid;
const EStreamChannel EStreamChannel_MAX = k_EStreamChannelDataChannelStart;
const int EStreamChannel_ARRAYSIZE = EStreamChannel_MAX + 1;

const ::google::protobuf::EnumDescriptor* EStreamChannel_descriptor();
inline const ::std::string& EStreamChannel_Name(EStreamChannel value) {
  return ::google::protobuf::internal::NameOfEnum(
    EStreamChannel_descriptor(), value);
}
inline bool EStreamChannel_Parse(
    const ::std::string& name, EStreamChannel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EStreamChannel>(
    EStreamChannel_descriptor(), name, value);
}
enum EStreamDiscoveryMessage {
  k_EStreamDiscoveryPingRequest = 1,
  k_EStreamDiscoveryPingResponse = 2
};
bool EStreamDiscoveryMessage_IsValid(int value);
const EStreamDiscoveryMessage EStreamDiscoveryMessage_MIN = k_EStreamDiscoveryPingRequest;
const EStreamDiscoveryMessage EStreamDiscoveryMessage_MAX = k_EStreamDiscoveryPingResponse;
const int EStreamDiscoveryMessage_ARRAYSIZE = EStreamDiscoveryMessage_MAX + 1;

const ::google::protobuf::EnumDescriptor* EStreamDiscoveryMessage_descriptor();
inline const ::std::string& EStreamDiscoveryMessage_Name(EStreamDiscoveryMessage value) {
  return ::google::protobuf::internal::NameOfEnum(
    EStreamDiscoveryMessage_descriptor(), value);
}
inline bool EStreamDiscoveryMessage_Parse(
    const ::std::string& name, EStreamDiscoveryMessage* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EStreamDiscoveryMessage>(
    EStreamDiscoveryMessage_descriptor(), name, value);
}
enum EStreamControlMessage {
  k_EStreamControlAuthenticationRequest = 1,
  k_EStreamControlAuthenticationResponse = 2,
  k_EStreamControlNegotiationInit = 3,
  k_EStreamControlNegotiationSetConfig = 4,
  k_EStreamControlNegotiationComplete = 5,
  k_EStreamControlClientHandshake = 6,
  k_EStreamControlServerHandshake = 7,
  k_EStreamControlStartNetworkTest = 8,
  k_EStreamControlKeepAlive = 9,
  k_EStreamControl_LAST_SETUP_MESSAGE = 15,
  k_EStreamControlStartAudioData = 50,
  k_EStreamControlStopAudioData = 51,
  k_EStreamControlStartVideoData = 52,
  k_EStreamControlStopVideoData = 53,
  k_EStreamControlInputMouseMotion = 54,
  k_EStreamControlInputMouseWheel = 55,
  k_EStreamControlInputMouseDown = 56,
  k_EStreamControlInputMouseUp = 57,
  k_EStreamControlInputKeyDown = 58,
  k_EStreamControlInputKeyUp = 59,
  k_EStreamControlInputGamepadAttached_OBSOLETE = 60,
  k_EStreamControlInputGamepadEvent_OBSOLETE = 61,
  k_EStreamControlInputGamepadDetached_OBSOLETE = 62,
  k_EStreamControlShowCursor = 63,
  k_EStreamControlHideCursor = 64,
  k_EStreamControlSetCursor = 65,
  k_EStreamControlGetCursorImage = 66,
  k_EStreamControlSetCursorImage = 67,
  k_EStreamControlDeleteCursor = 68,
  k_EStreamControlSetTargetFramerate = 69,
  k_EStreamControlInputLatencyTest = 70,
  k_EStreamControlGamepadRumble_OBSOLETE = 71,
  k_EStreamControlOverlayEnabled = 74,
  k_EStreamControlInputControllerAttached_OBSOLETE = 75,
  k_EStreamControlInputControllerState_OBSOLETE = 76,
  k_EStreamControlTriggerHapticPulse_OBSOLETE = 77,
  k_EStreamControlInputControllerDetached_OBSOLETE = 78,
  k_EStreamControlVideoDecoderInfo = 80,
  k_EStreamControlSetTitle = 81,
  k_EStreamControlSetIcon = 82,
  k_EStreamControlQuitRequest = 83,
  k_EStreamControlSetQoS = 87,
  k_EStreamControlInputControllerWirelessPresence_OBSOLETE = 88,
  k_EStreamControlSetGammaRamp = 89,
  k_EStreamControlVideoEncoderInfo = 90,
  k_EStreamControlInputControllerStateHID_OBSOLETE = 93,
  k_EStreamControlSetTargetBitrate = 94,
  k_EStreamControlSetControllerPairingEnabled_OBSOLETE = 95,
  k_EStreamControlSetControllerPairingResult_OBSOLETE = 96,
  k_EStreamControlTriggerControllerDisconnect_OBSOLETE = 97,
  k_EStreamControlSetActivity = 98,
  k_EStreamControlSetStreamingClientConfig = 99,
  k_EStreamControlSystemSuspend = 100,
  k_EStreamControlSetControllerSettings_OBSOLETE = 101,
  k_EStreamControlVirtualHereRequest = 102,
  k_EStreamControlVirtualHereReady = 103,
  k_EStreamControlVirtualHereShareDevice = 104,
  k_EStreamControlSetSpectatorMode = 105,
  k_EStreamControlRemoteHID = 106,
  k_EStreamControlStartMicrophoneData = 107,
  k_EStreamControlStopMicrophoneData = 108,
  k_EStreamControlInputText = 109,
  k_EStreamControlTouchConfigActive = 110,
  k_EStreamControlGetTouchConfigData = 111,
  k_EStreamControlSetTouchConfigData = 112,
  k_EStreamControlSaveTouchConfigLayout = 113,
  k_EStreamControlTouchActionSetActive = 114,
  k_EStreamControlGetTouchIconData = 115,
  k_EStreamControlSetTouchIconData = 116
};
bool EStreamControlMessage_IsValid(int value);
const EStreamControlMessage EStreamControlMessage_MIN = k_EStreamControlAuthenticationRequest;
const EStreamControlMessage EStreamControlMessage_MAX = k_EStreamControlSetTouchIconData;
const int EStreamControlMessage_ARRAYSIZE = EStreamControlMessage_MAX + 1;

const ::google::protobuf::EnumDescriptor* EStreamControlMessage_descriptor();
inline const ::std::string& EStreamControlMessage_Name(EStreamControlMessage value) {
  return ::google::protobuf::internal::NameOfEnum(
    EStreamControlMessage_descriptor(), value);
}
inline bool EStreamControlMessage_Parse(
    const ::std::string& name, EStreamControlMessage* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EStreamControlMessage>(
    EStreamControlMessage_descriptor(), name, value);
}
enum EStreamVersion {
  k_EStreamVersionNone = 0,
  k_EStreamVersionCurrent = 1
};
bool EStreamVersion_IsValid(int value);
const EStreamVersion EStreamVersion_MIN = k_EStreamVersionNone;
const EStreamVersion EStreamVersion_MAX = k_EStreamVersionCurrent;
const int EStreamVersion_ARRAYSIZE = EStreamVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* EStreamVersion_descriptor();
inline const ::std::string& EStreamVersion_Name(EStreamVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    EStreamVersion_descriptor(), value);
}
inline bool EStreamVersion_Parse(
    const ::std::string& name, EStreamVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EStreamVersion>(
    EStreamVersion_descriptor(), name, value);
}
enum EStreamAudioCodec {
  k_EStreamAudioCodecNone = 0,
  k_EStreamAudioCodecRaw = 1,
  k_EStreamAudioCodecVorbis = 2,
  k_EStreamAudioCodecOpus = 3,
  k_EStreamAudioCodecMP3 = 4,
  k_EStreamAudioCodecAAC = 5
};
bool EStreamAudioCodec_IsValid(int value);
const EStreamAudioCodec EStreamAudioCodec_MIN = k_EStreamAudioCodecNone;
const EStreamAudioCodec EStreamAudioCodec_MAX = k_EStreamAudioCodecAAC;
const int EStreamAudioCodec_ARRAYSIZE = EStreamAudioCodec_MAX + 1;

const ::google::protobuf::EnumDescriptor* EStreamAudioCodec_descriptor();
inline const ::std::string& EStreamAudioCodec_Name(EStreamAudioCodec value) {
  return ::google::protobuf::internal::NameOfEnum(
    EStreamAudioCodec_descriptor(), value);
}
inline bool EStreamAudioCodec_Parse(
    const ::std::string& name, EStreamAudioCodec* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EStreamAudioCodec>(
    EStreamAudioCodec_descriptor(), name, value);
}
enum EStreamVideoCodec {
  k_EStreamVideoCodecNone = 0,
  k_EStreamVideoCodecRaw = 1,
  k_EStreamVideoCodecVP8 = 2,
  k_EStreamVideoCodecVP9 = 3,
  k_EStreamVideoCodecH264 = 4,
  k_EStreamVideoCodecHEVC = 5,
  k_EStreamVideoCodecORBX1 = 6,
  k_EStreamVideoCodecORBX2 = 7
};
bool EStreamVideoCodec_IsValid(int value);
const EStreamVideoCodec EStreamVideoCodec_MIN = k_EStreamVideoCodecNone;
const EStreamVideoCodec EStreamVideoCodec_MAX = k_EStreamVideoCodecORBX2;
const int EStreamVideoCodec_ARRAYSIZE = EStreamVideoCodec_MAX + 1;

const ::google::protobuf::EnumDescriptor* EStreamVideoCodec_descriptor();
inline const ::std::string& EStreamVideoCodec_Name(EStreamVideoCodec value) {
  return ::google::protobuf::internal::NameOfEnum(
    EStreamVideoCodec_descriptor(), value);
}
inline bool EStreamVideoCodec_Parse(
    const ::std::string& name, EStreamVideoCodec* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EStreamVideoCodec>(
    EStreamVideoCodec_descriptor(), name, value);
}
enum EStreamQualityPreference {
  k_EStreamQualityFast = 1,
  k_EStreamQualityBalanced = 2,
  k_EStreamQualityBeautiful = 3
};
bool EStreamQualityPreference_IsValid(int value);
const EStreamQualityPreference EStreamQualityPreference_MIN = k_EStreamQualityFast;
const EStreamQualityPreference EStreamQualityPreference_MAX = k_EStreamQualityBeautiful;
const int EStreamQualityPreference_ARRAYSIZE = EStreamQualityPreference_MAX + 1;

const ::google::protobuf::EnumDescriptor* EStreamQualityPreference_descriptor();
inline const ::std::string& EStreamQualityPreference_Name(EStreamQualityPreference value) {
  return ::google::protobuf::internal::NameOfEnum(
    EStreamQualityPreference_descriptor(), value);
}
inline bool EStreamQualityPreference_Parse(
    const ::std::string& name, EStreamQualityPreference* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EStreamQualityPreference>(
    EStreamQualityPreference_descriptor(), name, value);
}
enum EStreamBitrate {
  k_EStreamBitrateAutodetect = -1,
  k_EStreamBitrateUnlimited = 0
};
bool EStreamBitrate_IsValid(int value);
const EStreamBitrate EStreamBitrate_MIN = k_EStreamBitrateAutodetect;
const EStreamBitrate EStreamBitrate_MAX = k_EStreamBitrateUnlimited;
const int EStreamBitrate_ARRAYSIZE = EStreamBitrate_MAX + 1;

const ::google::protobuf::EnumDescriptor* EStreamBitrate_descriptor();
inline const ::std::string& EStreamBitrate_Name(EStreamBitrate value) {
  return ::google::protobuf::internal::NameOfEnum(
    EStreamBitrate_descriptor(), value);
}
inline bool EStreamBitrate_Parse(
    const ::std::string& name, EStreamBitrate* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EStreamBitrate>(
    EStreamBitrate_descriptor(), name, value);
}
enum EStreamingDataType {
  k_EStreamingAudioData = 0,
  k_EStreamingVideoData = 1,
  k_EStreamingMicrophoneData = 2
};
bool EStreamingDataType_IsValid(int value);
const EStreamingDataType EStreamingDataType_MIN = k_EStreamingAudioData;
const EStreamingDataType EStreamingDataType_MAX = k_EStreamingMicrophoneData;
const int EStreamingDataType_ARRAYSIZE = EStreamingDataType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EStreamingDataType_descriptor();
inline const ::std::string& EStreamingDataType_Name(EStreamingDataType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EStreamingDataType_descriptor(), value);
}
inline bool EStreamingDataType_Parse(
    const ::std::string& name, EStreamingDataType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EStreamingDataType>(
    EStreamingDataType_descriptor(), name, value);
}
enum EStreamMouseButton {
  k_EStreamMouseButtonLeft = 1,
  k_EStreamMouseButtonRight = 2,
  k_EStreamMouseButtonMiddle = 16,
  k_EStreamMouseButtonX1 = 32,
  k_EStreamMouseButtonX2 = 64,
  k_EStreamMouseButtonUnknown = 4096
};
bool EStreamMouseButton_IsValid(int value);
const EStreamMouseButton EStreamMouseButton_MIN = k_EStreamMouseButtonLeft;
const EStreamMouseButton EStreamMouseButton_MAX = k_EStreamMouseButtonUnknown;
const int EStreamMouseButton_ARRAYSIZE = EStreamMouseButton_MAX + 1;

const ::google::protobuf::EnumDescriptor* EStreamMouseButton_descriptor();
inline const ::std::string& EStreamMouseButton_Name(EStreamMouseButton value) {
  return ::google::protobuf::internal::NameOfEnum(
    EStreamMouseButton_descriptor(), value);
}
inline bool EStreamMouseButton_Parse(
    const ::std::string& name, EStreamMouseButton* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EStreamMouseButton>(
    EStreamMouseButton_descriptor(), name, value);
}
enum EStreamMouseWheelDirection {
  k_EStreamMouseWheelUp = 120,
  k_EStreamMouseWheelDown = -120,
  k_EStreamMouseWheelLeft = 3,
  k_EStreamMouseWheelRight = 4
};
bool EStreamMouseWheelDirection_IsValid(int value);
const EStreamMouseWheelDirection EStreamMouseWheelDirection_MIN = k_EStreamMouseWheelDown;
const EStreamMouseWheelDirection EStreamMouseWheelDirection_MAX = k_EStreamMouseWheelUp;
const int EStreamMouseWheelDirection_ARRAYSIZE = EStreamMouseWheelDirection_MAX + 1;

const ::google::protobuf::EnumDescriptor* EStreamMouseWheelDirection_descriptor();
inline const ::std::string& EStreamMouseWheelDirection_Name(EStreamMouseWheelDirection value) {
  return ::google::protobuf::internal::NameOfEnum(
    EStreamMouseWheelDirection_descriptor(), value);
}
inline bool EStreamMouseWheelDirection_Parse(
    const ::std::string& name, EStreamMouseWheelDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EStreamMouseWheelDirection>(
    EStreamMouseWheelDirection_descriptor(), name, value);
}
enum EStreamGamepadInputType {
  k_EStreamGamepadInputInvalid = 0,
  k_EStreamGamepadInputDPadUp = 1,
  k_EStreamGamepadInputDPadDown = 2,
  k_EStreamGamepadInputDPadLeft = 4,
  k_EStreamGamepadInputDPadRight = 8,
  k_EStreamGamepadInputStart = 16,
  k_EStreamGamepadInputBack = 32,
  k_EStreamGamepadInputLeftThumb = 64,
  k_EStreamGamepadInputRightThumb = 128,
  k_EStreamGamepadInputLeftShoulder = 256,
  k_EStreamGamepadInputRightShoulder = 512,
  k_EStreamGamepadInputGuide = 1024,
  k_EStreamGamepadInputA = 4096,
  k_EStreamGamepadInputB = 8192,
  k_EStreamGamepadInputX = 16384,
  k_EStreamGamepadInputY = 32768,
  k_EStreamGamepadInputLeftThumbX = 65536,
  k_EStreamGamepadInputLeftThumbY = 131072,
  k_EStreamGamepadInputRightThumbX = 262144,
  k_EStreamGamepadInputRightThumbY = 524288,
  k_EStreamGamepadInputLeftTrigger = 1048576,
  k_EStreamGamepadInputRightTrigger = 2097152
};
bool EStreamGamepadInputType_IsValid(int value);
const EStreamGamepadInputType EStreamGamepadInputType_MIN = k_EStreamGamepadInputInvalid;
const EStreamGamepadInputType EStreamGamepadInputType_MAX = k_EStreamGamepadInputRightTrigger;
const int EStreamGamepadInputType_ARRAYSIZE = EStreamGamepadInputType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EStreamGamepadInputType_descriptor();
inline const ::std::string& EStreamGamepadInputType_Name(EStreamGamepadInputType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EStreamGamepadInputType_descriptor(), value);
}
inline bool EStreamGamepadInputType_Parse(
    const ::std::string& name, EStreamGamepadInputType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EStreamGamepadInputType>(
    EStreamGamepadInputType_descriptor(), name, value);
}
enum EStreamFramerateLimiter {
  k_EStreamFramerateSlowCapture = 1,
  k_EStreamFramerateSlowConvert = 2,
  k_EStreamFramerateSlowEncode = 4,
  k_EStreamFramerateSlowNetwork = 8,
  k_EStreamFramerateSlowDecode = 16,
  k_EStreamFramerateSlowGame = 32,
  k_EStreamFramerateSlowDisplay = 64
};
bool EStreamFramerateLimiter_IsValid(int value);
const EStreamFramerateLimiter EStreamFramerateLimiter_MIN = k_EStreamFramerateSlowCapture;
const EStreamFramerateLimiter EStreamFramerateLimiter_MAX = k_EStreamFramerateSlowDisplay;
const int EStreamFramerateLimiter_ARRAYSIZE = EStreamFramerateLimiter_MAX + 1;

const ::google::protobuf::EnumDescriptor* EStreamFramerateLimiter_descriptor();
inline const ::std::string& EStreamFramerateLimiter_Name(EStreamFramerateLimiter value) {
  return ::google::protobuf::internal::NameOfEnum(
    EStreamFramerateLimiter_descriptor(), value);
}
inline bool EStreamFramerateLimiter_Parse(
    const ::std::string& name, EStreamFramerateLimiter* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EStreamFramerateLimiter>(
    EStreamFramerateLimiter_descriptor(), name, value);
}
enum EStreamActivity {
  k_EStreamActivityIdle = 1,
  k_EStreamActivityGame = 2,
  k_EStreamActivityDesktop = 3
};
bool EStreamActivity_IsValid(int value);
const EStreamActivity EStreamActivity_MIN = k_EStreamActivityIdle;
const EStreamActivity EStreamActivity_MAX = k_EStreamActivityDesktop;
const int EStreamActivity_ARRAYSIZE = EStreamActivity_MAX + 1;

const ::google::protobuf::EnumDescriptor* EStreamActivity_descriptor();
inline const ::std::string& EStreamActivity_Name(EStreamActivity value) {
  return ::google::protobuf::internal::NameOfEnum(
    EStreamActivity_descriptor(), value);
}
inline bool EStreamActivity_Parse(
    const ::std::string& name, EStreamActivity* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EStreamActivity>(
    EStreamActivity_descriptor(), name, value);
}
enum EStreamDataMessage {
  k_EStreamDataPacket = 1,
  k_EStreamDataLost = 2
};
bool EStreamDataMessage_IsValid(int value);
const EStreamDataMessage EStreamDataMessage_MIN = k_EStreamDataPacket;
const EStreamDataMessage EStreamDataMessage_MAX = k_EStreamDataLost;
const int EStreamDataMessage_ARRAYSIZE = EStreamDataMessage_MAX + 1;

const ::google::protobuf::EnumDescriptor* EStreamDataMessage_descriptor();
inline const ::std::string& EStreamDataMessage_Name(EStreamDataMessage value) {
  return ::google::protobuf::internal::NameOfEnum(
    EStreamDataMessage_descriptor(), value);
}
inline bool EStreamDataMessage_Parse(
    const ::std::string& name, EStreamDataMessage* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EStreamDataMessage>(
    EStreamDataMessage_descriptor(), name, value);
}
enum EAudioFormat {
  k_EAudioFormatNone = 0,
  k_EAudioFormat16BitLittleEndian = 1,
  k_EAudioFormatFloat = 2
};
bool EAudioFormat_IsValid(int value);
const EAudioFormat EAudioFormat_MIN = k_EAudioFormatNone;
const EAudioFormat EAudioFormat_MAX = k_EAudioFormatFloat;
const int EAudioFormat_ARRAYSIZE = EAudioFormat_MAX + 1;

const ::google::protobuf::EnumDescriptor* EAudioFormat_descriptor();
inline const ::std::string& EAudioFormat_Name(EAudioFormat value) {
  return ::google::protobuf::internal::NameOfEnum(
    EAudioFormat_descriptor(), value);
}
inline bool EAudioFormat_Parse(
    const ::std::string& name, EAudioFormat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EAudioFormat>(
    EAudioFormat_descriptor(), name, value);
}
enum EVideoFormat {
  k_EVideoFormatNone = 0,
  k_EVideoFormatYV12 = 1,
  k_EVideoFormatAccel = 2
};
bool EVideoFormat_IsValid(int value);
const EVideoFormat EVideoFormat_MIN = k_EVideoFormatNone;
const EVideoFormat EVideoFormat_MAX = k_EVideoFormatAccel;
const int EVideoFormat_ARRAYSIZE = EVideoFormat_MAX + 1;

const ::google::protobuf::EnumDescriptor* EVideoFormat_descriptor();
inline const ::std::string& EVideoFormat_Name(EVideoFormat value) {
  return ::google::protobuf::internal::NameOfEnum(
    EVideoFormat_descriptor(), value);
}
inline bool EVideoFormat_Parse(
    const ::std::string& name, EVideoFormat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EVideoFormat>(
    EVideoFormat_descriptor(), name, value);
}
enum EStreamStatsMessage {
  k_EStreamStatsFrameEvents = 1,
  k_EStreamStatsDebugDump = 2,
  k_EStreamStatsLogMessage = 3,
  k_EStreamStatsLogUploadBegin = 4,
  k_EStreamStatsLogUploadData = 5,
  k_EStreamStatsLogUploadComplete = 6
};
bool EStreamStatsMessage_IsValid(int value);
const EStreamStatsMessage EStreamStatsMessage_MIN = k_EStreamStatsFrameEvents;
const EStreamStatsMessage EStreamStatsMessage_MAX = k_EStreamStatsLogUploadComplete;
const int EStreamStatsMessage_ARRAYSIZE = EStreamStatsMessage_MAX + 1;

const ::google::protobuf::EnumDescriptor* EStreamStatsMessage_descriptor();
inline const ::std::string& EStreamStatsMessage_Name(EStreamStatsMessage value) {
  return ::google::protobuf::internal::NameOfEnum(
    EStreamStatsMessage_descriptor(), value);
}
inline bool EStreamStatsMessage_Parse(
    const ::std::string& name, EStreamStatsMessage* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EStreamStatsMessage>(
    EStreamStatsMessage_descriptor(), name, value);
}
enum EStreamFrameEvent {
  k_EStreamInputEventStart = 0,
  k_EStreamInputEventSend = 1,
  k_EStreamInputEventRecv = 2,
  k_EStreamInputEventQueued = 3,
  k_EStreamInputEventHandled = 4,
  k_EStreamFrameEventStart = 5,
  k_EStreamFrameEventCaptureBegin = 6,
  k_EStreamFrameEventCaptureEnd = 7,
  k_EStreamFrameEventConvertBegin = 8,
  k_EStreamFrameEventConvertEnd = 9,
  k_EStreamFrameEventEncodeBegin = 10,
  k_EStreamFrameEventEncodeEnd = 11,
  k_EStreamFrameEventSend = 12,
  k_EStreamFrameEventRecv = 13,
  k_EStreamFrameEventDecodeBegin = 14,
  k_EStreamFrameEventDecodeEnd = 15,
  k_EStreamFrameEventUploadBegin = 16,
  k_EStreamFrameEventUploadEnd = 17,
  k_EStreamFrameEventComplete = 18
};
bool EStreamFrameEvent_IsValid(int value);
const EStreamFrameEvent EStreamFrameEvent_MIN = k_EStreamInputEventStart;
const EStreamFrameEvent EStreamFrameEvent_MAX = k_EStreamFrameEventComplete;
const int EStreamFrameEvent_ARRAYSIZE = EStreamFrameEvent_MAX + 1;

const ::google::protobuf::EnumDescriptor* EStreamFrameEvent_descriptor();
inline const ::std::string& EStreamFrameEvent_Name(EStreamFrameEvent value) {
  return ::google::protobuf::internal::NameOfEnum(
    EStreamFrameEvent_descriptor(), value);
}
inline bool EStreamFrameEvent_Parse(
    const ::std::string& name, EStreamFrameEvent* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EStreamFrameEvent>(
    EStreamFrameEvent_descriptor(), name, value);
}
enum EStreamFrameResult {
  k_EStreamFrameResultPending = 0,
  k_EStreamFrameResultDisplayed = 1,
  k_EStreamFrameResultDroppedNetworkSlow = 2,
  k_EStreamFrameResultDroppedNetworkLost = 3,
  k_EStreamFrameResultDroppedDecodeSlow = 4,
  k_EStreamFrameResultDroppedDecodeCorrupt = 5,
  k_EStreamFrameResultDroppedLate = 6,
  k_EStreamFrameResultDroppedReset = 7
};
bool EStreamFrameResult_IsValid(int value);
const EStreamFrameResult EStreamFrameResult_MIN = k_EStreamFrameResultPending;
const EStreamFrameResult EStreamFrameResult_MAX = k_EStreamFrameResultDroppedReset;
const int EStreamFrameResult_ARRAYSIZE = EStreamFrameResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* EStreamFrameResult_descriptor();
inline const ::std::string& EStreamFrameResult_Name(EStreamFrameResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    EStreamFrameResult_descriptor(), value);
}
inline bool EStreamFrameResult_Parse(
    const ::std::string& name, EStreamFrameResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EStreamFrameResult>(
    EStreamFrameResult_descriptor(), name, value);
}
enum EFrameAccumulatedStat {
  k_EFrameStatFPS = 0,
  k_EFrameStatCaptureDurationMS = 1,
  k_EFrameStatConvertDurationMS = 2,
  k_EFrameStatEncodeDurationMS = 3,
  k_EFrameStatSteamDurationMS = 4,
  k_EFrameStatServerDurationMS = 5,
  k_EFrameStatNetworkDurationMS = 6,
  k_EFrameStatDecodeDurationMS = 7,
  k_EFrameStatDisplayDurationMS = 8,
  k_EFrameStatClientDurationMS = 9,
  k_EFrameStatFrameDurationMS = 10,
  k_EFrameStatInputLatencyMS = 11,
  k_EFrameStatGameLatencyMS = 12,
  k_EFrameStatRoundTripLatencyMS = 13,
  k_EFrameStatPingTimeMS = 14,
  k_EFrameStatServerBitrateKbitPerSec = 15,
  k_EFrameStatClientBitrateKbitPerSec = 16,
  k_EFrameStatLinkBandwidthKbitPerSec = 17,
  k_EFrameStatPacketLossPercentage = 18
};
bool EFrameAccumulatedStat_IsValid(int value);
const EFrameAccumulatedStat EFrameAccumulatedStat_MIN = k_EFrameStatFPS;
const EFrameAccumulatedStat EFrameAccumulatedStat_MAX = k_EFrameStatPacketLossPercentage;
const int EFrameAccumulatedStat_ARRAYSIZE = EFrameAccumulatedStat_MAX + 1;

const ::google::protobuf::EnumDescriptor* EFrameAccumulatedStat_descriptor();
inline const ::std::string& EFrameAccumulatedStat_Name(EFrameAccumulatedStat value) {
  return ::google::protobuf::internal::NameOfEnum(
    EFrameAccumulatedStat_descriptor(), value);
}
inline bool EFrameAccumulatedStat_Parse(
    const ::std::string& name, EFrameAccumulatedStat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EFrameAccumulatedStat>(
    EFrameAccumulatedStat_descriptor(), name, value);
}
enum ELogFileType {
  k_ELogFileSystemBoot = 0,
  k_ELogFileSystemReset = 1,
  k_ELogFileSystemDebug = 2
};
bool ELogFileType_IsValid(int value);
const ELogFileType ELogFileType_MIN = k_ELogFileSystemBoot;
const ELogFileType ELogFileType_MAX = k_ELogFileSystemDebug;
const int ELogFileType_ARRAYSIZE = ELogFileType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ELogFileType_descriptor();
inline const ::std::string& ELogFileType_Name(ELogFileType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ELogFileType_descriptor(), value);
}
inline bool ELogFileType_Parse(
    const ::std::string& name, ELogFileType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ELogFileType>(
    ELogFileType_descriptor(), name, value);
}
// ===================================================================

class CDiscoveryPingRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CDiscoveryPingRequest) */ {
 public:
  CDiscoveryPingRequest();
  virtual ~CDiscoveryPingRequest();

  CDiscoveryPingRequest(const CDiscoveryPingRequest& from);

  inline CDiscoveryPingRequest& operator=(const CDiscoveryPingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CDiscoveryPingRequest(CDiscoveryPingRequest&& from) noexcept
    : CDiscoveryPingRequest() {
    *this = ::std::move(from);
  }

  inline CDiscoveryPingRequest& operator=(CDiscoveryPingRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CDiscoveryPingRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CDiscoveryPingRequest* internal_default_instance() {
    return reinterpret_cast<const CDiscoveryPingRequest*>(
               &_CDiscoveryPingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(CDiscoveryPingRequest* other);
  friend void swap(CDiscoveryPingRequest& a, CDiscoveryPingRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CDiscoveryPingRequest* New() const final {
    return CreateMaybeMessage<CDiscoveryPingRequest>(NULL);
  }

  CDiscoveryPingRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CDiscoveryPingRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CDiscoveryPingRequest& from);
  void MergeFrom(const CDiscoveryPingRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CDiscoveryPingRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 sequence = 1;
  bool has_sequence() const;
  void clear_sequence();
  static const int kSequenceFieldNumber = 1;
  ::google::protobuf::uint32 sequence() const;
  void set_sequence(::google::protobuf::uint32 value);

  // optional uint32 packet_size_requested = 2;
  bool has_packet_size_requested() const;
  void clear_packet_size_requested();
  static const int kPacketSizeRequestedFieldNumber = 2;
  ::google::protobuf::uint32 packet_size_requested() const;
  void set_packet_size_requested(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CDiscoveryPingRequest)
 private:
  void set_has_sequence();
  void clear_has_sequence();
  void set_has_packet_size_requested();
  void clear_has_packet_size_requested();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 sequence_;
  ::google::protobuf::uint32 packet_size_requested_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CDiscoveryPingResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CDiscoveryPingResponse) */ {
 public:
  CDiscoveryPingResponse();
  virtual ~CDiscoveryPingResponse();

  CDiscoveryPingResponse(const CDiscoveryPingResponse& from);

  inline CDiscoveryPingResponse& operator=(const CDiscoveryPingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CDiscoveryPingResponse(CDiscoveryPingResponse&& from) noexcept
    : CDiscoveryPingResponse() {
    *this = ::std::move(from);
  }

  inline CDiscoveryPingResponse& operator=(CDiscoveryPingResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CDiscoveryPingResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CDiscoveryPingResponse* internal_default_instance() {
    return reinterpret_cast<const CDiscoveryPingResponse*>(
               &_CDiscoveryPingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(CDiscoveryPingResponse* other);
  friend void swap(CDiscoveryPingResponse& a, CDiscoveryPingResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CDiscoveryPingResponse* New() const final {
    return CreateMaybeMessage<CDiscoveryPingResponse>(NULL);
  }

  CDiscoveryPingResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CDiscoveryPingResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CDiscoveryPingResponse& from);
  void MergeFrom(const CDiscoveryPingResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CDiscoveryPingResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 sequence = 1;
  bool has_sequence() const;
  void clear_sequence();
  static const int kSequenceFieldNumber = 1;
  ::google::protobuf::uint32 sequence() const;
  void set_sequence(::google::protobuf::uint32 value);

  // optional uint32 packet_size_received = 2;
  bool has_packet_size_received() const;
  void clear_packet_size_received();
  static const int kPacketSizeReceivedFieldNumber = 2;
  ::google::protobuf::uint32 packet_size_received() const;
  void set_packet_size_received(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CDiscoveryPingResponse)
 private:
  void set_has_sequence();
  void clear_has_sequence();
  void set_has_packet_size_received();
  void clear_has_packet_size_received();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 sequence_;
  ::google::protobuf::uint32 packet_size_received_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CStreamingClientHandshakeInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CStreamingClientHandshakeInfo) */ {
 public:
  CStreamingClientHandshakeInfo();
  virtual ~CStreamingClientHandshakeInfo();

  CStreamingClientHandshakeInfo(const CStreamingClientHandshakeInfo& from);

  inline CStreamingClientHandshakeInfo& operator=(const CStreamingClientHandshakeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CStreamingClientHandshakeInfo(CStreamingClientHandshakeInfo&& from) noexcept
    : CStreamingClientHandshakeInfo() {
    *this = ::std::move(from);
  }

  inline CStreamingClientHandshakeInfo& operator=(CStreamingClientHandshakeInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CStreamingClientHandshakeInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CStreamingClientHandshakeInfo* internal_default_instance() {
    return reinterpret_cast<const CStreamingClientHandshakeInfo*>(
               &_CStreamingClientHandshakeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(CStreamingClientHandshakeInfo* other);
  friend void swap(CStreamingClientHandshakeInfo& a, CStreamingClientHandshakeInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CStreamingClientHandshakeInfo* New() const final {
    return CreateMaybeMessage<CStreamingClientHandshakeInfo>(NULL);
  }

  CStreamingClientHandshakeInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CStreamingClientHandshakeInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CStreamingClientHandshakeInfo& from);
  void MergeFrom(const CStreamingClientHandshakeInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStreamingClientHandshakeInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 network_test = 2;
  bool has_network_test() const;
  void clear_network_test();
  static const int kNetworkTestFieldNumber = 2;
  ::google::protobuf::int32 network_test() const;
  void set_network_test(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CStreamingClientHandshakeInfo)
 private:
  void set_has_network_test();
  void clear_has_network_test();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 network_test_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CClientHandshakeMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CClientHandshakeMsg) */ {
 public:
  CClientHandshakeMsg();
  virtual ~CClientHandshakeMsg();

  CClientHandshakeMsg(const CClientHandshakeMsg& from);

  inline CClientHandshakeMsg& operator=(const CClientHandshakeMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CClientHandshakeMsg(CClientHandshakeMsg&& from) noexcept
    : CClientHandshakeMsg() {
    *this = ::std::move(from);
  }

  inline CClientHandshakeMsg& operator=(CClientHandshakeMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CClientHandshakeMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CClientHandshakeMsg* internal_default_instance() {
    return reinterpret_cast<const CClientHandshakeMsg*>(
               &_CClientHandshakeMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(CClientHandshakeMsg* other);
  friend void swap(CClientHandshakeMsg& a, CClientHandshakeMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CClientHandshakeMsg* New() const final {
    return CreateMaybeMessage<CClientHandshakeMsg>(NULL);
  }

  CClientHandshakeMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CClientHandshakeMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CClientHandshakeMsg& from);
  void MergeFrom(const CClientHandshakeMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CClientHandshakeMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .CStreamingClientHandshakeInfo info = 1;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 1;
  private:
  const ::CStreamingClientHandshakeInfo& _internal_info() const;
  public:
  const ::CStreamingClientHandshakeInfo& info() const;
  ::CStreamingClientHandshakeInfo* release_info();
  ::CStreamingClientHandshakeInfo* mutable_info();
  void set_allocated_info(::CStreamingClientHandshakeInfo* info);

  // @@protoc_insertion_point(class_scope:CClientHandshakeMsg)
 private:
  void set_has_info();
  void clear_has_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::CStreamingClientHandshakeInfo* info_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CStreamingServerHandshakeInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CStreamingServerHandshakeInfo) */ {
 public:
  CStreamingServerHandshakeInfo();
  virtual ~CStreamingServerHandshakeInfo();

  CStreamingServerHandshakeInfo(const CStreamingServerHandshakeInfo& from);

  inline CStreamingServerHandshakeInfo& operator=(const CStreamingServerHandshakeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CStreamingServerHandshakeInfo(CStreamingServerHandshakeInfo&& from) noexcept
    : CStreamingServerHandshakeInfo() {
    *this = ::std::move(from);
  }

  inline CStreamingServerHandshakeInfo& operator=(CStreamingServerHandshakeInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CStreamingServerHandshakeInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CStreamingServerHandshakeInfo* internal_default_instance() {
    return reinterpret_cast<const CStreamingServerHandshakeInfo*>(
               &_CStreamingServerHandshakeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(CStreamingServerHandshakeInfo* other);
  friend void swap(CStreamingServerHandshakeInfo& a, CStreamingServerHandshakeInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CStreamingServerHandshakeInfo* New() const final {
    return CreateMaybeMessage<CStreamingServerHandshakeInfo>(NULL);
  }

  CStreamingServerHandshakeInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CStreamingServerHandshakeInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CStreamingServerHandshakeInfo& from);
  void MergeFrom(const CStreamingServerHandshakeInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStreamingServerHandshakeInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 mtu = 1;
  bool has_mtu() const;
  void clear_mtu();
  static const int kMtuFieldNumber = 1;
  ::google::protobuf::int32 mtu() const;
  void set_mtu(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CStreamingServerHandshakeInfo)
 private:
  void set_has_mtu();
  void clear_has_mtu();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 mtu_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CServerHandshakeMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CServerHandshakeMsg) */ {
 public:
  CServerHandshakeMsg();
  virtual ~CServerHandshakeMsg();

  CServerHandshakeMsg(const CServerHandshakeMsg& from);

  inline CServerHandshakeMsg& operator=(const CServerHandshakeMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CServerHandshakeMsg(CServerHandshakeMsg&& from) noexcept
    : CServerHandshakeMsg() {
    *this = ::std::move(from);
  }

  inline CServerHandshakeMsg& operator=(CServerHandshakeMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CServerHandshakeMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CServerHandshakeMsg* internal_default_instance() {
    return reinterpret_cast<const CServerHandshakeMsg*>(
               &_CServerHandshakeMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(CServerHandshakeMsg* other);
  friend void swap(CServerHandshakeMsg& a, CServerHandshakeMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CServerHandshakeMsg* New() const final {
    return CreateMaybeMessage<CServerHandshakeMsg>(NULL);
  }

  CServerHandshakeMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CServerHandshakeMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CServerHandshakeMsg& from);
  void MergeFrom(const CServerHandshakeMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CServerHandshakeMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .CStreamingServerHandshakeInfo info = 1;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 1;
  private:
  const ::CStreamingServerHandshakeInfo& _internal_info() const;
  public:
  const ::CStreamingServerHandshakeInfo& info() const;
  ::CStreamingServerHandshakeInfo* release_info();
  ::CStreamingServerHandshakeInfo* mutable_info();
  void set_allocated_info(::CStreamingServerHandshakeInfo* info);

  // @@protoc_insertion_point(class_scope:CServerHandshakeMsg)
 private:
  void set_has_info();
  void clear_has_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::CStreamingServerHandshakeInfo* info_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CAuthenticationRequestMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CAuthenticationRequestMsg) */ {
 public:
  CAuthenticationRequestMsg();
  virtual ~CAuthenticationRequestMsg();

  CAuthenticationRequestMsg(const CAuthenticationRequestMsg& from);

  inline CAuthenticationRequestMsg& operator=(const CAuthenticationRequestMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CAuthenticationRequestMsg(CAuthenticationRequestMsg&& from) noexcept
    : CAuthenticationRequestMsg() {
    *this = ::std::move(from);
  }

  inline CAuthenticationRequestMsg& operator=(CAuthenticationRequestMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CAuthenticationRequestMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CAuthenticationRequestMsg* internal_default_instance() {
    return reinterpret_cast<const CAuthenticationRequestMsg*>(
               &_CAuthenticationRequestMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(CAuthenticationRequestMsg* other);
  friend void swap(CAuthenticationRequestMsg& a, CAuthenticationRequestMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CAuthenticationRequestMsg* New() const final {
    return CreateMaybeMessage<CAuthenticationRequestMsg>(NULL);
  }

  CAuthenticationRequestMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CAuthenticationRequestMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CAuthenticationRequestMsg& from);
  void MergeFrom(const CAuthenticationRequestMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthenticationRequestMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes token = 1;
  bool has_token() const;
  void clear_token();
  static const int kTokenFieldNumber = 1;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  #if LANG_CXX11
  void set_token(::std::string&& value);
  #endif
  void set_token(const char* value);
  void set_token(const void* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // optional .EStreamVersion version = 2 [default = k_EStreamVersionNone];
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  ::EStreamVersion version() const;
  void set_version(::EStreamVersion value);

  // @@protoc_insertion_point(class_scope:CAuthenticationRequestMsg)
 private:
  void set_has_token();
  void clear_has_token();
  void set_has_version();
  void clear_has_version();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  int version_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CAuthenticationResponseMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CAuthenticationResponseMsg) */ {
 public:
  CAuthenticationResponseMsg();
  virtual ~CAuthenticationResponseMsg();

  CAuthenticationResponseMsg(const CAuthenticationResponseMsg& from);

  inline CAuthenticationResponseMsg& operator=(const CAuthenticationResponseMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CAuthenticationResponseMsg(CAuthenticationResponseMsg&& from) noexcept
    : CAuthenticationResponseMsg() {
    *this = ::std::move(from);
  }

  inline CAuthenticationResponseMsg& operator=(CAuthenticationResponseMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CAuthenticationResponseMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CAuthenticationResponseMsg* internal_default_instance() {
    return reinterpret_cast<const CAuthenticationResponseMsg*>(
               &_CAuthenticationResponseMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(CAuthenticationResponseMsg* other);
  friend void swap(CAuthenticationResponseMsg& a, CAuthenticationResponseMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CAuthenticationResponseMsg* New() const final {
    return CreateMaybeMessage<CAuthenticationResponseMsg>(NULL);
  }

  CAuthenticationResponseMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CAuthenticationResponseMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CAuthenticationResponseMsg& from);
  void MergeFrom(const CAuthenticationResponseMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthenticationResponseMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CAuthenticationResponseMsg_AuthenticationResult AuthenticationResult;
  static const AuthenticationResult SUCCEEDED =
    CAuthenticationResponseMsg_AuthenticationResult_SUCCEEDED;
  static const AuthenticationResult FAILED =
    CAuthenticationResponseMsg_AuthenticationResult_FAILED;
  static inline bool AuthenticationResult_IsValid(int value) {
    return CAuthenticationResponseMsg_AuthenticationResult_IsValid(value);
  }
  static const AuthenticationResult AuthenticationResult_MIN =
    CAuthenticationResponseMsg_AuthenticationResult_AuthenticationResult_MIN;
  static const AuthenticationResult AuthenticationResult_MAX =
    CAuthenticationResponseMsg_AuthenticationResult_AuthenticationResult_MAX;
  static const int AuthenticationResult_ARRAYSIZE =
    CAuthenticationResponseMsg_AuthenticationResult_AuthenticationResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AuthenticationResult_descriptor() {
    return CAuthenticationResponseMsg_AuthenticationResult_descriptor();
  }
  static inline const ::std::string& AuthenticationResult_Name(AuthenticationResult value) {
    return CAuthenticationResponseMsg_AuthenticationResult_Name(value);
  }
  static inline bool AuthenticationResult_Parse(const ::std::string& name,
      AuthenticationResult* value) {
    return CAuthenticationResponseMsg_AuthenticationResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .CAuthenticationResponseMsg.AuthenticationResult result = 1 [default = SUCCEEDED];
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::CAuthenticationResponseMsg_AuthenticationResult result() const;
  void set_result(::CAuthenticationResponseMsg_AuthenticationResult value);

  // optional .EStreamVersion version = 2 [default = k_EStreamVersionNone];
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  ::EStreamVersion version() const;
  void set_version(::EStreamVersion value);

  // @@protoc_insertion_point(class_scope:CAuthenticationResponseMsg)
 private:
  void set_has_result();
  void clear_has_result();
  void set_has_version();
  void clear_has_version();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int result_;
  int version_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CKeepAliveMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CKeepAliveMsg) */ {
 public:
  CKeepAliveMsg();
  virtual ~CKeepAliveMsg();

  CKeepAliveMsg(const CKeepAliveMsg& from);

  inline CKeepAliveMsg& operator=(const CKeepAliveMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CKeepAliveMsg(CKeepAliveMsg&& from) noexcept
    : CKeepAliveMsg() {
    *this = ::std::move(from);
  }

  inline CKeepAliveMsg& operator=(CKeepAliveMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CKeepAliveMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CKeepAliveMsg* internal_default_instance() {
    return reinterpret_cast<const CKeepAliveMsg*>(
               &_CKeepAliveMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(CKeepAliveMsg* other);
  friend void swap(CKeepAliveMsg& a, CKeepAliveMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CKeepAliveMsg* New() const final {
    return CreateMaybeMessage<CKeepAliveMsg>(NULL);
  }

  CKeepAliveMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CKeepAliveMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CKeepAliveMsg& from);
  void MergeFrom(const CKeepAliveMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CKeepAliveMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CKeepAliveMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CStartNetworkTestMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CStartNetworkTestMsg) */ {
 public:
  CStartNetworkTestMsg();
  virtual ~CStartNetworkTestMsg();

  CStartNetworkTestMsg(const CStartNetworkTestMsg& from);

  inline CStartNetworkTestMsg& operator=(const CStartNetworkTestMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CStartNetworkTestMsg(CStartNetworkTestMsg&& from) noexcept
    : CStartNetworkTestMsg() {
    *this = ::std::move(from);
  }

  inline CStartNetworkTestMsg& operator=(CStartNetworkTestMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CStartNetworkTestMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CStartNetworkTestMsg* internal_default_instance() {
    return reinterpret_cast<const CStartNetworkTestMsg*>(
               &_CStartNetworkTestMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(CStartNetworkTestMsg* other);
  friend void swap(CStartNetworkTestMsg& a, CStartNetworkTestMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CStartNetworkTestMsg* New() const final {
    return CreateMaybeMessage<CStartNetworkTestMsg>(NULL);
  }

  CStartNetworkTestMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CStartNetworkTestMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CStartNetworkTestMsg& from);
  void MergeFrom(const CStartNetworkTestMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStartNetworkTestMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 frames = 1;
  bool has_frames() const;
  void clear_frames();
  static const int kFramesFieldNumber = 1;
  ::google::protobuf::uint32 frames() const;
  void set_frames(::google::protobuf::uint32 value);

  // optional uint32 framerate = 2;
  bool has_framerate() const;
  void clear_framerate();
  static const int kFramerateFieldNumber = 2;
  ::google::protobuf::uint32 framerate() const;
  void set_framerate(::google::protobuf::uint32 value);

  // optional uint32 bitrate_kbps = 3;
  bool has_bitrate_kbps() const;
  void clear_bitrate_kbps();
  static const int kBitrateKbpsFieldNumber = 3;
  ::google::protobuf::uint32 bitrate_kbps() const;
  void set_bitrate_kbps(::google::protobuf::uint32 value);

  // optional uint32 burst_bitrate_kbps = 4;
  bool has_burst_bitrate_kbps() const;
  void clear_burst_bitrate_kbps();
  static const int kBurstBitrateKbpsFieldNumber = 4;
  ::google::protobuf::uint32 burst_bitrate_kbps() const;
  void set_burst_bitrate_kbps(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CStartNetworkTestMsg)
 private:
  void set_has_frames();
  void clear_has_frames();
  void set_has_framerate();
  void clear_has_framerate();
  void set_has_bitrate_kbps();
  void clear_has_bitrate_kbps();
  void set_has_burst_bitrate_kbps();
  void clear_has_burst_bitrate_kbps();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 frames_;
  ::google::protobuf::uint32 framerate_;
  ::google::protobuf::uint32 bitrate_kbps_;
  ::google::protobuf::uint32 burst_bitrate_kbps_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CStreamVideoMode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CStreamVideoMode) */ {
 public:
  CStreamVideoMode();
  virtual ~CStreamVideoMode();

  CStreamVideoMode(const CStreamVideoMode& from);

  inline CStreamVideoMode& operator=(const CStreamVideoMode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CStreamVideoMode(CStreamVideoMode&& from) noexcept
    : CStreamVideoMode() {
    *this = ::std::move(from);
  }

  inline CStreamVideoMode& operator=(CStreamVideoMode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CStreamVideoMode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CStreamVideoMode* internal_default_instance() {
    return reinterpret_cast<const CStreamVideoMode*>(
               &_CStreamVideoMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(CStreamVideoMode* other);
  friend void swap(CStreamVideoMode& a, CStreamVideoMode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CStreamVideoMode* New() const final {
    return CreateMaybeMessage<CStreamVideoMode>(NULL);
  }

  CStreamVideoMode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CStreamVideoMode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CStreamVideoMode& from);
  void MergeFrom(const CStreamVideoMode& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStreamVideoMode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 width = 1;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 1;
  ::google::protobuf::uint32 width() const;
  void set_width(::google::protobuf::uint32 value);

  // required uint32 height = 2;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // optional uint32 refresh_rate = 3;
  bool has_refresh_rate() const;
  void clear_refresh_rate();
  static const int kRefreshRateFieldNumber = 3;
  ::google::protobuf::uint32 refresh_rate() const;
  void set_refresh_rate(::google::protobuf::uint32 value);

  // optional uint32 refresh_rate_numerator = 4;
  bool has_refresh_rate_numerator() const;
  void clear_refresh_rate_numerator();
  static const int kRefreshRateNumeratorFieldNumber = 4;
  ::google::protobuf::uint32 refresh_rate_numerator() const;
  void set_refresh_rate_numerator(::google::protobuf::uint32 value);

  // optional uint32 refresh_rate_denominator = 5;
  bool has_refresh_rate_denominator() const;
  void clear_refresh_rate_denominator();
  static const int kRefreshRateDenominatorFieldNumber = 5;
  ::google::protobuf::uint32 refresh_rate_denominator() const;
  void set_refresh_rate_denominator(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CStreamVideoMode)
 private:
  void set_has_width();
  void clear_has_width();
  void set_has_height();
  void clear_has_height();
  void set_has_refresh_rate();
  void clear_has_refresh_rate();
  void set_has_refresh_rate_numerator();
  void clear_has_refresh_rate_numerator();
  void set_has_refresh_rate_denominator();
  void clear_has_refresh_rate_denominator();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;
  ::google::protobuf::uint32 refresh_rate_;
  ::google::protobuf::uint32 refresh_rate_numerator_;
  ::google::protobuf::uint32 refresh_rate_denominator_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CStreamingClientCaps : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CStreamingClientCaps) */ {
 public:
  CStreamingClientCaps();
  virtual ~CStreamingClientCaps();

  CStreamingClientCaps(const CStreamingClientCaps& from);

  inline CStreamingClientCaps& operator=(const CStreamingClientCaps& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CStreamingClientCaps(CStreamingClientCaps&& from) noexcept
    : CStreamingClientCaps() {
    *this = ::std::move(from);
  }

  inline CStreamingClientCaps& operator=(CStreamingClientCaps&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CStreamingClientCaps& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CStreamingClientCaps* internal_default_instance() {
    return reinterpret_cast<const CStreamingClientCaps*>(
               &_CStreamingClientCaps_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(CStreamingClientCaps* other);
  friend void swap(CStreamingClientCaps& a, CStreamingClientCaps& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CStreamingClientCaps* New() const final {
    return CreateMaybeMessage<CStreamingClientCaps>(NULL);
  }

  CStreamingClientCaps* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CStreamingClientCaps>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CStreamingClientCaps& from);
  void MergeFrom(const CStreamingClientCaps& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStreamingClientCaps* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string system_info = 1;
  bool has_system_info() const;
  void clear_system_info();
  static const int kSystemInfoFieldNumber = 1;
  const ::std::string& system_info() const;
  void set_system_info(const ::std::string& value);
  #if LANG_CXX11
  void set_system_info(::std::string&& value);
  #endif
  void set_system_info(const char* value);
  void set_system_info(const char* value, size_t size);
  ::std::string* mutable_system_info();
  ::std::string* release_system_info();
  void set_allocated_system_info(::std::string* system_info);

  // optional int32 maximum_decode_bitrate_kbps = 3;
  bool has_maximum_decode_bitrate_kbps() const;
  void clear_maximum_decode_bitrate_kbps();
  static const int kMaximumDecodeBitrateKbpsFieldNumber = 3;
  ::google::protobuf::int32 maximum_decode_bitrate_kbps() const;
  void set_maximum_decode_bitrate_kbps(::google::protobuf::int32 value);

  // optional int32 maximum_burst_bitrate_kbps = 4;
  bool has_maximum_burst_bitrate_kbps() const;
  void clear_maximum_burst_bitrate_kbps();
  static const int kMaximumBurstBitrateKbpsFieldNumber = 4;
  ::google::protobuf::int32 maximum_burst_bitrate_kbps() const;
  void set_maximum_burst_bitrate_kbps(::google::protobuf::int32 value);

  // optional bool system_can_suspend = 2;
  bool has_system_can_suspend() const;
  void clear_system_can_suspend();
  static const int kSystemCanSuspendFieldNumber = 2;
  bool system_can_suspend() const;
  void set_system_can_suspend(bool value);

  // optional bool supports_video_hevc = 5;
  bool has_supports_video_hevc() const;
  void clear_supports_video_hevc();
  static const int kSupportsVideoHevcFieldNumber = 5;
  bool supports_video_hevc() const;
  void set_supports_video_hevc(bool value);

  // optional bool disable_steam_store = 6;
  bool has_disable_steam_store() const;
  void clear_disable_steam_store();
  static const int kDisableSteamStoreFieldNumber = 6;
  bool disable_steam_store() const;
  void set_disable_steam_store(bool value);

  // optional bool disable_client_cursor = 7;
  bool has_disable_client_cursor() const;
  void clear_disable_client_cursor();
  static const int kDisableClientCursorFieldNumber = 7;
  bool disable_client_cursor() const;
  void set_disable_client_cursor(bool value);

  // optional bool disable_intel_hardware_encoding = 8;
  bool has_disable_intel_hardware_encoding() const;
  void clear_disable_intel_hardware_encoding();
  static const int kDisableIntelHardwareEncodingFieldNumber = 8;
  bool disable_intel_hardware_encoding() const;
  void set_disable_intel_hardware_encoding(bool value);

  // optional bool disable_amd_hardware_encoding = 9;
  bool has_disable_amd_hardware_encoding() const;
  void clear_disable_amd_hardware_encoding();
  static const int kDisableAmdHardwareEncodingFieldNumber = 9;
  bool disable_amd_hardware_encoding() const;
  void set_disable_amd_hardware_encoding(bool value);

  // optional bool disable_nvidia_hardware_encoding = 10;
  bool has_disable_nvidia_hardware_encoding() const;
  void clear_disable_nvidia_hardware_encoding();
  static const int kDisableNvidiaHardwareEncodingFieldNumber = 10;
  bool disable_nvidia_hardware_encoding() const;
  void set_disable_nvidia_hardware_encoding(bool value);

  // @@protoc_insertion_point(class_scope:CStreamingClientCaps)
 private:
  void set_has_system_info();
  void clear_has_system_info();
  void set_has_system_can_suspend();
  void clear_has_system_can_suspend();
  void set_has_maximum_decode_bitrate_kbps();
  void clear_has_maximum_decode_bitrate_kbps();
  void set_has_maximum_burst_bitrate_kbps();
  void clear_has_maximum_burst_bitrate_kbps();
  void set_has_supports_video_hevc();
  void clear_has_supports_video_hevc();
  void set_has_disable_steam_store();
  void clear_has_disable_steam_store();
  void set_has_disable_client_cursor();
  void clear_has_disable_client_cursor();
  void set_has_disable_intel_hardware_encoding();
  void clear_has_disable_intel_hardware_encoding();
  void set_has_disable_amd_hardware_encoding();
  void clear_has_disable_amd_hardware_encoding();
  void set_has_disable_nvidia_hardware_encoding();
  void clear_has_disable_nvidia_hardware_encoding();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr system_info_;
  ::google::protobuf::int32 maximum_decode_bitrate_kbps_;
  ::google::protobuf::int32 maximum_burst_bitrate_kbps_;
  bool system_can_suspend_;
  bool supports_video_hevc_;
  bool disable_steam_store_;
  bool disable_client_cursor_;
  bool disable_intel_hardware_encoding_;
  bool disable_amd_hardware_encoding_;
  bool disable_nvidia_hardware_encoding_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CStreamingClientConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CStreamingClientConfig) */ {
 public:
  CStreamingClientConfig();
  virtual ~CStreamingClientConfig();

  CStreamingClientConfig(const CStreamingClientConfig& from);

  inline CStreamingClientConfig& operator=(const CStreamingClientConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CStreamingClientConfig(CStreamingClientConfig&& from) noexcept
    : CStreamingClientConfig() {
    *this = ::std::move(from);
  }

  inline CStreamingClientConfig& operator=(CStreamingClientConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CStreamingClientConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CStreamingClientConfig* internal_default_instance() {
    return reinterpret_cast<const CStreamingClientConfig*>(
               &_CStreamingClientConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(CStreamingClientConfig* other);
  friend void swap(CStreamingClientConfig& a, CStreamingClientConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CStreamingClientConfig* New() const final {
    return CreateMaybeMessage<CStreamingClientConfig>(NULL);
  }

  CStreamingClientConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CStreamingClientConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CStreamingClientConfig& from);
  void MergeFrom(const CStreamingClientConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStreamingClientConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 maximum_resolution_x = 2;
  bool has_maximum_resolution_x() const;
  void clear_maximum_resolution_x();
  static const int kMaximumResolutionXFieldNumber = 2;
  ::google::protobuf::uint32 maximum_resolution_x() const;
  void set_maximum_resolution_x(::google::protobuf::uint32 value);

  // optional uint32 maximum_resolution_y = 3;
  bool has_maximum_resolution_y() const;
  void clear_maximum_resolution_y();
  static const int kMaximumResolutionYFieldNumber = 3;
  ::google::protobuf::uint32 maximum_resolution_y() const;
  void set_maximum_resolution_y(::google::protobuf::uint32 value);

  // optional uint32 maximum_framerate_numerator = 4;
  bool has_maximum_framerate_numerator() const;
  void clear_maximum_framerate_numerator();
  static const int kMaximumFramerateNumeratorFieldNumber = 4;
  ::google::protobuf::uint32 maximum_framerate_numerator() const;
  void set_maximum_framerate_numerator(::google::protobuf::uint32 value);

  // optional uint32 maximum_framerate_denominator = 5;
  bool has_maximum_framerate_denominator() const;
  void clear_maximum_framerate_denominator();
  static const int kMaximumFramerateDenominatorFieldNumber = 5;
  ::google::protobuf::uint32 maximum_framerate_denominator() const;
  void set_maximum_framerate_denominator(::google::protobuf::uint32 value);

  // optional bool enable_performance_overlay = 8 [default = false];
  bool has_enable_performance_overlay() const;
  void clear_enable_performance_overlay();
  static const int kEnablePerformanceOverlayFieldNumber = 8;
  bool enable_performance_overlay() const;
  void set_enable_performance_overlay(bool value);

  // optional bool enable_video_hevc = 13 [default = false];
  bool has_enable_video_hevc() const;
  void clear_enable_video_hevc();
  static const int kEnableVideoHevcFieldNumber = 13;
  bool enable_video_hevc() const;
  void set_enable_video_hevc(bool value);

  // optional .EStreamQualityPreference quality = 1 [default = k_EStreamQualityBalanced];
  bool has_quality() const;
  void clear_quality();
  static const int kQualityFieldNumber = 1;
  ::EStreamQualityPreference quality() const;
  void set_quality(::EStreamQualityPreference value);

  // optional int32 maximum_bitrate_kbps = 6 [default = -1];
  bool has_maximum_bitrate_kbps() const;
  void clear_maximum_bitrate_kbps();
  static const int kMaximumBitrateKbpsFieldNumber = 6;
  ::google::protobuf::int32 maximum_bitrate_kbps() const;
  void set_maximum_bitrate_kbps(::google::protobuf::int32 value);

  // optional bool enable_hardware_decoding = 7 [default = true];
  bool has_enable_hardware_decoding() const;
  void clear_enable_hardware_decoding();
  static const int kEnableHardwareDecodingFieldNumber = 7;
  bool enable_hardware_decoding() const;
  void set_enable_hardware_decoding(bool value);

  // optional bool enable_video_streaming = 9 [default = true];
  bool has_enable_video_streaming() const;
  void clear_enable_video_streaming();
  static const int kEnableVideoStreamingFieldNumber = 9;
  bool enable_video_streaming() const;
  void set_enable_video_streaming(bool value);

  // optional bool enable_audio_streaming = 10 [default = true];
  bool has_enable_audio_streaming() const;
  void clear_enable_audio_streaming();
  static const int kEnableAudioStreamingFieldNumber = 10;
  bool enable_audio_streaming() const;
  void set_enable_audio_streaming(bool value);

  // optional bool enable_input_streaming = 11 [default = true];
  bool has_enable_input_streaming() const;
  void clear_enable_input_streaming();
  static const int kEnableInputStreamingFieldNumber = 11;
  bool enable_input_streaming() const;
  void set_enable_input_streaming(bool value);

  // optional int32 audio_channels = 12 [default = 2];
  bool has_audio_channels() const;
  void clear_audio_channels();
  static const int kAudioChannelsFieldNumber = 12;
  ::google::protobuf::int32 audio_channels() const;
  void set_audio_channels(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CStreamingClientConfig)
 private:
  void set_has_quality();
  void clear_has_quality();
  void set_has_maximum_resolution_x();
  void clear_has_maximum_resolution_x();
  void set_has_maximum_resolution_y();
  void clear_has_maximum_resolution_y();
  void set_has_maximum_framerate_numerator();
  void clear_has_maximum_framerate_numerator();
  void set_has_maximum_framerate_denominator();
  void clear_has_maximum_framerate_denominator();
  void set_has_maximum_bitrate_kbps();
  void clear_has_maximum_bitrate_kbps();
  void set_has_enable_hardware_decoding();
  void clear_has_enable_hardware_decoding();
  void set_has_enable_performance_overlay();
  void clear_has_enable_performance_overlay();
  void set_has_enable_video_streaming();
  void clear_has_enable_video_streaming();
  void set_has_enable_audio_streaming();
  void clear_has_enable_audio_streaming();
  void set_has_enable_input_streaming();
  void clear_has_enable_input_streaming();
  void set_has_audio_channels();
  void clear_has_audio_channels();
  void set_has_enable_video_hevc();
  void clear_has_enable_video_hevc();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 maximum_resolution_x_;
  ::google::protobuf::uint32 maximum_resolution_y_;
  ::google::protobuf::uint32 maximum_framerate_numerator_;
  ::google::protobuf::uint32 maximum_framerate_denominator_;
  bool enable_performance_overlay_;
  bool enable_video_hevc_;
  int quality_;
  ::google::protobuf::int32 maximum_bitrate_kbps_;
  bool enable_hardware_decoding_;
  bool enable_video_streaming_;
  bool enable_audio_streaming_;
  bool enable_input_streaming_;
  ::google::protobuf::int32 audio_channels_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CStreamingServerConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CStreamingServerConfig) */ {
 public:
  CStreamingServerConfig();
  virtual ~CStreamingServerConfig();

  CStreamingServerConfig(const CStreamingServerConfig& from);

  inline CStreamingServerConfig& operator=(const CStreamingServerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CStreamingServerConfig(CStreamingServerConfig&& from) noexcept
    : CStreamingServerConfig() {
    *this = ::std::move(from);
  }

  inline CStreamingServerConfig& operator=(CStreamingServerConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CStreamingServerConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CStreamingServerConfig* internal_default_instance() {
    return reinterpret_cast<const CStreamingServerConfig*>(
               &_CStreamingServerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(CStreamingServerConfig* other);
  friend void swap(CStreamingServerConfig& a, CStreamingServerConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CStreamingServerConfig* New() const final {
    return CreateMaybeMessage<CStreamingServerConfig>(NULL);
  }

  CStreamingServerConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CStreamingServerConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CStreamingServerConfig& from);
  void MergeFrom(const CStreamingServerConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStreamingServerConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool change_desktop_resolution = 1;
  bool has_change_desktop_resolution() const;
  void clear_change_desktop_resolution();
  static const int kChangeDesktopResolutionFieldNumber = 1;
  bool change_desktop_resolution() const;
  void set_change_desktop_resolution(bool value);

  // optional bool dynamically_adjust_resolution = 2;
  bool has_dynamically_adjust_resolution() const;
  void clear_dynamically_adjust_resolution();
  static const int kDynamicallyAdjustResolutionFieldNumber = 2;
  bool dynamically_adjust_resolution() const;
  void set_dynamically_adjust_resolution(bool value);

  // optional bool enable_capture_nvfbc = 3;
  bool has_enable_capture_nvfbc() const;
  void clear_enable_capture_nvfbc();
  static const int kEnableCaptureNvfbcFieldNumber = 3;
  bool enable_capture_nvfbc() const;
  void set_enable_capture_nvfbc(bool value);

  // optional bool enable_hardware_encoding_nvidia = 4;
  bool has_enable_hardware_encoding_nvidia() const;
  void clear_enable_hardware_encoding_nvidia();
  static const int kEnableHardwareEncodingNvidiaFieldNumber = 4;
  bool enable_hardware_encoding_nvidia() const;
  void set_enable_hardware_encoding_nvidia(bool value);

  // optional bool enable_hardware_encoding_amd = 5;
  bool has_enable_hardware_encoding_amd() const;
  void clear_enable_hardware_encoding_amd();
  static const int kEnableHardwareEncodingAmdFieldNumber = 5;
  bool enable_hardware_encoding_amd() const;
  void set_enable_hardware_encoding_amd(bool value);

  // optional bool enable_hardware_encoding_intel = 6;
  bool has_enable_hardware_encoding_intel() const;
  void clear_enable_hardware_encoding_intel();
  static const int kEnableHardwareEncodingIntelFieldNumber = 6;
  bool enable_hardware_encoding_intel() const;
  void set_enable_hardware_encoding_intel(bool value);

  // optional bool enable_traffic_priority = 8;
  bool has_enable_traffic_priority() const;
  void clear_enable_traffic_priority();
  static const int kEnableTrafficPriorityFieldNumber = 8;
  bool enable_traffic_priority() const;
  void set_enable_traffic_priority(bool value);

  // optional int32 software_encoding_threads = 7;
  bool has_software_encoding_threads() const;
  void clear_software_encoding_threads();
  static const int kSoftwareEncodingThreadsFieldNumber = 7;
  ::google::protobuf::int32 software_encoding_threads() const;
  void set_software_encoding_threads(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CStreamingServerConfig)
 private:
  void set_has_change_desktop_resolution();
  void clear_has_change_desktop_resolution();
  void set_has_dynamically_adjust_resolution();
  void clear_has_dynamically_adjust_resolution();
  void set_has_enable_capture_nvfbc();
  void clear_has_enable_capture_nvfbc();
  void set_has_enable_hardware_encoding_nvidia();
  void clear_has_enable_hardware_encoding_nvidia();
  void set_has_enable_hardware_encoding_amd();
  void clear_has_enable_hardware_encoding_amd();
  void set_has_enable_hardware_encoding_intel();
  void clear_has_enable_hardware_encoding_intel();
  void set_has_software_encoding_threads();
  void clear_has_software_encoding_threads();
  void set_has_enable_traffic_priority();
  void clear_has_enable_traffic_priority();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool change_desktop_resolution_;
  bool dynamically_adjust_resolution_;
  bool enable_capture_nvfbc_;
  bool enable_hardware_encoding_nvidia_;
  bool enable_hardware_encoding_amd_;
  bool enable_hardware_encoding_intel_;
  bool enable_traffic_priority_;
  ::google::protobuf::int32 software_encoding_threads_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CNegotiatedConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CNegotiatedConfig) */ {
 public:
  CNegotiatedConfig();
  virtual ~CNegotiatedConfig();

  CNegotiatedConfig(const CNegotiatedConfig& from);

  inline CNegotiatedConfig& operator=(const CNegotiatedConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CNegotiatedConfig(CNegotiatedConfig&& from) noexcept
    : CNegotiatedConfig() {
    *this = ::std::move(from);
  }

  inline CNegotiatedConfig& operator=(CNegotiatedConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CNegotiatedConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CNegotiatedConfig* internal_default_instance() {
    return reinterpret_cast<const CNegotiatedConfig*>(
               &_CNegotiatedConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(CNegotiatedConfig* other);
  friend void swap(CNegotiatedConfig& a, CNegotiatedConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CNegotiatedConfig* New() const final {
    return CreateMaybeMessage<CNegotiatedConfig>(NULL);
  }

  CNegotiatedConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CNegotiatedConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CNegotiatedConfig& from);
  void MergeFrom(const CNegotiatedConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CNegotiatedConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CStreamVideoMode available_video_modes = 4;
  int available_video_modes_size() const;
  void clear_available_video_modes();
  static const int kAvailableVideoModesFieldNumber = 4;
  ::CStreamVideoMode* mutable_available_video_modes(int index);
  ::google::protobuf::RepeatedPtrField< ::CStreamVideoMode >*
      mutable_available_video_modes();
  const ::CStreamVideoMode& available_video_modes(int index) const;
  ::CStreamVideoMode* add_available_video_modes();
  const ::google::protobuf::RepeatedPtrField< ::CStreamVideoMode >&
      available_video_modes() const;

  // optional .EStreamAudioCodec selected_audio_codec = 2 [default = k_EStreamAudioCodecNone];
  bool has_selected_audio_codec() const;
  void clear_selected_audio_codec();
  static const int kSelectedAudioCodecFieldNumber = 2;
  ::EStreamAudioCodec selected_audio_codec() const;
  void set_selected_audio_codec(::EStreamAudioCodec value);

  // optional .EStreamVideoCodec selected_video_codec = 3 [default = k_EStreamVideoCodecNone];
  bool has_selected_video_codec() const;
  void clear_selected_video_codec();
  static const int kSelectedVideoCodecFieldNumber = 3;
  ::EStreamVideoCodec selected_video_codec() const;
  void set_selected_video_codec(::EStreamVideoCodec value);

  // optional bool reliable_data = 1;
  bool has_reliable_data() const;
  void clear_reliable_data();
  static const int kReliableDataFieldNumber = 1;
  bool reliable_data() const;
  void set_reliable_data(bool value);

  // optional bool enable_remote_hid = 5;
  bool has_enable_remote_hid() const;
  void clear_enable_remote_hid();
  static const int kEnableRemoteHidFieldNumber = 5;
  bool enable_remote_hid() const;
  void set_enable_remote_hid(bool value);

  // @@protoc_insertion_point(class_scope:CNegotiatedConfig)
 private:
  void set_has_reliable_data();
  void clear_has_reliable_data();
  void set_has_selected_audio_codec();
  void clear_has_selected_audio_codec();
  void set_has_selected_video_codec();
  void clear_has_selected_video_codec();
  void set_has_enable_remote_hid();
  void clear_has_enable_remote_hid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::CStreamVideoMode > available_video_modes_;
  int selected_audio_codec_;
  int selected_video_codec_;
  bool reliable_data_;
  bool enable_remote_hid_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CNegotiationInitMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CNegotiationInitMsg) */ {
 public:
  CNegotiationInitMsg();
  virtual ~CNegotiationInitMsg();

  CNegotiationInitMsg(const CNegotiationInitMsg& from);

  inline CNegotiationInitMsg& operator=(const CNegotiationInitMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CNegotiationInitMsg(CNegotiationInitMsg&& from) noexcept
    : CNegotiationInitMsg() {
    *this = ::std::move(from);
  }

  inline CNegotiationInitMsg& operator=(CNegotiationInitMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CNegotiationInitMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CNegotiationInitMsg* internal_default_instance() {
    return reinterpret_cast<const CNegotiationInitMsg*>(
               &_CNegotiationInitMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(CNegotiationInitMsg* other);
  friend void swap(CNegotiationInitMsg& a, CNegotiationInitMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CNegotiationInitMsg* New() const final {
    return CreateMaybeMessage<CNegotiationInitMsg>(NULL);
  }

  CNegotiationInitMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CNegotiationInitMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CNegotiationInitMsg& from);
  void MergeFrom(const CNegotiationInitMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CNegotiationInitMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .EStreamAudioCodec supported_audio_codecs = 2;
  int supported_audio_codecs_size() const;
  void clear_supported_audio_codecs();
  static const int kSupportedAudioCodecsFieldNumber = 2;
  ::EStreamAudioCodec supported_audio_codecs(int index) const;
  void set_supported_audio_codecs(int index, ::EStreamAudioCodec value);
  void add_supported_audio_codecs(::EStreamAudioCodec value);
  const ::google::protobuf::RepeatedField<int>& supported_audio_codecs() const;
  ::google::protobuf::RepeatedField<int>* mutable_supported_audio_codecs();

  // repeated .EStreamVideoCodec supported_video_codecs = 3;
  int supported_video_codecs_size() const;
  void clear_supported_video_codecs();
  static const int kSupportedVideoCodecsFieldNumber = 3;
  ::EStreamVideoCodec supported_video_codecs(int index) const;
  void set_supported_video_codecs(int index, ::EStreamVideoCodec value);
  void add_supported_video_codecs(::EStreamVideoCodec value);
  const ::google::protobuf::RepeatedField<int>& supported_video_codecs() const;
  ::google::protobuf::RepeatedField<int>* mutable_supported_video_codecs();

  // optional bool reliable_data = 1;
  bool has_reliable_data() const;
  void clear_reliable_data();
  static const int kReliableDataFieldNumber = 1;
  bool reliable_data() const;
  void set_reliable_data(bool value);

  // optional bool supports_remote_hid = 4;
  bool has_supports_remote_hid() const;
  void clear_supports_remote_hid();
  static const int kSupportsRemoteHidFieldNumber = 4;
  bool supports_remote_hid() const;
  void set_supports_remote_hid(bool value);

  // @@protoc_insertion_point(class_scope:CNegotiationInitMsg)
 private:
  void set_has_reliable_data();
  void clear_has_reliable_data();
  void set_has_supports_remote_hid();
  void clear_has_supports_remote_hid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField<int> supported_audio_codecs_;
  ::google::protobuf::RepeatedField<int> supported_video_codecs_;
  bool reliable_data_;
  bool supports_remote_hid_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CNegotiationSetConfigMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CNegotiationSetConfigMsg) */ {
 public:
  CNegotiationSetConfigMsg();
  virtual ~CNegotiationSetConfigMsg();

  CNegotiationSetConfigMsg(const CNegotiationSetConfigMsg& from);

  inline CNegotiationSetConfigMsg& operator=(const CNegotiationSetConfigMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CNegotiationSetConfigMsg(CNegotiationSetConfigMsg&& from) noexcept
    : CNegotiationSetConfigMsg() {
    *this = ::std::move(from);
  }

  inline CNegotiationSetConfigMsg& operator=(CNegotiationSetConfigMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CNegotiationSetConfigMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CNegotiationSetConfigMsg* internal_default_instance() {
    return reinterpret_cast<const CNegotiationSetConfigMsg*>(
               &_CNegotiationSetConfigMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(CNegotiationSetConfigMsg* other);
  friend void swap(CNegotiationSetConfigMsg& a, CNegotiationSetConfigMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CNegotiationSetConfigMsg* New() const final {
    return CreateMaybeMessage<CNegotiationSetConfigMsg>(NULL);
  }

  CNegotiationSetConfigMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CNegotiationSetConfigMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CNegotiationSetConfigMsg& from);
  void MergeFrom(const CNegotiationSetConfigMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CNegotiationSetConfigMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .CNegotiatedConfig config = 1;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 1;
  private:
  const ::CNegotiatedConfig& _internal_config() const;
  public:
  const ::CNegotiatedConfig& config() const;
  ::CNegotiatedConfig* release_config();
  ::CNegotiatedConfig* mutable_config();
  void set_allocated_config(::CNegotiatedConfig* config);

  // optional .CStreamingClientConfig streaming_client_config = 2;
  bool has_streaming_client_config() const;
  void clear_streaming_client_config();
  static const int kStreamingClientConfigFieldNumber = 2;
  private:
  const ::CStreamingClientConfig& _internal_streaming_client_config() const;
  public:
  const ::CStreamingClientConfig& streaming_client_config() const;
  ::CStreamingClientConfig* release_streaming_client_config();
  ::CStreamingClientConfig* mutable_streaming_client_config();
  void set_allocated_streaming_client_config(::CStreamingClientConfig* streaming_client_config);

  // optional .CStreamingClientCaps streaming_client_caps = 3;
  bool has_streaming_client_caps() const;
  void clear_streaming_client_caps();
  static const int kStreamingClientCapsFieldNumber = 3;
  private:
  const ::CStreamingClientCaps& _internal_streaming_client_caps() const;
  public:
  const ::CStreamingClientCaps& streaming_client_caps() const;
  ::CStreamingClientCaps* release_streaming_client_caps();
  ::CStreamingClientCaps* mutable_streaming_client_caps();
  void set_allocated_streaming_client_caps(::CStreamingClientCaps* streaming_client_caps);

  // @@protoc_insertion_point(class_scope:CNegotiationSetConfigMsg)
 private:
  void set_has_config();
  void clear_has_config();
  void set_has_streaming_client_config();
  void clear_has_streaming_client_config();
  void set_has_streaming_client_caps();
  void clear_has_streaming_client_caps();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::CNegotiatedConfig* config_;
  ::CStreamingClientConfig* streaming_client_config_;
  ::CStreamingClientCaps* streaming_client_caps_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CNegotiationCompleteMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CNegotiationCompleteMsg) */ {
 public:
  CNegotiationCompleteMsg();
  virtual ~CNegotiationCompleteMsg();

  CNegotiationCompleteMsg(const CNegotiationCompleteMsg& from);

  inline CNegotiationCompleteMsg& operator=(const CNegotiationCompleteMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CNegotiationCompleteMsg(CNegotiationCompleteMsg&& from) noexcept
    : CNegotiationCompleteMsg() {
    *this = ::std::move(from);
  }

  inline CNegotiationCompleteMsg& operator=(CNegotiationCompleteMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CNegotiationCompleteMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CNegotiationCompleteMsg* internal_default_instance() {
    return reinterpret_cast<const CNegotiationCompleteMsg*>(
               &_CNegotiationCompleteMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(CNegotiationCompleteMsg* other);
  friend void swap(CNegotiationCompleteMsg& a, CNegotiationCompleteMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CNegotiationCompleteMsg* New() const final {
    return CreateMaybeMessage<CNegotiationCompleteMsg>(NULL);
  }

  CNegotiationCompleteMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CNegotiationCompleteMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CNegotiationCompleteMsg& from);
  void MergeFrom(const CNegotiationCompleteMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CNegotiationCompleteMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CNegotiationCompleteMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CStartAudioDataMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CStartAudioDataMsg) */ {
 public:
  CStartAudioDataMsg();
  virtual ~CStartAudioDataMsg();

  CStartAudioDataMsg(const CStartAudioDataMsg& from);

  inline CStartAudioDataMsg& operator=(const CStartAudioDataMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CStartAudioDataMsg(CStartAudioDataMsg&& from) noexcept
    : CStartAudioDataMsg() {
    *this = ::std::move(from);
  }

  inline CStartAudioDataMsg& operator=(CStartAudioDataMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CStartAudioDataMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CStartAudioDataMsg* internal_default_instance() {
    return reinterpret_cast<const CStartAudioDataMsg*>(
               &_CStartAudioDataMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(CStartAudioDataMsg* other);
  friend void swap(CStartAudioDataMsg& a, CStartAudioDataMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CStartAudioDataMsg* New() const final {
    return CreateMaybeMessage<CStartAudioDataMsg>(NULL);
  }

  CStartAudioDataMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CStartAudioDataMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CStartAudioDataMsg& from);
  void MergeFrom(const CStartAudioDataMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStartAudioDataMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes codec_data = 4;
  bool has_codec_data() const;
  void clear_codec_data();
  static const int kCodecDataFieldNumber = 4;
  const ::std::string& codec_data() const;
  void set_codec_data(const ::std::string& value);
  #if LANG_CXX11
  void set_codec_data(::std::string&& value);
  #endif
  void set_codec_data(const char* value);
  void set_codec_data(const void* value, size_t size);
  ::std::string* mutable_codec_data();
  ::std::string* release_codec_data();
  void set_allocated_codec_data(::std::string* codec_data);

  // required uint32 channel = 2;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 2;
  ::google::protobuf::uint32 channel() const;
  void set_channel(::google::protobuf::uint32 value);

  // optional .EStreamAudioCodec codec = 3 [default = k_EStreamAudioCodecNone];
  bool has_codec() const;
  void clear_codec();
  static const int kCodecFieldNumber = 3;
  ::EStreamAudioCodec codec() const;
  void set_codec(::EStreamAudioCodec value);

  // optional uint32 frequency = 5;
  bool has_frequency() const;
  void clear_frequency();
  static const int kFrequencyFieldNumber = 5;
  ::google::protobuf::uint32 frequency() const;
  void set_frequency(::google::protobuf::uint32 value);

  // optional uint32 channels = 6;
  bool has_channels() const;
  void clear_channels();
  static const int kChannelsFieldNumber = 6;
  ::google::protobuf::uint32 channels() const;
  void set_channels(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CStartAudioDataMsg)
 private:
  void set_has_channel();
  void clear_has_channel();
  void set_has_codec();
  void clear_has_codec();
  void set_has_codec_data();
  void clear_has_codec_data();
  void set_has_frequency();
  void clear_has_frequency();
  void set_has_channels();
  void clear_has_channels();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr codec_data_;
  ::google::protobuf::uint32 channel_;
  int codec_;
  ::google::protobuf::uint32 frequency_;
  ::google::protobuf::uint32 channels_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CStopAudioDataMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CStopAudioDataMsg) */ {
 public:
  CStopAudioDataMsg();
  virtual ~CStopAudioDataMsg();

  CStopAudioDataMsg(const CStopAudioDataMsg& from);

  inline CStopAudioDataMsg& operator=(const CStopAudioDataMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CStopAudioDataMsg(CStopAudioDataMsg&& from) noexcept
    : CStopAudioDataMsg() {
    *this = ::std::move(from);
  }

  inline CStopAudioDataMsg& operator=(CStopAudioDataMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CStopAudioDataMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CStopAudioDataMsg* internal_default_instance() {
    return reinterpret_cast<const CStopAudioDataMsg*>(
               &_CStopAudioDataMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(CStopAudioDataMsg* other);
  friend void swap(CStopAudioDataMsg& a, CStopAudioDataMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CStopAudioDataMsg* New() const final {
    return CreateMaybeMessage<CStopAudioDataMsg>(NULL);
  }

  CStopAudioDataMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CStopAudioDataMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CStopAudioDataMsg& from);
  void MergeFrom(const CStopAudioDataMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStopAudioDataMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CStopAudioDataMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CStartVideoDataMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CStartVideoDataMsg) */ {
 public:
  CStartVideoDataMsg();
  virtual ~CStartVideoDataMsg();

  CStartVideoDataMsg(const CStartVideoDataMsg& from);

  inline CStartVideoDataMsg& operator=(const CStartVideoDataMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CStartVideoDataMsg(CStartVideoDataMsg&& from) noexcept
    : CStartVideoDataMsg() {
    *this = ::std::move(from);
  }

  inline CStartVideoDataMsg& operator=(CStartVideoDataMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CStartVideoDataMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CStartVideoDataMsg* internal_default_instance() {
    return reinterpret_cast<const CStartVideoDataMsg*>(
               &_CStartVideoDataMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(CStartVideoDataMsg* other);
  friend void swap(CStartVideoDataMsg& a, CStartVideoDataMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CStartVideoDataMsg* New() const final {
    return CreateMaybeMessage<CStartVideoDataMsg>(NULL);
  }

  CStartVideoDataMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CStartVideoDataMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CStartVideoDataMsg& from);
  void MergeFrom(const CStartVideoDataMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStartVideoDataMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes codec_data = 3;
  bool has_codec_data() const;
  void clear_codec_data();
  static const int kCodecDataFieldNumber = 3;
  const ::std::string& codec_data() const;
  void set_codec_data(const ::std::string& value);
  #if LANG_CXX11
  void set_codec_data(::std::string&& value);
  #endif
  void set_codec_data(const char* value);
  void set_codec_data(const void* value, size_t size);
  ::std::string* mutable_codec_data();
  ::std::string* release_codec_data();
  void set_allocated_codec_data(::std::string* codec_data);

  // required uint32 channel = 1;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 1;
  ::google::protobuf::uint32 channel() const;
  void set_channel(::google::protobuf::uint32 value);

  // optional .EStreamVideoCodec codec = 2 [default = k_EStreamVideoCodecNone];
  bool has_codec() const;
  void clear_codec();
  static const int kCodecFieldNumber = 2;
  ::EStreamVideoCodec codec() const;
  void set_codec(::EStreamVideoCodec value);

  // optional uint32 width = 4;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 4;
  ::google::protobuf::uint32 width() const;
  void set_width(::google::protobuf::uint32 value);

  // optional uint32 height = 5;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 5;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CStartVideoDataMsg)
 private:
  void set_has_channel();
  void clear_has_channel();
  void set_has_codec();
  void clear_has_codec();
  void set_has_codec_data();
  void clear_has_codec_data();
  void set_has_width();
  void clear_has_width();
  void set_has_height();
  void clear_has_height();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr codec_data_;
  ::google::protobuf::uint32 channel_;
  int codec_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CStopVideoDataMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CStopVideoDataMsg) */ {
 public:
  CStopVideoDataMsg();
  virtual ~CStopVideoDataMsg();

  CStopVideoDataMsg(const CStopVideoDataMsg& from);

  inline CStopVideoDataMsg& operator=(const CStopVideoDataMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CStopVideoDataMsg(CStopVideoDataMsg&& from) noexcept
    : CStopVideoDataMsg() {
    *this = ::std::move(from);
  }

  inline CStopVideoDataMsg& operator=(CStopVideoDataMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CStopVideoDataMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CStopVideoDataMsg* internal_default_instance() {
    return reinterpret_cast<const CStopVideoDataMsg*>(
               &_CStopVideoDataMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(CStopVideoDataMsg* other);
  friend void swap(CStopVideoDataMsg& a, CStopVideoDataMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CStopVideoDataMsg* New() const final {
    return CreateMaybeMessage<CStopVideoDataMsg>(NULL);
  }

  CStopVideoDataMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CStopVideoDataMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CStopVideoDataMsg& from);
  void MergeFrom(const CStopVideoDataMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStopVideoDataMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CStopVideoDataMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CInputLatencyTestMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CInputLatencyTestMsg) */ {
 public:
  CInputLatencyTestMsg();
  virtual ~CInputLatencyTestMsg();

  CInputLatencyTestMsg(const CInputLatencyTestMsg& from);

  inline CInputLatencyTestMsg& operator=(const CInputLatencyTestMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CInputLatencyTestMsg(CInputLatencyTestMsg&& from) noexcept
    : CInputLatencyTestMsg() {
    *this = ::std::move(from);
  }

  inline CInputLatencyTestMsg& operator=(CInputLatencyTestMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CInputLatencyTestMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CInputLatencyTestMsg* internal_default_instance() {
    return reinterpret_cast<const CInputLatencyTestMsg*>(
               &_CInputLatencyTestMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(CInputLatencyTestMsg* other);
  friend void swap(CInputLatencyTestMsg& a, CInputLatencyTestMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CInputLatencyTestMsg* New() const final {
    return CreateMaybeMessage<CInputLatencyTestMsg>(NULL);
  }

  CInputLatencyTestMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CInputLatencyTestMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CInputLatencyTestMsg& from);
  void MergeFrom(const CInputLatencyTestMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CInputLatencyTestMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 input_mark = 1;
  bool has_input_mark() const;
  void clear_input_mark();
  static const int kInputMarkFieldNumber = 1;
  ::google::protobuf::uint32 input_mark() const;
  void set_input_mark(::google::protobuf::uint32 value);

  // optional uint32 color = 2;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 2;
  ::google::protobuf::uint32 color() const;
  void set_color(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CInputLatencyTestMsg)
 private:
  void set_has_input_mark();
  void clear_has_input_mark();
  void set_has_color();
  void clear_has_color();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 input_mark_;
  ::google::protobuf::uint32 color_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CInputMouseMotionMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CInputMouseMotionMsg) */ {
 public:
  CInputMouseMotionMsg();
  virtual ~CInputMouseMotionMsg();

  CInputMouseMotionMsg(const CInputMouseMotionMsg& from);

  inline CInputMouseMotionMsg& operator=(const CInputMouseMotionMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CInputMouseMotionMsg(CInputMouseMotionMsg&& from) noexcept
    : CInputMouseMotionMsg() {
    *this = ::std::move(from);
  }

  inline CInputMouseMotionMsg& operator=(CInputMouseMotionMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CInputMouseMotionMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CInputMouseMotionMsg* internal_default_instance() {
    return reinterpret_cast<const CInputMouseMotionMsg*>(
               &_CInputMouseMotionMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(CInputMouseMotionMsg* other);
  friend void swap(CInputMouseMotionMsg& a, CInputMouseMotionMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CInputMouseMotionMsg* New() const final {
    return CreateMaybeMessage<CInputMouseMotionMsg>(NULL);
  }

  CInputMouseMotionMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CInputMouseMotionMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CInputMouseMotionMsg& from);
  void MergeFrom(const CInputMouseMotionMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CInputMouseMotionMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 input_mark = 1;
  bool has_input_mark() const;
  void clear_input_mark();
  static const int kInputMarkFieldNumber = 1;
  ::google::protobuf::uint32 input_mark() const;
  void set_input_mark(::google::protobuf::uint32 value);

  // optional float x_normalized = 2;
  bool has_x_normalized() const;
  void clear_x_normalized();
  static const int kXNormalizedFieldNumber = 2;
  float x_normalized() const;
  void set_x_normalized(float value);

  // optional float y_normalized = 3;
  bool has_y_normalized() const;
  void clear_y_normalized();
  static const int kYNormalizedFieldNumber = 3;
  float y_normalized() const;
  void set_y_normalized(float value);

  // optional int32 dx = 4;
  bool has_dx() const;
  void clear_dx();
  static const int kDxFieldNumber = 4;
  ::google::protobuf::int32 dx() const;
  void set_dx(::google::protobuf::int32 value);

  // optional int32 dy = 5;
  bool has_dy() const;
  void clear_dy();
  static const int kDyFieldNumber = 5;
  ::google::protobuf::int32 dy() const;
  void set_dy(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CInputMouseMotionMsg)
 private:
  void set_has_input_mark();
  void clear_has_input_mark();
  void set_has_x_normalized();
  void clear_has_x_normalized();
  void set_has_y_normalized();
  void clear_has_y_normalized();
  void set_has_dx();
  void clear_has_dx();
  void set_has_dy();
  void clear_has_dy();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 input_mark_;
  float x_normalized_;
  float y_normalized_;
  ::google::protobuf::int32 dx_;
  ::google::protobuf::int32 dy_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CInputMouseWheelMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CInputMouseWheelMsg) */ {
 public:
  CInputMouseWheelMsg();
  virtual ~CInputMouseWheelMsg();

  CInputMouseWheelMsg(const CInputMouseWheelMsg& from);

  inline CInputMouseWheelMsg& operator=(const CInputMouseWheelMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CInputMouseWheelMsg(CInputMouseWheelMsg&& from) noexcept
    : CInputMouseWheelMsg() {
    *this = ::std::move(from);
  }

  inline CInputMouseWheelMsg& operator=(CInputMouseWheelMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CInputMouseWheelMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CInputMouseWheelMsg* internal_default_instance() {
    return reinterpret_cast<const CInputMouseWheelMsg*>(
               &_CInputMouseWheelMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(CInputMouseWheelMsg* other);
  friend void swap(CInputMouseWheelMsg& a, CInputMouseWheelMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CInputMouseWheelMsg* New() const final {
    return CreateMaybeMessage<CInputMouseWheelMsg>(NULL);
  }

  CInputMouseWheelMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CInputMouseWheelMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CInputMouseWheelMsg& from);
  void MergeFrom(const CInputMouseWheelMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CInputMouseWheelMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 input_mark = 1;
  bool has_input_mark() const;
  void clear_input_mark();
  static const int kInputMarkFieldNumber = 1;
  ::google::protobuf::uint32 input_mark() const;
  void set_input_mark(::google::protobuf::uint32 value);

  // required .EStreamMouseWheelDirection direction = 2 [default = k_EStreamMouseWheelUp];
  bool has_direction() const;
  void clear_direction();
  static const int kDirectionFieldNumber = 2;
  ::EStreamMouseWheelDirection direction() const;
  void set_direction(::EStreamMouseWheelDirection value);

  // @@protoc_insertion_point(class_scope:CInputMouseWheelMsg)
 private:
  void set_has_input_mark();
  void clear_has_input_mark();
  void set_has_direction();
  void clear_has_direction();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 input_mark_;
  int direction_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CInputMouseDownMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CInputMouseDownMsg) */ {
 public:
  CInputMouseDownMsg();
  virtual ~CInputMouseDownMsg();

  CInputMouseDownMsg(const CInputMouseDownMsg& from);

  inline CInputMouseDownMsg& operator=(const CInputMouseDownMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CInputMouseDownMsg(CInputMouseDownMsg&& from) noexcept
    : CInputMouseDownMsg() {
    *this = ::std::move(from);
  }

  inline CInputMouseDownMsg& operator=(CInputMouseDownMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CInputMouseDownMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CInputMouseDownMsg* internal_default_instance() {
    return reinterpret_cast<const CInputMouseDownMsg*>(
               &_CInputMouseDownMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(CInputMouseDownMsg* other);
  friend void swap(CInputMouseDownMsg& a, CInputMouseDownMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CInputMouseDownMsg* New() const final {
    return CreateMaybeMessage<CInputMouseDownMsg>(NULL);
  }

  CInputMouseDownMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CInputMouseDownMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CInputMouseDownMsg& from);
  void MergeFrom(const CInputMouseDownMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CInputMouseDownMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 input_mark = 1;
  bool has_input_mark() const;
  void clear_input_mark();
  static const int kInputMarkFieldNumber = 1;
  ::google::protobuf::uint32 input_mark() const;
  void set_input_mark(::google::protobuf::uint32 value);

  // required .EStreamMouseButton button = 2 [default = k_EStreamMouseButtonLeft];
  bool has_button() const;
  void clear_button();
  static const int kButtonFieldNumber = 2;
  ::EStreamMouseButton button() const;
  void set_button(::EStreamMouseButton value);

  // @@protoc_insertion_point(class_scope:CInputMouseDownMsg)
 private:
  void set_has_input_mark();
  void clear_has_input_mark();
  void set_has_button();
  void clear_has_button();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 input_mark_;
  int button_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CInputMouseUpMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CInputMouseUpMsg) */ {
 public:
  CInputMouseUpMsg();
  virtual ~CInputMouseUpMsg();

  CInputMouseUpMsg(const CInputMouseUpMsg& from);

  inline CInputMouseUpMsg& operator=(const CInputMouseUpMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CInputMouseUpMsg(CInputMouseUpMsg&& from) noexcept
    : CInputMouseUpMsg() {
    *this = ::std::move(from);
  }

  inline CInputMouseUpMsg& operator=(CInputMouseUpMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CInputMouseUpMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CInputMouseUpMsg* internal_default_instance() {
    return reinterpret_cast<const CInputMouseUpMsg*>(
               &_CInputMouseUpMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(CInputMouseUpMsg* other);
  friend void swap(CInputMouseUpMsg& a, CInputMouseUpMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CInputMouseUpMsg* New() const final {
    return CreateMaybeMessage<CInputMouseUpMsg>(NULL);
  }

  CInputMouseUpMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CInputMouseUpMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CInputMouseUpMsg& from);
  void MergeFrom(const CInputMouseUpMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CInputMouseUpMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 input_mark = 1;
  bool has_input_mark() const;
  void clear_input_mark();
  static const int kInputMarkFieldNumber = 1;
  ::google::protobuf::uint32 input_mark() const;
  void set_input_mark(::google::protobuf::uint32 value);

  // required .EStreamMouseButton button = 2 [default = k_EStreamMouseButtonLeft];
  bool has_button() const;
  void clear_button();
  static const int kButtonFieldNumber = 2;
  ::EStreamMouseButton button() const;
  void set_button(::EStreamMouseButton value);

  // @@protoc_insertion_point(class_scope:CInputMouseUpMsg)
 private:
  void set_has_input_mark();
  void clear_has_input_mark();
  void set_has_button();
  void clear_has_button();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 input_mark_;
  int button_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CInputKeyDownMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CInputKeyDownMsg) */ {
 public:
  CInputKeyDownMsg();
  virtual ~CInputKeyDownMsg();

  CInputKeyDownMsg(const CInputKeyDownMsg& from);

  inline CInputKeyDownMsg& operator=(const CInputKeyDownMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CInputKeyDownMsg(CInputKeyDownMsg&& from) noexcept
    : CInputKeyDownMsg() {
    *this = ::std::move(from);
  }

  inline CInputKeyDownMsg& operator=(CInputKeyDownMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CInputKeyDownMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CInputKeyDownMsg* internal_default_instance() {
    return reinterpret_cast<const CInputKeyDownMsg*>(
               &_CInputKeyDownMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(CInputKeyDownMsg* other);
  friend void swap(CInputKeyDownMsg& a, CInputKeyDownMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CInputKeyDownMsg* New() const final {
    return CreateMaybeMessage<CInputKeyDownMsg>(NULL);
  }

  CInputKeyDownMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CInputKeyDownMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CInputKeyDownMsg& from);
  void MergeFrom(const CInputKeyDownMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CInputKeyDownMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 input_mark = 1;
  bool has_input_mark() const;
  void clear_input_mark();
  static const int kInputMarkFieldNumber = 1;
  ::google::protobuf::uint32 input_mark() const;
  void set_input_mark(::google::protobuf::uint32 value);

  // required uint32 scancode = 2;
  bool has_scancode() const;
  void clear_scancode();
  static const int kScancodeFieldNumber = 2;
  ::google::protobuf::uint32 scancode() const;
  void set_scancode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CInputKeyDownMsg)
 private:
  void set_has_input_mark();
  void clear_has_input_mark();
  void set_has_scancode();
  void clear_has_scancode();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 input_mark_;
  ::google::protobuf::uint32 scancode_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CInputKeyUpMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CInputKeyUpMsg) */ {
 public:
  CInputKeyUpMsg();
  virtual ~CInputKeyUpMsg();

  CInputKeyUpMsg(const CInputKeyUpMsg& from);

  inline CInputKeyUpMsg& operator=(const CInputKeyUpMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CInputKeyUpMsg(CInputKeyUpMsg&& from) noexcept
    : CInputKeyUpMsg() {
    *this = ::std::move(from);
  }

  inline CInputKeyUpMsg& operator=(CInputKeyUpMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CInputKeyUpMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CInputKeyUpMsg* internal_default_instance() {
    return reinterpret_cast<const CInputKeyUpMsg*>(
               &_CInputKeyUpMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(CInputKeyUpMsg* other);
  friend void swap(CInputKeyUpMsg& a, CInputKeyUpMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CInputKeyUpMsg* New() const final {
    return CreateMaybeMessage<CInputKeyUpMsg>(NULL);
  }

  CInputKeyUpMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CInputKeyUpMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CInputKeyUpMsg& from);
  void MergeFrom(const CInputKeyUpMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CInputKeyUpMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 input_mark = 1;
  bool has_input_mark() const;
  void clear_input_mark();
  static const int kInputMarkFieldNumber = 1;
  ::google::protobuf::uint32 input_mark() const;
  void set_input_mark(::google::protobuf::uint32 value);

  // required uint32 scancode = 2;
  bool has_scancode() const;
  void clear_scancode();
  static const int kScancodeFieldNumber = 2;
  ::google::protobuf::uint32 scancode() const;
  void set_scancode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CInputKeyUpMsg)
 private:
  void set_has_input_mark();
  void clear_has_input_mark();
  void set_has_scancode();
  void clear_has_scancode();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 input_mark_;
  ::google::protobuf::uint32 scancode_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CInputTextMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CInputTextMsg) */ {
 public:
  CInputTextMsg();
  virtual ~CInputTextMsg();

  CInputTextMsg(const CInputTextMsg& from);

  inline CInputTextMsg& operator=(const CInputTextMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CInputTextMsg(CInputTextMsg&& from) noexcept
    : CInputTextMsg() {
    *this = ::std::move(from);
  }

  inline CInputTextMsg& operator=(CInputTextMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CInputTextMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CInputTextMsg* internal_default_instance() {
    return reinterpret_cast<const CInputTextMsg*>(
               &_CInputTextMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(CInputTextMsg* other);
  friend void swap(CInputTextMsg& a, CInputTextMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CInputTextMsg* New() const final {
    return CreateMaybeMessage<CInputTextMsg>(NULL);
  }

  CInputTextMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CInputTextMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CInputTextMsg& from);
  void MergeFrom(const CInputTextMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CInputTextMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string text_utf8 = 2;
  bool has_text_utf8() const;
  void clear_text_utf8();
  static const int kTextUtf8FieldNumber = 2;
  const ::std::string& text_utf8() const;
  void set_text_utf8(const ::std::string& value);
  #if LANG_CXX11
  void set_text_utf8(::std::string&& value);
  #endif
  void set_text_utf8(const char* value);
  void set_text_utf8(const char* value, size_t size);
  ::std::string* mutable_text_utf8();
  ::std::string* release_text_utf8();
  void set_allocated_text_utf8(::std::string* text_utf8);

  // optional uint32 input_mark = 1;
  bool has_input_mark() const;
  void clear_input_mark();
  static const int kInputMarkFieldNumber = 1;
  ::google::protobuf::uint32 input_mark() const;
  void set_input_mark(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CInputTextMsg)
 private:
  void set_has_input_mark();
  void clear_has_input_mark();
  void set_has_text_utf8();
  void clear_has_text_utf8();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr text_utf8_;
  ::google::protobuf::uint32 input_mark_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CSetTitleMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CSetTitleMsg) */ {
 public:
  CSetTitleMsg();
  virtual ~CSetTitleMsg();

  CSetTitleMsg(const CSetTitleMsg& from);

  inline CSetTitleMsg& operator=(const CSetTitleMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CSetTitleMsg(CSetTitleMsg&& from) noexcept
    : CSetTitleMsg() {
    *this = ::std::move(from);
  }

  inline CSetTitleMsg& operator=(CSetTitleMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSetTitleMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CSetTitleMsg* internal_default_instance() {
    return reinterpret_cast<const CSetTitleMsg*>(
               &_CSetTitleMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(CSetTitleMsg* other);
  friend void swap(CSetTitleMsg& a, CSetTitleMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CSetTitleMsg* New() const final {
    return CreateMaybeMessage<CSetTitleMsg>(NULL);
  }

  CSetTitleMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CSetTitleMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CSetTitleMsg& from);
  void MergeFrom(const CSetTitleMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSetTitleMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string text = 1;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:CSetTitleMsg)
 private:
  void set_has_text();
  void clear_has_text();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CSetIconMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CSetIconMsg) */ {
 public:
  CSetIconMsg();
  virtual ~CSetIconMsg();

  CSetIconMsg(const CSetIconMsg& from);

  inline CSetIconMsg& operator=(const CSetIconMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CSetIconMsg(CSetIconMsg&& from) noexcept
    : CSetIconMsg() {
    *this = ::std::move(from);
  }

  inline CSetIconMsg& operator=(CSetIconMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSetIconMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CSetIconMsg* internal_default_instance() {
    return reinterpret_cast<const CSetIconMsg*>(
               &_CSetIconMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(CSetIconMsg* other);
  friend void swap(CSetIconMsg& a, CSetIconMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CSetIconMsg* New() const final {
    return CreateMaybeMessage<CSetIconMsg>(NULL);
  }

  CSetIconMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CSetIconMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CSetIconMsg& from);
  void MergeFrom(const CSetIconMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSetIconMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes image = 3;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 3;
  const ::std::string& image() const;
  void set_image(const ::std::string& value);
  #if LANG_CXX11
  void set_image(::std::string&& value);
  #endif
  void set_image(const char* value);
  void set_image(const void* value, size_t size);
  ::std::string* mutable_image();
  ::std::string* release_image();
  void set_allocated_image(::std::string* image);

  // optional int32 width = 1;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 1;
  ::google::protobuf::int32 width() const;
  void set_width(::google::protobuf::int32 value);

  // optional int32 height = 2;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  ::google::protobuf::int32 height() const;
  void set_height(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CSetIconMsg)
 private:
  void set_has_width();
  void clear_has_width();
  void set_has_height();
  void clear_has_height();
  void set_has_image();
  void clear_has_image();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr image_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CShowCursorMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CShowCursorMsg) */ {
 public:
  CShowCursorMsg();
  virtual ~CShowCursorMsg();

  CShowCursorMsg(const CShowCursorMsg& from);

  inline CShowCursorMsg& operator=(const CShowCursorMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CShowCursorMsg(CShowCursorMsg&& from) noexcept
    : CShowCursorMsg() {
    *this = ::std::move(from);
  }

  inline CShowCursorMsg& operator=(CShowCursorMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CShowCursorMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CShowCursorMsg* internal_default_instance() {
    return reinterpret_cast<const CShowCursorMsg*>(
               &_CShowCursorMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(CShowCursorMsg* other);
  friend void swap(CShowCursorMsg& a, CShowCursorMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CShowCursorMsg* New() const final {
    return CreateMaybeMessage<CShowCursorMsg>(NULL);
  }

  CShowCursorMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CShowCursorMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CShowCursorMsg& from);
  void MergeFrom(const CShowCursorMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CShowCursorMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x_normalized = 1;
  bool has_x_normalized() const;
  void clear_x_normalized();
  static const int kXNormalizedFieldNumber = 1;
  float x_normalized() const;
  void set_x_normalized(float value);

  // optional float y_normalized = 2;
  bool has_y_normalized() const;
  void clear_y_normalized();
  static const int kYNormalizedFieldNumber = 2;
  float y_normalized() const;
  void set_y_normalized(float value);

  // @@protoc_insertion_point(class_scope:CShowCursorMsg)
 private:
  void set_has_x_normalized();
  void clear_has_x_normalized();
  void set_has_y_normalized();
  void clear_has_y_normalized();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float x_normalized_;
  float y_normalized_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CHideCursorMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CHideCursorMsg) */ {
 public:
  CHideCursorMsg();
  virtual ~CHideCursorMsg();

  CHideCursorMsg(const CHideCursorMsg& from);

  inline CHideCursorMsg& operator=(const CHideCursorMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CHideCursorMsg(CHideCursorMsg&& from) noexcept
    : CHideCursorMsg() {
    *this = ::std::move(from);
  }

  inline CHideCursorMsg& operator=(CHideCursorMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CHideCursorMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CHideCursorMsg* internal_default_instance() {
    return reinterpret_cast<const CHideCursorMsg*>(
               &_CHideCursorMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(CHideCursorMsg* other);
  friend void swap(CHideCursorMsg& a, CHideCursorMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CHideCursorMsg* New() const final {
    return CreateMaybeMessage<CHideCursorMsg>(NULL);
  }

  CHideCursorMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CHideCursorMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CHideCursorMsg& from);
  void MergeFrom(const CHideCursorMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CHideCursorMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CHideCursorMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CSetCursorMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CSetCursorMsg) */ {
 public:
  CSetCursorMsg();
  virtual ~CSetCursorMsg();

  CSetCursorMsg(const CSetCursorMsg& from);

  inline CSetCursorMsg& operator=(const CSetCursorMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CSetCursorMsg(CSetCursorMsg&& from) noexcept
    : CSetCursorMsg() {
    *this = ::std::move(from);
  }

  inline CSetCursorMsg& operator=(CSetCursorMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSetCursorMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CSetCursorMsg* internal_default_instance() {
    return reinterpret_cast<const CSetCursorMsg*>(
               &_CSetCursorMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(CSetCursorMsg* other);
  friend void swap(CSetCursorMsg& a, CSetCursorMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CSetCursorMsg* New() const final {
    return CreateMaybeMessage<CSetCursorMsg>(NULL);
  }

  CSetCursorMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CSetCursorMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CSetCursorMsg& from);
  void MergeFrom(const CSetCursorMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSetCursorMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 cursor_id = 1;
  bool has_cursor_id() const;
  void clear_cursor_id();
  static const int kCursorIdFieldNumber = 1;
  ::google::protobuf::uint64 cursor_id() const;
  void set_cursor_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:CSetCursorMsg)
 private:
  void set_has_cursor_id();
  void clear_has_cursor_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 cursor_id_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CGetCursorImageMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CGetCursorImageMsg) */ {
 public:
  CGetCursorImageMsg();
  virtual ~CGetCursorImageMsg();

  CGetCursorImageMsg(const CGetCursorImageMsg& from);

  inline CGetCursorImageMsg& operator=(const CGetCursorImageMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CGetCursorImageMsg(CGetCursorImageMsg&& from) noexcept
    : CGetCursorImageMsg() {
    *this = ::std::move(from);
  }

  inline CGetCursorImageMsg& operator=(CGetCursorImageMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGetCursorImageMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CGetCursorImageMsg* internal_default_instance() {
    return reinterpret_cast<const CGetCursorImageMsg*>(
               &_CGetCursorImageMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(CGetCursorImageMsg* other);
  friend void swap(CGetCursorImageMsg& a, CGetCursorImageMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CGetCursorImageMsg* New() const final {
    return CreateMaybeMessage<CGetCursorImageMsg>(NULL);
  }

  CGetCursorImageMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CGetCursorImageMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CGetCursorImageMsg& from);
  void MergeFrom(const CGetCursorImageMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGetCursorImageMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 cursor_id = 1;
  bool has_cursor_id() const;
  void clear_cursor_id();
  static const int kCursorIdFieldNumber = 1;
  ::google::protobuf::uint64 cursor_id() const;
  void set_cursor_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:CGetCursorImageMsg)
 private:
  void set_has_cursor_id();
  void clear_has_cursor_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 cursor_id_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CSetCursorImageMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CSetCursorImageMsg) */ {
 public:
  CSetCursorImageMsg();
  virtual ~CSetCursorImageMsg();

  CSetCursorImageMsg(const CSetCursorImageMsg& from);

  inline CSetCursorImageMsg& operator=(const CSetCursorImageMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CSetCursorImageMsg(CSetCursorImageMsg&& from) noexcept
    : CSetCursorImageMsg() {
    *this = ::std::move(from);
  }

  inline CSetCursorImageMsg& operator=(CSetCursorImageMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSetCursorImageMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CSetCursorImageMsg* internal_default_instance() {
    return reinterpret_cast<const CSetCursorImageMsg*>(
               &_CSetCursorImageMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(CSetCursorImageMsg* other);
  friend void swap(CSetCursorImageMsg& a, CSetCursorImageMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CSetCursorImageMsg* New() const final {
    return CreateMaybeMessage<CSetCursorImageMsg>(NULL);
  }

  CSetCursorImageMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CSetCursorImageMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CSetCursorImageMsg& from);
  void MergeFrom(const CSetCursorImageMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSetCursorImageMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes image = 6;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 6;
  const ::std::string& image() const;
  void set_image(const ::std::string& value);
  #if LANG_CXX11
  void set_image(::std::string&& value);
  #endif
  void set_image(const char* value);
  void set_image(const void* value, size_t size);
  ::std::string* mutable_image();
  ::std::string* release_image();
  void set_allocated_image(::std::string* image);

  // required uint64 cursor_id = 1;
  bool has_cursor_id() const;
  void clear_cursor_id();
  static const int kCursorIdFieldNumber = 1;
  ::google::protobuf::uint64 cursor_id() const;
  void set_cursor_id(::google::protobuf::uint64 value);

  // optional int32 width = 2;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 2;
  ::google::protobuf::int32 width() const;
  void set_width(::google::protobuf::int32 value);

  // optional int32 height = 3;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  ::google::protobuf::int32 height() const;
  void set_height(::google::protobuf::int32 value);

  // optional int32 hot_x = 4;
  bool has_hot_x() const;
  void clear_hot_x();
  static const int kHotXFieldNumber = 4;
  ::google::protobuf::int32 hot_x() const;
  void set_hot_x(::google::protobuf::int32 value);

  // optional int32 hot_y = 5;
  bool has_hot_y() const;
  void clear_hot_y();
  static const int kHotYFieldNumber = 5;
  ::google::protobuf::int32 hot_y() const;
  void set_hot_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CSetCursorImageMsg)
 private:
  void set_has_cursor_id();
  void clear_has_cursor_id();
  void set_has_width();
  void clear_has_width();
  void set_has_height();
  void clear_has_height();
  void set_has_hot_x();
  void clear_has_hot_x();
  void set_has_hot_y();
  void clear_has_hot_y();
  void set_has_image();
  void clear_has_image();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr image_;
  ::google::protobuf::uint64 cursor_id_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 hot_x_;
  ::google::protobuf::int32 hot_y_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CVideoDecoderInfoMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CVideoDecoderInfoMsg) */ {
 public:
  CVideoDecoderInfoMsg();
  virtual ~CVideoDecoderInfoMsg();

  CVideoDecoderInfoMsg(const CVideoDecoderInfoMsg& from);

  inline CVideoDecoderInfoMsg& operator=(const CVideoDecoderInfoMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CVideoDecoderInfoMsg(CVideoDecoderInfoMsg&& from) noexcept
    : CVideoDecoderInfoMsg() {
    *this = ::std::move(from);
  }

  inline CVideoDecoderInfoMsg& operator=(CVideoDecoderInfoMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CVideoDecoderInfoMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CVideoDecoderInfoMsg* internal_default_instance() {
    return reinterpret_cast<const CVideoDecoderInfoMsg*>(
               &_CVideoDecoderInfoMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(CVideoDecoderInfoMsg* other);
  friend void swap(CVideoDecoderInfoMsg& a, CVideoDecoderInfoMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CVideoDecoderInfoMsg* New() const final {
    return CreateMaybeMessage<CVideoDecoderInfoMsg>(NULL);
  }

  CVideoDecoderInfoMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CVideoDecoderInfoMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CVideoDecoderInfoMsg& from);
  void MergeFrom(const CVideoDecoderInfoMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CVideoDecoderInfoMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string info = 1;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 1;
  const ::std::string& info() const;
  void set_info(const ::std::string& value);
  #if LANG_CXX11
  void set_info(::std::string&& value);
  #endif
  void set_info(const char* value);
  void set_info(const char* value, size_t size);
  ::std::string* mutable_info();
  ::std::string* release_info();
  void set_allocated_info(::std::string* info);

  // optional int32 threads = 2;
  bool has_threads() const;
  void clear_threads();
  static const int kThreadsFieldNumber = 2;
  ::google::protobuf::int32 threads() const;
  void set_threads(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CVideoDecoderInfoMsg)
 private:
  void set_has_info();
  void clear_has_info();
  void set_has_threads();
  void clear_has_threads();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr info_;
  ::google::protobuf::int32 threads_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CVideoEncoderInfoMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CVideoEncoderInfoMsg) */ {
 public:
  CVideoEncoderInfoMsg();
  virtual ~CVideoEncoderInfoMsg();

  CVideoEncoderInfoMsg(const CVideoEncoderInfoMsg& from);

  inline CVideoEncoderInfoMsg& operator=(const CVideoEncoderInfoMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CVideoEncoderInfoMsg(CVideoEncoderInfoMsg&& from) noexcept
    : CVideoEncoderInfoMsg() {
    *this = ::std::move(from);
  }

  inline CVideoEncoderInfoMsg& operator=(CVideoEncoderInfoMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CVideoEncoderInfoMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CVideoEncoderInfoMsg* internal_default_instance() {
    return reinterpret_cast<const CVideoEncoderInfoMsg*>(
               &_CVideoEncoderInfoMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  void Swap(CVideoEncoderInfoMsg* other);
  friend void swap(CVideoEncoderInfoMsg& a, CVideoEncoderInfoMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CVideoEncoderInfoMsg* New() const final {
    return CreateMaybeMessage<CVideoEncoderInfoMsg>(NULL);
  }

  CVideoEncoderInfoMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CVideoEncoderInfoMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CVideoEncoderInfoMsg& from);
  void MergeFrom(const CVideoEncoderInfoMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CVideoEncoderInfoMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string info = 1;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 1;
  const ::std::string& info() const;
  void set_info(const ::std::string& value);
  #if LANG_CXX11
  void set_info(::std::string&& value);
  #endif
  void set_info(const char* value);
  void set_info(const char* value, size_t size);
  ::std::string* mutable_info();
  ::std::string* release_info();
  void set_allocated_info(::std::string* info);

  // @@protoc_insertion_point(class_scope:CVideoEncoderInfoMsg)
 private:
  void set_has_info();
  void clear_has_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr info_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CQuitRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CQuitRequest) */ {
 public:
  CQuitRequest();
  virtual ~CQuitRequest();

  CQuitRequest(const CQuitRequest& from);

  inline CQuitRequest& operator=(const CQuitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CQuitRequest(CQuitRequest&& from) noexcept
    : CQuitRequest() {
    *this = ::std::move(from);
  }

  inline CQuitRequest& operator=(CQuitRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CQuitRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CQuitRequest* internal_default_instance() {
    return reinterpret_cast<const CQuitRequest*>(
               &_CQuitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  void Swap(CQuitRequest* other);
  friend void swap(CQuitRequest& a, CQuitRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CQuitRequest* New() const final {
    return CreateMaybeMessage<CQuitRequest>(NULL);
  }

  CQuitRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CQuitRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CQuitRequest& from);
  void MergeFrom(const CQuitRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CQuitRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CQuitRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CDeleteCursorMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CDeleteCursorMsg) */ {
 public:
  CDeleteCursorMsg();
  virtual ~CDeleteCursorMsg();

  CDeleteCursorMsg(const CDeleteCursorMsg& from);

  inline CDeleteCursorMsg& operator=(const CDeleteCursorMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CDeleteCursorMsg(CDeleteCursorMsg&& from) noexcept
    : CDeleteCursorMsg() {
    *this = ::std::move(from);
  }

  inline CDeleteCursorMsg& operator=(CDeleteCursorMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CDeleteCursorMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CDeleteCursorMsg* internal_default_instance() {
    return reinterpret_cast<const CDeleteCursorMsg*>(
               &_CDeleteCursorMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  void Swap(CDeleteCursorMsg* other);
  friend void swap(CDeleteCursorMsg& a, CDeleteCursorMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CDeleteCursorMsg* New() const final {
    return CreateMaybeMessage<CDeleteCursorMsg>(NULL);
  }

  CDeleteCursorMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CDeleteCursorMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CDeleteCursorMsg& from);
  void MergeFrom(const CDeleteCursorMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CDeleteCursorMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 cursor_id = 1;
  bool has_cursor_id() const;
  void clear_cursor_id();
  static const int kCursorIdFieldNumber = 1;
  ::google::protobuf::uint64 cursor_id() const;
  void set_cursor_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:CDeleteCursorMsg)
 private:
  void set_has_cursor_id();
  void clear_has_cursor_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 cursor_id_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CSetStreamingClientConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CSetStreamingClientConfig) */ {
 public:
  CSetStreamingClientConfig();
  virtual ~CSetStreamingClientConfig();

  CSetStreamingClientConfig(const CSetStreamingClientConfig& from);

  inline CSetStreamingClientConfig& operator=(const CSetStreamingClientConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CSetStreamingClientConfig(CSetStreamingClientConfig&& from) noexcept
    : CSetStreamingClientConfig() {
    *this = ::std::move(from);
  }

  inline CSetStreamingClientConfig& operator=(CSetStreamingClientConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSetStreamingClientConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CSetStreamingClientConfig* internal_default_instance() {
    return reinterpret_cast<const CSetStreamingClientConfig*>(
               &_CSetStreamingClientConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  void Swap(CSetStreamingClientConfig* other);
  friend void swap(CSetStreamingClientConfig& a, CSetStreamingClientConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CSetStreamingClientConfig* New() const final {
    return CreateMaybeMessage<CSetStreamingClientConfig>(NULL);
  }

  CSetStreamingClientConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CSetStreamingClientConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CSetStreamingClientConfig& from);
  void MergeFrom(const CSetStreamingClientConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSetStreamingClientConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .CStreamingClientConfig config = 1;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 1;
  private:
  const ::CStreamingClientConfig& _internal_config() const;
  public:
  const ::CStreamingClientConfig& config() const;
  ::CStreamingClientConfig* release_config();
  ::CStreamingClientConfig* mutable_config();
  void set_allocated_config(::CStreamingClientConfig* config);

  // @@protoc_insertion_point(class_scope:CSetStreamingClientConfig)
 private:
  void set_has_config();
  void clear_has_config();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::CStreamingClientConfig* config_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CSetQoSMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CSetQoSMsg) */ {
 public:
  CSetQoSMsg();
  virtual ~CSetQoSMsg();

  CSetQoSMsg(const CSetQoSMsg& from);

  inline CSetQoSMsg& operator=(const CSetQoSMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CSetQoSMsg(CSetQoSMsg&& from) noexcept
    : CSetQoSMsg() {
    *this = ::std::move(from);
  }

  inline CSetQoSMsg& operator=(CSetQoSMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSetQoSMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CSetQoSMsg* internal_default_instance() {
    return reinterpret_cast<const CSetQoSMsg*>(
               &_CSetQoSMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  void Swap(CSetQoSMsg* other);
  friend void swap(CSetQoSMsg& a, CSetQoSMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CSetQoSMsg* New() const final {
    return CreateMaybeMessage<CSetQoSMsg>(NULL);
  }

  CSetQoSMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CSetQoSMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CSetQoSMsg& from);
  void MergeFrom(const CSetQoSMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSetQoSMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool use_qos = 1;
  bool has_use_qos() const;
  void clear_use_qos();
  static const int kUseQosFieldNumber = 1;
  bool use_qos() const;
  void set_use_qos(bool value);

  // @@protoc_insertion_point(class_scope:CSetQoSMsg)
 private:
  void set_has_use_qos();
  void clear_has_use_qos();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool use_qos_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CSetTargetFramerateMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CSetTargetFramerateMsg) */ {
 public:
  CSetTargetFramerateMsg();
  virtual ~CSetTargetFramerateMsg();

  CSetTargetFramerateMsg(const CSetTargetFramerateMsg& from);

  inline CSetTargetFramerateMsg& operator=(const CSetTargetFramerateMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CSetTargetFramerateMsg(CSetTargetFramerateMsg&& from) noexcept
    : CSetTargetFramerateMsg() {
    *this = ::std::move(from);
  }

  inline CSetTargetFramerateMsg& operator=(CSetTargetFramerateMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSetTargetFramerateMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CSetTargetFramerateMsg* internal_default_instance() {
    return reinterpret_cast<const CSetTargetFramerateMsg*>(
               &_CSetTargetFramerateMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  void Swap(CSetTargetFramerateMsg* other);
  friend void swap(CSetTargetFramerateMsg& a, CSetTargetFramerateMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CSetTargetFramerateMsg* New() const final {
    return CreateMaybeMessage<CSetTargetFramerateMsg>(NULL);
  }

  CSetTargetFramerateMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CSetTargetFramerateMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CSetTargetFramerateMsg& from);
  void MergeFrom(const CSetTargetFramerateMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSetTargetFramerateMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 framerate = 1;
  bool has_framerate() const;
  void clear_framerate();
  static const int kFramerateFieldNumber = 1;
  ::google::protobuf::uint32 framerate() const;
  void set_framerate(::google::protobuf::uint32 value);

  // optional uint32 reasons = 2;
  bool has_reasons() const;
  void clear_reasons();
  static const int kReasonsFieldNumber = 2;
  ::google::protobuf::uint32 reasons() const;
  void set_reasons(::google::protobuf::uint32 value);

  // optional uint32 framerate_numerator = 3;
  bool has_framerate_numerator() const;
  void clear_framerate_numerator();
  static const int kFramerateNumeratorFieldNumber = 3;
  ::google::protobuf::uint32 framerate_numerator() const;
  void set_framerate_numerator(::google::protobuf::uint32 value);

  // optional uint32 framerate_denominator = 4;
  bool has_framerate_denominator() const;
  void clear_framerate_denominator();
  static const int kFramerateDenominatorFieldNumber = 4;
  ::google::protobuf::uint32 framerate_denominator() const;
  void set_framerate_denominator(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CSetTargetFramerateMsg)
 private:
  void set_has_framerate();
  void clear_has_framerate();
  void set_has_reasons();
  void clear_has_reasons();
  void set_has_framerate_numerator();
  void clear_has_framerate_numerator();
  void set_has_framerate_denominator();
  void clear_has_framerate_denominator();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 framerate_;
  ::google::protobuf::uint32 reasons_;
  ::google::protobuf::uint32 framerate_numerator_;
  ::google::protobuf::uint32 framerate_denominator_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CSetTargetBitrateMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CSetTargetBitrateMsg) */ {
 public:
  CSetTargetBitrateMsg();
  virtual ~CSetTargetBitrateMsg();

  CSetTargetBitrateMsg(const CSetTargetBitrateMsg& from);

  inline CSetTargetBitrateMsg& operator=(const CSetTargetBitrateMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CSetTargetBitrateMsg(CSetTargetBitrateMsg&& from) noexcept
    : CSetTargetBitrateMsg() {
    *this = ::std::move(from);
  }

  inline CSetTargetBitrateMsg& operator=(CSetTargetBitrateMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSetTargetBitrateMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CSetTargetBitrateMsg* internal_default_instance() {
    return reinterpret_cast<const CSetTargetBitrateMsg*>(
               &_CSetTargetBitrateMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  void Swap(CSetTargetBitrateMsg* other);
  friend void swap(CSetTargetBitrateMsg& a, CSetTargetBitrateMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CSetTargetBitrateMsg* New() const final {
    return CreateMaybeMessage<CSetTargetBitrateMsg>(NULL);
  }

  CSetTargetBitrateMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CSetTargetBitrateMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CSetTargetBitrateMsg& from);
  void MergeFrom(const CSetTargetBitrateMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSetTargetBitrateMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 bitrate = 1;
  bool has_bitrate() const;
  void clear_bitrate();
  static const int kBitrateFieldNumber = 1;
  ::google::protobuf::int32 bitrate() const;
  void set_bitrate(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CSetTargetBitrateMsg)
 private:
  void set_has_bitrate();
  void clear_has_bitrate();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 bitrate_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class COverlayEnabledMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:COverlayEnabledMsg) */ {
 public:
  COverlayEnabledMsg();
  virtual ~COverlayEnabledMsg();

  COverlayEnabledMsg(const COverlayEnabledMsg& from);

  inline COverlayEnabledMsg& operator=(const COverlayEnabledMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  COverlayEnabledMsg(COverlayEnabledMsg&& from) noexcept
    : COverlayEnabledMsg() {
    *this = ::std::move(from);
  }

  inline COverlayEnabledMsg& operator=(COverlayEnabledMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const COverlayEnabledMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const COverlayEnabledMsg* internal_default_instance() {
    return reinterpret_cast<const COverlayEnabledMsg*>(
               &_COverlayEnabledMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  void Swap(COverlayEnabledMsg* other);
  friend void swap(COverlayEnabledMsg& a, COverlayEnabledMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline COverlayEnabledMsg* New() const final {
    return CreateMaybeMessage<COverlayEnabledMsg>(NULL);
  }

  COverlayEnabledMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<COverlayEnabledMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const COverlayEnabledMsg& from);
  void MergeFrom(const COverlayEnabledMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(COverlayEnabledMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool enabled = 1;
  bool has_enabled() const;
  void clear_enabled();
  static const int kEnabledFieldNumber = 1;
  bool enabled() const;
  void set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:COverlayEnabledMsg)
 private:
  void set_has_enabled();
  void clear_has_enabled();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool enabled_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CSetGammaRampMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CSetGammaRampMsg) */ {
 public:
  CSetGammaRampMsg();
  virtual ~CSetGammaRampMsg();

  CSetGammaRampMsg(const CSetGammaRampMsg& from);

  inline CSetGammaRampMsg& operator=(const CSetGammaRampMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CSetGammaRampMsg(CSetGammaRampMsg&& from) noexcept
    : CSetGammaRampMsg() {
    *this = ::std::move(from);
  }

  inline CSetGammaRampMsg& operator=(CSetGammaRampMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSetGammaRampMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CSetGammaRampMsg* internal_default_instance() {
    return reinterpret_cast<const CSetGammaRampMsg*>(
               &_CSetGammaRampMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  void Swap(CSetGammaRampMsg* other);
  friend void swap(CSetGammaRampMsg& a, CSetGammaRampMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CSetGammaRampMsg* New() const final {
    return CreateMaybeMessage<CSetGammaRampMsg>(NULL);
  }

  CSetGammaRampMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CSetGammaRampMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CSetGammaRampMsg& from);
  void MergeFrom(const CSetGammaRampMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSetGammaRampMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes gamma_ramp = 1;
  bool has_gamma_ramp() const;
  void clear_gamma_ramp();
  static const int kGammaRampFieldNumber = 1;
  const ::std::string& gamma_ramp() const;
  void set_gamma_ramp(const ::std::string& value);
  #if LANG_CXX11
  void set_gamma_ramp(::std::string&& value);
  #endif
  void set_gamma_ramp(const char* value);
  void set_gamma_ramp(const void* value, size_t size);
  ::std::string* mutable_gamma_ramp();
  ::std::string* release_gamma_ramp();
  void set_allocated_gamma_ramp(::std::string* gamma_ramp);

  // @@protoc_insertion_point(class_scope:CSetGammaRampMsg)
 private:
  void set_has_gamma_ramp();
  void clear_has_gamma_ramp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr gamma_ramp_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CSetActivityMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CSetActivityMsg) */ {
 public:
  CSetActivityMsg();
  virtual ~CSetActivityMsg();

  CSetActivityMsg(const CSetActivityMsg& from);

  inline CSetActivityMsg& operator=(const CSetActivityMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CSetActivityMsg(CSetActivityMsg&& from) noexcept
    : CSetActivityMsg() {
    *this = ::std::move(from);
  }

  inline CSetActivityMsg& operator=(CSetActivityMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSetActivityMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CSetActivityMsg* internal_default_instance() {
    return reinterpret_cast<const CSetActivityMsg*>(
               &_CSetActivityMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  void Swap(CSetActivityMsg* other);
  friend void swap(CSetActivityMsg& a, CSetActivityMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CSetActivityMsg* New() const final {
    return CreateMaybeMessage<CSetActivityMsg>(NULL);
  }

  CSetActivityMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CSetActivityMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CSetActivityMsg& from);
  void MergeFrom(const CSetActivityMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSetActivityMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .EStreamActivity activity = 1 [default = k_EStreamActivityIdle];
  bool has_activity() const;
  void clear_activity();
  static const int kActivityFieldNumber = 1;
  ::EStreamActivity activity() const;
  void set_activity(::EStreamActivity value);

  // @@protoc_insertion_point(class_scope:CSetActivityMsg)
 private:
  void set_has_activity();
  void clear_has_activity();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int activity_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CSystemSuspendMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CSystemSuspendMsg) */ {
 public:
  CSystemSuspendMsg();
  virtual ~CSystemSuspendMsg();

  CSystemSuspendMsg(const CSystemSuspendMsg& from);

  inline CSystemSuspendMsg& operator=(const CSystemSuspendMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CSystemSuspendMsg(CSystemSuspendMsg&& from) noexcept
    : CSystemSuspendMsg() {
    *this = ::std::move(from);
  }

  inline CSystemSuspendMsg& operator=(CSystemSuspendMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSystemSuspendMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CSystemSuspendMsg* internal_default_instance() {
    return reinterpret_cast<const CSystemSuspendMsg*>(
               &_CSystemSuspendMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  void Swap(CSystemSuspendMsg* other);
  friend void swap(CSystemSuspendMsg& a, CSystemSuspendMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CSystemSuspendMsg* New() const final {
    return CreateMaybeMessage<CSystemSuspendMsg>(NULL);
  }

  CSystemSuspendMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CSystemSuspendMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CSystemSuspendMsg& from);
  void MergeFrom(const CSystemSuspendMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSystemSuspendMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CSystemSuspendMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CVirtualHereRequestMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CVirtualHereRequestMsg) */ {
 public:
  CVirtualHereRequestMsg();
  virtual ~CVirtualHereRequestMsg();

  CVirtualHereRequestMsg(const CVirtualHereRequestMsg& from);

  inline CVirtualHereRequestMsg& operator=(const CVirtualHereRequestMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CVirtualHereRequestMsg(CVirtualHereRequestMsg&& from) noexcept
    : CVirtualHereRequestMsg() {
    *this = ::std::move(from);
  }

  inline CVirtualHereRequestMsg& operator=(CVirtualHereRequestMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CVirtualHereRequestMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CVirtualHereRequestMsg* internal_default_instance() {
    return reinterpret_cast<const CVirtualHereRequestMsg*>(
               &_CVirtualHereRequestMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  void Swap(CVirtualHereRequestMsg* other);
  friend void swap(CVirtualHereRequestMsg& a, CVirtualHereRequestMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CVirtualHereRequestMsg* New() const final {
    return CreateMaybeMessage<CVirtualHereRequestMsg>(NULL);
  }

  CVirtualHereRequestMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CVirtualHereRequestMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CVirtualHereRequestMsg& from);
  void MergeFrom(const CVirtualHereRequestMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CVirtualHereRequestMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string hostname = 1;
  bool has_hostname() const;
  void clear_hostname();
  static const int kHostnameFieldNumber = 1;
  const ::std::string& hostname() const;
  void set_hostname(const ::std::string& value);
  #if LANG_CXX11
  void set_hostname(::std::string&& value);
  #endif
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  ::std::string* mutable_hostname();
  ::std::string* release_hostname();
  void set_allocated_hostname(::std::string* hostname);

  // @@protoc_insertion_point(class_scope:CVirtualHereRequestMsg)
 private:
  void set_has_hostname();
  void clear_has_hostname();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr hostname_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CVirtualHereReadyMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CVirtualHereReadyMsg) */ {
 public:
  CVirtualHereReadyMsg();
  virtual ~CVirtualHereReadyMsg();

  CVirtualHereReadyMsg(const CVirtualHereReadyMsg& from);

  inline CVirtualHereReadyMsg& operator=(const CVirtualHereReadyMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CVirtualHereReadyMsg(CVirtualHereReadyMsg&& from) noexcept
    : CVirtualHereReadyMsg() {
    *this = ::std::move(from);
  }

  inline CVirtualHereReadyMsg& operator=(CVirtualHereReadyMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CVirtualHereReadyMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CVirtualHereReadyMsg* internal_default_instance() {
    return reinterpret_cast<const CVirtualHereReadyMsg*>(
               &_CVirtualHereReadyMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  void Swap(CVirtualHereReadyMsg* other);
  friend void swap(CVirtualHereReadyMsg& a, CVirtualHereReadyMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CVirtualHereReadyMsg* New() const final {
    return CreateMaybeMessage<CVirtualHereReadyMsg>(NULL);
  }

  CVirtualHereReadyMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CVirtualHereReadyMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CVirtualHereReadyMsg& from);
  void MergeFrom(const CVirtualHereReadyMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CVirtualHereReadyMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 licensed_device_count = 1;
  bool has_licensed_device_count() const;
  void clear_licensed_device_count();
  static const int kLicensedDeviceCountFieldNumber = 1;
  ::google::protobuf::uint32 licensed_device_count() const;
  void set_licensed_device_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CVirtualHereReadyMsg)
 private:
  void set_has_licensed_device_count();
  void clear_has_licensed_device_count();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 licensed_device_count_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CVirtualHereShareDeviceMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CVirtualHereShareDeviceMsg) */ {
 public:
  CVirtualHereShareDeviceMsg();
  virtual ~CVirtualHereShareDeviceMsg();

  CVirtualHereShareDeviceMsg(const CVirtualHereShareDeviceMsg& from);

  inline CVirtualHereShareDeviceMsg& operator=(const CVirtualHereShareDeviceMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CVirtualHereShareDeviceMsg(CVirtualHereShareDeviceMsg&& from) noexcept
    : CVirtualHereShareDeviceMsg() {
    *this = ::std::move(from);
  }

  inline CVirtualHereShareDeviceMsg& operator=(CVirtualHereShareDeviceMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CVirtualHereShareDeviceMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CVirtualHereShareDeviceMsg* internal_default_instance() {
    return reinterpret_cast<const CVirtualHereShareDeviceMsg*>(
               &_CVirtualHereShareDeviceMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  void Swap(CVirtualHereShareDeviceMsg* other);
  friend void swap(CVirtualHereShareDeviceMsg& a, CVirtualHereShareDeviceMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CVirtualHereShareDeviceMsg* New() const final {
    return CreateMaybeMessage<CVirtualHereShareDeviceMsg>(NULL);
  }

  CVirtualHereShareDeviceMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CVirtualHereShareDeviceMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CVirtualHereShareDeviceMsg& from);
  void MergeFrom(const CVirtualHereShareDeviceMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CVirtualHereShareDeviceMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string device_address = 1;
  bool has_device_address() const;
  void clear_device_address();
  static const int kDeviceAddressFieldNumber = 1;
  const ::std::string& device_address() const;
  void set_device_address(const ::std::string& value);
  #if LANG_CXX11
  void set_device_address(::std::string&& value);
  #endif
  void set_device_address(const char* value);
  void set_device_address(const char* value, size_t size);
  ::std::string* mutable_device_address();
  ::std::string* release_device_address();
  void set_allocated_device_address(::std::string* device_address);

  // @@protoc_insertion_point(class_scope:CVirtualHereShareDeviceMsg)
 private:
  void set_has_device_address();
  void clear_has_device_address();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr device_address_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CSetSpectatorModeMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CSetSpectatorModeMsg) */ {
 public:
  CSetSpectatorModeMsg();
  virtual ~CSetSpectatorModeMsg();

  CSetSpectatorModeMsg(const CSetSpectatorModeMsg& from);

  inline CSetSpectatorModeMsg& operator=(const CSetSpectatorModeMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CSetSpectatorModeMsg(CSetSpectatorModeMsg&& from) noexcept
    : CSetSpectatorModeMsg() {
    *this = ::std::move(from);
  }

  inline CSetSpectatorModeMsg& operator=(CSetSpectatorModeMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSetSpectatorModeMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CSetSpectatorModeMsg* internal_default_instance() {
    return reinterpret_cast<const CSetSpectatorModeMsg*>(
               &_CSetSpectatorModeMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  void Swap(CSetSpectatorModeMsg* other);
  friend void swap(CSetSpectatorModeMsg& a, CSetSpectatorModeMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CSetSpectatorModeMsg* New() const final {
    return CreateMaybeMessage<CSetSpectatorModeMsg>(NULL);
  }

  CSetSpectatorModeMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CSetSpectatorModeMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CSetSpectatorModeMsg& from);
  void MergeFrom(const CSetSpectatorModeMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSetSpectatorModeMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enabled = 1;
  bool has_enabled() const;
  void clear_enabled();
  static const int kEnabledFieldNumber = 1;
  bool enabled() const;
  void set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:CSetSpectatorModeMsg)
 private:
  void set_has_enabled();
  void clear_has_enabled();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool enabled_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CRemoteHIDMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CRemoteHIDMsg) */ {
 public:
  CRemoteHIDMsg();
  virtual ~CRemoteHIDMsg();

  CRemoteHIDMsg(const CRemoteHIDMsg& from);

  inline CRemoteHIDMsg& operator=(const CRemoteHIDMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CRemoteHIDMsg(CRemoteHIDMsg&& from) noexcept
    : CRemoteHIDMsg() {
    *this = ::std::move(from);
  }

  inline CRemoteHIDMsg& operator=(CRemoteHIDMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CRemoteHIDMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CRemoteHIDMsg* internal_default_instance() {
    return reinterpret_cast<const CRemoteHIDMsg*>(
               &_CRemoteHIDMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  void Swap(CRemoteHIDMsg* other);
  friend void swap(CRemoteHIDMsg& a, CRemoteHIDMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CRemoteHIDMsg* New() const final {
    return CreateMaybeMessage<CRemoteHIDMsg>(NULL);
  }

  CRemoteHIDMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CRemoteHIDMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CRemoteHIDMsg& from);
  void MergeFrom(const CRemoteHIDMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CRemoteHIDMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes data = 1;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:CRemoteHIDMsg)
 private:
  void set_has_data();
  void clear_has_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CTouchConfigActiveMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CTouchConfigActiveMsg) */ {
 public:
  CTouchConfigActiveMsg();
  virtual ~CTouchConfigActiveMsg();

  CTouchConfigActiveMsg(const CTouchConfigActiveMsg& from);

  inline CTouchConfigActiveMsg& operator=(const CTouchConfigActiveMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CTouchConfigActiveMsg(CTouchConfigActiveMsg&& from) noexcept
    : CTouchConfigActiveMsg() {
    *this = ::std::move(from);
  }

  inline CTouchConfigActiveMsg& operator=(CTouchConfigActiveMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CTouchConfigActiveMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CTouchConfigActiveMsg* internal_default_instance() {
    return reinterpret_cast<const CTouchConfigActiveMsg*>(
               &_CTouchConfigActiveMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  void Swap(CTouchConfigActiveMsg* other);
  friend void swap(CTouchConfigActiveMsg& a, CTouchConfigActiveMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CTouchConfigActiveMsg* New() const final {
    return CreateMaybeMessage<CTouchConfigActiveMsg>(NULL);
  }

  CTouchConfigActiveMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CTouchConfigActiveMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CTouchConfigActiveMsg& from);
  void MergeFrom(const CTouchConfigActiveMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CTouchConfigActiveMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 appid = 1;
  bool has_appid() const;
  void clear_appid();
  static const int kAppidFieldNumber = 1;
  ::google::protobuf::uint32 appid() const;
  void set_appid(::google::protobuf::uint32 value);

  // optional uint32 revision = 2;
  bool has_revision() const;
  void clear_revision();
  static const int kRevisionFieldNumber = 2;
  ::google::protobuf::uint32 revision() const;
  void set_revision(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CTouchConfigActiveMsg)
 private:
  void set_has_appid();
  void clear_has_appid();
  void set_has_revision();
  void clear_has_revision();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 appid_;
  ::google::protobuf::uint32 revision_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CGetTouchConfigDataMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CGetTouchConfigDataMsg) */ {
 public:
  CGetTouchConfigDataMsg();
  virtual ~CGetTouchConfigDataMsg();

  CGetTouchConfigDataMsg(const CGetTouchConfigDataMsg& from);

  inline CGetTouchConfigDataMsg& operator=(const CGetTouchConfigDataMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CGetTouchConfigDataMsg(CGetTouchConfigDataMsg&& from) noexcept
    : CGetTouchConfigDataMsg() {
    *this = ::std::move(from);
  }

  inline CGetTouchConfigDataMsg& operator=(CGetTouchConfigDataMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGetTouchConfigDataMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CGetTouchConfigDataMsg* internal_default_instance() {
    return reinterpret_cast<const CGetTouchConfigDataMsg*>(
               &_CGetTouchConfigDataMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  void Swap(CGetTouchConfigDataMsg* other);
  friend void swap(CGetTouchConfigDataMsg& a, CGetTouchConfigDataMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CGetTouchConfigDataMsg* New() const final {
    return CreateMaybeMessage<CGetTouchConfigDataMsg>(NULL);
  }

  CGetTouchConfigDataMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CGetTouchConfigDataMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CGetTouchConfigDataMsg& from);
  void MergeFrom(const CGetTouchConfigDataMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGetTouchConfigDataMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 appid = 1;
  bool has_appid() const;
  void clear_appid();
  static const int kAppidFieldNumber = 1;
  ::google::protobuf::uint32 appid() const;
  void set_appid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CGetTouchConfigDataMsg)
 private:
  void set_has_appid();
  void clear_has_appid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 appid_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CSetTouchConfigDataMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CSetTouchConfigDataMsg) */ {
 public:
  CSetTouchConfigDataMsg();
  virtual ~CSetTouchConfigDataMsg();

  CSetTouchConfigDataMsg(const CSetTouchConfigDataMsg& from);

  inline CSetTouchConfigDataMsg& operator=(const CSetTouchConfigDataMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CSetTouchConfigDataMsg(CSetTouchConfigDataMsg&& from) noexcept
    : CSetTouchConfigDataMsg() {
    *this = ::std::move(from);
  }

  inline CSetTouchConfigDataMsg& operator=(CSetTouchConfigDataMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSetTouchConfigDataMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CSetTouchConfigDataMsg* internal_default_instance() {
    return reinterpret_cast<const CSetTouchConfigDataMsg*>(
               &_CSetTouchConfigDataMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  void Swap(CSetTouchConfigDataMsg* other);
  friend void swap(CSetTouchConfigDataMsg& a, CSetTouchConfigDataMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CSetTouchConfigDataMsg* New() const final {
    return CreateMaybeMessage<CSetTouchConfigDataMsg>(NULL);
  }

  CSetTouchConfigDataMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CSetTouchConfigDataMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CSetTouchConfigDataMsg& from);
  void MergeFrom(const CSetTouchConfigDataMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSetTouchConfigDataMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes data = 3;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // optional bytes layout = 4;
  bool has_layout() const;
  void clear_layout();
  static const int kLayoutFieldNumber = 4;
  const ::std::string& layout() const;
  void set_layout(const ::std::string& value);
  #if LANG_CXX11
  void set_layout(::std::string&& value);
  #endif
  void set_layout(const char* value);
  void set_layout(const void* value, size_t size);
  ::std::string* mutable_layout();
  ::std::string* release_layout();
  void set_allocated_layout(::std::string* layout);

  // optional uint32 appid = 1;
  bool has_appid() const;
  void clear_appid();
  static const int kAppidFieldNumber = 1;
  ::google::protobuf::uint32 appid() const;
  void set_appid(::google::protobuf::uint32 value);

  // optional uint32 revision = 2;
  bool has_revision() const;
  void clear_revision();
  static const int kRevisionFieldNumber = 2;
  ::google::protobuf::uint32 revision() const;
  void set_revision(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CSetTouchConfigDataMsg)
 private:
  void set_has_appid();
  void clear_has_appid();
  void set_has_revision();
  void clear_has_revision();
  void set_has_data();
  void clear_has_data();
  void set_has_layout();
  void clear_has_layout();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::internal::ArenaStringPtr layout_;
  ::google::protobuf::uint32 appid_;
  ::google::protobuf::uint32 revision_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CSaveTouchConfigLayoutMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CSaveTouchConfigLayoutMsg) */ {
 public:
  CSaveTouchConfigLayoutMsg();
  virtual ~CSaveTouchConfigLayoutMsg();

  CSaveTouchConfigLayoutMsg(const CSaveTouchConfigLayoutMsg& from);

  inline CSaveTouchConfigLayoutMsg& operator=(const CSaveTouchConfigLayoutMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CSaveTouchConfigLayoutMsg(CSaveTouchConfigLayoutMsg&& from) noexcept
    : CSaveTouchConfigLayoutMsg() {
    *this = ::std::move(from);
  }

  inline CSaveTouchConfigLayoutMsg& operator=(CSaveTouchConfigLayoutMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSaveTouchConfigLayoutMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CSaveTouchConfigLayoutMsg* internal_default_instance() {
    return reinterpret_cast<const CSaveTouchConfigLayoutMsg*>(
               &_CSaveTouchConfigLayoutMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  void Swap(CSaveTouchConfigLayoutMsg* other);
  friend void swap(CSaveTouchConfigLayoutMsg& a, CSaveTouchConfigLayoutMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CSaveTouchConfigLayoutMsg* New() const final {
    return CreateMaybeMessage<CSaveTouchConfigLayoutMsg>(NULL);
  }

  CSaveTouchConfigLayoutMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CSaveTouchConfigLayoutMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CSaveTouchConfigLayoutMsg& from);
  void MergeFrom(const CSaveTouchConfigLayoutMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSaveTouchConfigLayoutMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes layout = 4;
  bool has_layout() const;
  void clear_layout();
  static const int kLayoutFieldNumber = 4;
  const ::std::string& layout() const;
  void set_layout(const ::std::string& value);
  #if LANG_CXX11
  void set_layout(::std::string&& value);
  #endif
  void set_layout(const char* value);
  void set_layout(const void* value, size_t size);
  ::std::string* mutable_layout();
  ::std::string* release_layout();
  void set_allocated_layout(::std::string* layout);

  // optional uint32 appid = 1;
  bool has_appid() const;
  void clear_appid();
  static const int kAppidFieldNumber = 1;
  ::google::protobuf::uint32 appid() const;
  void set_appid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CSaveTouchConfigLayoutMsg)
 private:
  void set_has_appid();
  void clear_has_appid();
  void set_has_layout();
  void clear_has_layout();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr layout_;
  ::google::protobuf::uint32 appid_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CTouchActionSetActiveMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CTouchActionSetActiveMsg) */ {
 public:
  CTouchActionSetActiveMsg();
  virtual ~CTouchActionSetActiveMsg();

  CTouchActionSetActiveMsg(const CTouchActionSetActiveMsg& from);

  inline CTouchActionSetActiveMsg& operator=(const CTouchActionSetActiveMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CTouchActionSetActiveMsg(CTouchActionSetActiveMsg&& from) noexcept
    : CTouchActionSetActiveMsg() {
    *this = ::std::move(from);
  }

  inline CTouchActionSetActiveMsg& operator=(CTouchActionSetActiveMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CTouchActionSetActiveMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CTouchActionSetActiveMsg* internal_default_instance() {
    return reinterpret_cast<const CTouchActionSetActiveMsg*>(
               &_CTouchActionSetActiveMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  void Swap(CTouchActionSetActiveMsg* other);
  friend void swap(CTouchActionSetActiveMsg& a, CTouchActionSetActiveMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CTouchActionSetActiveMsg* New() const final {
    return CreateMaybeMessage<CTouchActionSetActiveMsg>(NULL);
  }

  CTouchActionSetActiveMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CTouchActionSetActiveMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CTouchActionSetActiveMsg& from);
  void MergeFrom(const CTouchActionSetActiveMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CTouchActionSetActiveMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 appid = 1;
  bool has_appid() const;
  void clear_appid();
  static const int kAppidFieldNumber = 1;
  ::google::protobuf::uint32 appid() const;
  void set_appid(::google::protobuf::uint32 value);

  // optional int32 actionset_id = 2;
  bool has_actionset_id() const;
  void clear_actionset_id();
  static const int kActionsetIdFieldNumber = 2;
  ::google::protobuf::int32 actionset_id() const;
  void set_actionset_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CTouchActionSetActiveMsg)
 private:
  void set_has_appid();
  void clear_has_appid();
  void set_has_actionset_id();
  void clear_has_actionset_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 appid_;
  ::google::protobuf::int32 actionset_id_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CGetTouchIconDataMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CGetTouchIconDataMsg) */ {
 public:
  CGetTouchIconDataMsg();
  virtual ~CGetTouchIconDataMsg();

  CGetTouchIconDataMsg(const CGetTouchIconDataMsg& from);

  inline CGetTouchIconDataMsg& operator=(const CGetTouchIconDataMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CGetTouchIconDataMsg(CGetTouchIconDataMsg&& from) noexcept
    : CGetTouchIconDataMsg() {
    *this = ::std::move(from);
  }

  inline CGetTouchIconDataMsg& operator=(CGetTouchIconDataMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CGetTouchIconDataMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CGetTouchIconDataMsg* internal_default_instance() {
    return reinterpret_cast<const CGetTouchIconDataMsg*>(
               &_CGetTouchIconDataMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  void Swap(CGetTouchIconDataMsg* other);
  friend void swap(CGetTouchIconDataMsg& a, CGetTouchIconDataMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CGetTouchIconDataMsg* New() const final {
    return CreateMaybeMessage<CGetTouchIconDataMsg>(NULL);
  }

  CGetTouchIconDataMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CGetTouchIconDataMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CGetTouchIconDataMsg& from);
  void MergeFrom(const CGetTouchIconDataMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGetTouchIconDataMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string icon = 2;
  bool has_icon() const;
  void clear_icon();
  static const int kIconFieldNumber = 2;
  const ::std::string& icon() const;
  void set_icon(const ::std::string& value);
  #if LANG_CXX11
  void set_icon(::std::string&& value);
  #endif
  void set_icon(const char* value);
  void set_icon(const char* value, size_t size);
  ::std::string* mutable_icon();
  ::std::string* release_icon();
  void set_allocated_icon(::std::string* icon);

  // optional uint32 appid = 1;
  bool has_appid() const;
  void clear_appid();
  static const int kAppidFieldNumber = 1;
  ::google::protobuf::uint32 appid() const;
  void set_appid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CGetTouchIconDataMsg)
 private:
  void set_has_appid();
  void clear_has_appid();
  void set_has_icon();
  void clear_has_icon();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr icon_;
  ::google::protobuf::uint32 appid_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CSetTouchIconDataMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CSetTouchIconDataMsg) */ {
 public:
  CSetTouchIconDataMsg();
  virtual ~CSetTouchIconDataMsg();

  CSetTouchIconDataMsg(const CSetTouchIconDataMsg& from);

  inline CSetTouchIconDataMsg& operator=(const CSetTouchIconDataMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CSetTouchIconDataMsg(CSetTouchIconDataMsg&& from) noexcept
    : CSetTouchIconDataMsg() {
    *this = ::std::move(from);
  }

  inline CSetTouchIconDataMsg& operator=(CSetTouchIconDataMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSetTouchIconDataMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CSetTouchIconDataMsg* internal_default_instance() {
    return reinterpret_cast<const CSetTouchIconDataMsg*>(
               &_CSetTouchIconDataMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  void Swap(CSetTouchIconDataMsg* other);
  friend void swap(CSetTouchIconDataMsg& a, CSetTouchIconDataMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CSetTouchIconDataMsg* New() const final {
    return CreateMaybeMessage<CSetTouchIconDataMsg>(NULL);
  }

  CSetTouchIconDataMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CSetTouchIconDataMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CSetTouchIconDataMsg& from);
  void MergeFrom(const CSetTouchIconDataMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSetTouchIconDataMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string icon = 2;
  bool has_icon() const;
  void clear_icon();
  static const int kIconFieldNumber = 2;
  const ::std::string& icon() const;
  void set_icon(const ::std::string& value);
  #if LANG_CXX11
  void set_icon(::std::string&& value);
  #endif
  void set_icon(const char* value);
  void set_icon(const char* value, size_t size);
  ::std::string* mutable_icon();
  ::std::string* release_icon();
  void set_allocated_icon(::std::string* icon);

  // optional bytes data = 3;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // optional uint32 appid = 1;
  bool has_appid() const;
  void clear_appid();
  static const int kAppidFieldNumber = 1;
  ::google::protobuf::uint32 appid() const;
  void set_appid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CSetTouchIconDataMsg)
 private:
  void set_has_appid();
  void clear_has_appid();
  void set_has_icon();
  void clear_has_icon();
  void set_has_data();
  void clear_has_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr icon_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::uint32 appid_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CStreamDataLostMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CStreamDataLostMsg) */ {
 public:
  CStreamDataLostMsg();
  virtual ~CStreamDataLostMsg();

  CStreamDataLostMsg(const CStreamDataLostMsg& from);

  inline CStreamDataLostMsg& operator=(const CStreamDataLostMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CStreamDataLostMsg(CStreamDataLostMsg&& from) noexcept
    : CStreamDataLostMsg() {
    *this = ::std::move(from);
  }

  inline CStreamDataLostMsg& operator=(CStreamDataLostMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CStreamDataLostMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CStreamDataLostMsg* internal_default_instance() {
    return reinterpret_cast<const CStreamDataLostMsg*>(
               &_CStreamDataLostMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  void Swap(CStreamDataLostMsg* other);
  friend void swap(CStreamDataLostMsg& a, CStreamDataLostMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CStreamDataLostMsg* New() const final {
    return CreateMaybeMessage<CStreamDataLostMsg>(NULL);
  }

  CStreamDataLostMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CStreamDataLostMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CStreamDataLostMsg& from);
  void MergeFrom(const CStreamDataLostMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStreamDataLostMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 packets = 1;
  int packets_size() const;
  void clear_packets();
  static const int kPacketsFieldNumber = 1;
  ::google::protobuf::uint32 packets(int index) const;
  void set_packets(int index, ::google::protobuf::uint32 value);
  void add_packets(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      packets() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_packets();

  // @@protoc_insertion_point(class_scope:CStreamDataLostMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > packets_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CAudioFormat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CAudioFormat) */ {
 public:
  CAudioFormat();
  virtual ~CAudioFormat();

  CAudioFormat(const CAudioFormat& from);

  inline CAudioFormat& operator=(const CAudioFormat& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CAudioFormat(CAudioFormat&& from) noexcept
    : CAudioFormat() {
    *this = ::std::move(from);
  }

  inline CAudioFormat& operator=(CAudioFormat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CAudioFormat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CAudioFormat* internal_default_instance() {
    return reinterpret_cast<const CAudioFormat*>(
               &_CAudioFormat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  void Swap(CAudioFormat* other);
  friend void swap(CAudioFormat& a, CAudioFormat& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CAudioFormat* New() const final {
    return CreateMaybeMessage<CAudioFormat>(NULL);
  }

  CAudioFormat* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CAudioFormat>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CAudioFormat& from);
  void MergeFrom(const CAudioFormat& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAudioFormat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .EAudioFormat format = 1 [default = k_EAudioFormatNone];
  bool has_format() const;
  void clear_format();
  static const int kFormatFieldNumber = 1;
  ::EAudioFormat format() const;
  void set_format(::EAudioFormat value);

  // optional uint32 frequency = 2;
  bool has_frequency() const;
  void clear_frequency();
  static const int kFrequencyFieldNumber = 2;
  ::google::protobuf::uint32 frequency() const;
  void set_frequency(::google::protobuf::uint32 value);

  // optional uint32 channels = 3;
  bool has_channels() const;
  void clear_channels();
  static const int kChannelsFieldNumber = 3;
  ::google::protobuf::uint32 channels() const;
  void set_channels(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CAudioFormat)
 private:
  void set_has_format();
  void clear_has_format();
  void set_has_frequency();
  void clear_has_frequency();
  void set_has_channels();
  void clear_has_channels();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int format_;
  ::google::protobuf::uint32 frequency_;
  ::google::protobuf::uint32 channels_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CVideoFormat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CVideoFormat) */ {
 public:
  CVideoFormat();
  virtual ~CVideoFormat();

  CVideoFormat(const CVideoFormat& from);

  inline CVideoFormat& operator=(const CVideoFormat& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CVideoFormat(CVideoFormat&& from) noexcept
    : CVideoFormat() {
    *this = ::std::move(from);
  }

  inline CVideoFormat& operator=(CVideoFormat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CVideoFormat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CVideoFormat* internal_default_instance() {
    return reinterpret_cast<const CVideoFormat*>(
               &_CVideoFormat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  void Swap(CVideoFormat* other);
  friend void swap(CVideoFormat& a, CVideoFormat& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CVideoFormat* New() const final {
    return CreateMaybeMessage<CVideoFormat>(NULL);
  }

  CVideoFormat* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CVideoFormat>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CVideoFormat& from);
  void MergeFrom(const CVideoFormat& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CVideoFormat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .EVideoFormat format = 1 [default = k_EVideoFormatNone];
  bool has_format() const;
  void clear_format();
  static const int kFormatFieldNumber = 1;
  ::EVideoFormat format() const;
  void set_format(::EVideoFormat value);

  // optional uint32 width = 2;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 2;
  ::google::protobuf::uint32 width() const;
  void set_width(::google::protobuf::uint32 value);

  // optional uint32 height = 3;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CVideoFormat)
 private:
  void set_has_format();
  void clear_has_format();
  void set_has_width();
  void clear_has_width();
  void set_has_height();
  void clear_has_height();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int format_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CFrameEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CFrameEvent) */ {
 public:
  CFrameEvent();
  virtual ~CFrameEvent();

  CFrameEvent(const CFrameEvent& from);

  inline CFrameEvent& operator=(const CFrameEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CFrameEvent(CFrameEvent&& from) noexcept
    : CFrameEvent() {
    *this = ::std::move(from);
  }

  inline CFrameEvent& operator=(CFrameEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CFrameEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CFrameEvent* internal_default_instance() {
    return reinterpret_cast<const CFrameEvent*>(
               &_CFrameEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  void Swap(CFrameEvent* other);
  friend void swap(CFrameEvent& a, CFrameEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CFrameEvent* New() const final {
    return CreateMaybeMessage<CFrameEvent>(NULL);
  }

  CFrameEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CFrameEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CFrameEvent& from);
  void MergeFrom(const CFrameEvent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CFrameEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .EStreamFrameEvent event_id = 1 [default = k_EStreamInputEventStart];
  bool has_event_id() const;
  void clear_event_id();
  static const int kEventIdFieldNumber = 1;
  ::EStreamFrameEvent event_id() const;
  void set_event_id(::EStreamFrameEvent value);

  // required uint32 timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::uint32 timestamp() const;
  void set_timestamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CFrameEvent)
 private:
  void set_has_event_id();
  void clear_has_event_id();
  void set_has_timestamp();
  void clear_has_timestamp();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int event_id_;
  ::google::protobuf::uint32 timestamp_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CFrameStats : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CFrameStats) */ {
 public:
  CFrameStats();
  virtual ~CFrameStats();

  CFrameStats(const CFrameStats& from);

  inline CFrameStats& operator=(const CFrameStats& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CFrameStats(CFrameStats&& from) noexcept
    : CFrameStats() {
    *this = ::std::move(from);
  }

  inline CFrameStats& operator=(CFrameStats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CFrameStats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CFrameStats* internal_default_instance() {
    return reinterpret_cast<const CFrameStats*>(
               &_CFrameStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  void Swap(CFrameStats* other);
  friend void swap(CFrameStats& a, CFrameStats& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CFrameStats* New() const final {
    return CreateMaybeMessage<CFrameStats>(NULL);
  }

  CFrameStats* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CFrameStats>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CFrameStats& from);
  void MergeFrom(const CFrameStats& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CFrameStats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CFrameEvent events = 3;
  int events_size() const;
  void clear_events();
  static const int kEventsFieldNumber = 3;
  ::CFrameEvent* mutable_events(int index);
  ::google::protobuf::RepeatedPtrField< ::CFrameEvent >*
      mutable_events();
  const ::CFrameEvent& events(int index) const;
  ::CFrameEvent* add_events();
  const ::google::protobuf::RepeatedPtrField< ::CFrameEvent >&
      events() const;

  // required uint32 frame_id = 1;
  bool has_frame_id() const;
  void clear_frame_id();
  static const int kFrameIdFieldNumber = 1;
  ::google::protobuf::uint32 frame_id() const;
  void set_frame_id(::google::protobuf::uint32 value);

  // optional uint32 input_mark = 2;
  bool has_input_mark() const;
  void clear_input_mark();
  static const int kInputMarkFieldNumber = 2;
  ::google::protobuf::uint32 input_mark() const;
  void set_input_mark(::google::protobuf::uint32 value);

  // required .EStreamFrameResult result = 4 [default = k_EStreamFrameResultPending];
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 4;
  ::EStreamFrameResult result() const;
  void set_result(::EStreamFrameResult value);

  // optional float frame_start_delta = 5;
  bool has_frame_start_delta() const;
  void clear_frame_start_delta();
  static const int kFrameStartDeltaFieldNumber = 5;
  float frame_start_delta() const;
  void set_frame_start_delta(float value);

  // optional float frame_display_delta = 6;
  bool has_frame_display_delta() const;
  void clear_frame_display_delta();
  static const int kFrameDisplayDeltaFieldNumber = 6;
  float frame_display_delta() const;
  void set_frame_display_delta(float value);

  // optional float ping_time = 7;
  bool has_ping_time() const;
  void clear_ping_time();
  static const int kPingTimeFieldNumber = 7;
  float ping_time() const;
  void set_ping_time(float value);

  // optional float server_bitrate = 8;
  bool has_server_bitrate() const;
  void clear_server_bitrate();
  static const int kServerBitrateFieldNumber = 8;
  float server_bitrate() const;
  void set_server_bitrate(float value);

  // optional float client_bitrate = 9;
  bool has_client_bitrate() const;
  void clear_client_bitrate();
  static const int kClientBitrateFieldNumber = 9;
  float client_bitrate() const;
  void set_client_bitrate(float value);

  // optional float link_bandwidth = 10;
  bool has_link_bandwidth() const;
  void clear_link_bandwidth();
  static const int kLinkBandwidthFieldNumber = 10;
  float link_bandwidth() const;
  void set_link_bandwidth(float value);

  // optional float packet_loss = 11;
  bool has_packet_loss() const;
  void clear_packet_loss();
  static const int kPacketLossFieldNumber = 11;
  float packet_loss() const;
  void set_packet_loss(float value);

  // optional uint32 frame_size = 12;
  bool has_frame_size() const;
  void clear_frame_size();
  static const int kFrameSizeFieldNumber = 12;
  ::google::protobuf::uint32 frame_size() const;
  void set_frame_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CFrameStats)
 private:
  void set_has_frame_id();
  void clear_has_frame_id();
  void set_has_input_mark();
  void clear_has_input_mark();
  void set_has_result();
  void clear_has_result();
  void set_has_frame_start_delta();
  void clear_has_frame_start_delta();
  void set_has_frame_display_delta();
  void clear_has_frame_display_delta();
  void set_has_ping_time();
  void clear_has_ping_time();
  void set_has_server_bitrate();
  void clear_has_server_bitrate();
  void set_has_client_bitrate();
  void clear_has_client_bitrate();
  void set_has_link_bandwidth();
  void clear_has_link_bandwidth();
  void set_has_packet_loss();
  void clear_has_packet_loss();
  void set_has_frame_size();
  void clear_has_frame_size();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::CFrameEvent > events_;
  ::google::protobuf::uint32 frame_id_;
  ::google::protobuf::uint32 input_mark_;
  int result_;
  float frame_start_delta_;
  float frame_display_delta_;
  float ping_time_;
  float server_bitrate_;
  float client_bitrate_;
  float link_bandwidth_;
  float packet_loss_;
  ::google::protobuf::uint32 frame_size_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CFrameStatAccumulatedValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CFrameStatAccumulatedValue) */ {
 public:
  CFrameStatAccumulatedValue();
  virtual ~CFrameStatAccumulatedValue();

  CFrameStatAccumulatedValue(const CFrameStatAccumulatedValue& from);

  inline CFrameStatAccumulatedValue& operator=(const CFrameStatAccumulatedValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CFrameStatAccumulatedValue(CFrameStatAccumulatedValue&& from) noexcept
    : CFrameStatAccumulatedValue() {
    *this = ::std::move(from);
  }

  inline CFrameStatAccumulatedValue& operator=(CFrameStatAccumulatedValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CFrameStatAccumulatedValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CFrameStatAccumulatedValue* internal_default_instance() {
    return reinterpret_cast<const CFrameStatAccumulatedValue*>(
               &_CFrameStatAccumulatedValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  void Swap(CFrameStatAccumulatedValue* other);
  friend void swap(CFrameStatAccumulatedValue& a, CFrameStatAccumulatedValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CFrameStatAccumulatedValue* New() const final {
    return CreateMaybeMessage<CFrameStatAccumulatedValue>(NULL);
  }

  CFrameStatAccumulatedValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CFrameStatAccumulatedValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CFrameStatAccumulatedValue& from);
  void MergeFrom(const CFrameStatAccumulatedValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CFrameStatAccumulatedValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .EFrameAccumulatedStat stat_type = 1 [default = k_EFrameStatFPS];
  bool has_stat_type() const;
  void clear_stat_type();
  static const int kStatTypeFieldNumber = 1;
  ::EFrameAccumulatedStat stat_type() const;
  void set_stat_type(::EFrameAccumulatedStat value);

  // required int32 count = 2;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 2;
  ::google::protobuf::int32 count() const;
  void set_count(::google::protobuf::int32 value);

  // required float average = 3;
  bool has_average() const;
  void clear_average();
  static const int kAverageFieldNumber = 3;
  float average() const;
  void set_average(float value);

  // optional float stddev = 4;
  bool has_stddev() const;
  void clear_stddev();
  static const int kStddevFieldNumber = 4;
  float stddev() const;
  void set_stddev(float value);

  // @@protoc_insertion_point(class_scope:CFrameStatAccumulatedValue)
 private:
  void set_has_stat_type();
  void clear_has_stat_type();
  void set_has_count();
  void clear_has_count();
  void set_has_average();
  void clear_has_average();
  void set_has_stddev();
  void clear_has_stddev();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int stat_type_;
  ::google::protobuf::int32 count_;
  float average_;
  float stddev_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CFrameStatsListMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CFrameStatsListMsg) */ {
 public:
  CFrameStatsListMsg();
  virtual ~CFrameStatsListMsg();

  CFrameStatsListMsg(const CFrameStatsListMsg& from);

  inline CFrameStatsListMsg& operator=(const CFrameStatsListMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CFrameStatsListMsg(CFrameStatsListMsg&& from) noexcept
    : CFrameStatsListMsg() {
    *this = ::std::move(from);
  }

  inline CFrameStatsListMsg& operator=(CFrameStatsListMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CFrameStatsListMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CFrameStatsListMsg* internal_default_instance() {
    return reinterpret_cast<const CFrameStatsListMsg*>(
               &_CFrameStatsListMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  void Swap(CFrameStatsListMsg* other);
  friend void swap(CFrameStatsListMsg& a, CFrameStatsListMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CFrameStatsListMsg* New() const final {
    return CreateMaybeMessage<CFrameStatsListMsg>(NULL);
  }

  CFrameStatsListMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CFrameStatsListMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CFrameStatsListMsg& from);
  void MergeFrom(const CFrameStatsListMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CFrameStatsListMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CFrameStats stats = 2;
  int stats_size() const;
  void clear_stats();
  static const int kStatsFieldNumber = 2;
  ::CFrameStats* mutable_stats(int index);
  ::google::protobuf::RepeatedPtrField< ::CFrameStats >*
      mutable_stats();
  const ::CFrameStats& stats(int index) const;
  ::CFrameStats* add_stats();
  const ::google::protobuf::RepeatedPtrField< ::CFrameStats >&
      stats() const;

  // repeated .CFrameStatAccumulatedValue accumulated_stats = 3;
  int accumulated_stats_size() const;
  void clear_accumulated_stats();
  static const int kAccumulatedStatsFieldNumber = 3;
  ::CFrameStatAccumulatedValue* mutable_accumulated_stats(int index);
  ::google::protobuf::RepeatedPtrField< ::CFrameStatAccumulatedValue >*
      mutable_accumulated_stats();
  const ::CFrameStatAccumulatedValue& accumulated_stats(int index) const;
  ::CFrameStatAccumulatedValue* add_accumulated_stats();
  const ::google::protobuf::RepeatedPtrField< ::CFrameStatAccumulatedValue >&
      accumulated_stats() const;

  // required .EStreamingDataType data_type = 1 [default = k_EStreamingAudioData];
  bool has_data_type() const;
  void clear_data_type();
  static const int kDataTypeFieldNumber = 1;
  ::EStreamingDataType data_type() const;
  void set_data_type(::EStreamingDataType value);

  // required int32 latest_frame_id = 4;
  bool has_latest_frame_id() const;
  void clear_latest_frame_id();
  static const int kLatestFrameIdFieldNumber = 4;
  ::google::protobuf::int32 latest_frame_id() const;
  void set_latest_frame_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CFrameStatsListMsg)
 private:
  void set_has_data_type();
  void clear_has_data_type();
  void set_has_latest_frame_id();
  void clear_has_latest_frame_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::CFrameStats > stats_;
  ::google::protobuf::RepeatedPtrField< ::CFrameStatAccumulatedValue > accumulated_stats_;
  int data_type_;
  ::google::protobuf::int32 latest_frame_id_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CStreamingSessionStats : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CStreamingSessionStats) */ {
 public:
  CStreamingSessionStats();
  virtual ~CStreamingSessionStats();

  CStreamingSessionStats(const CStreamingSessionStats& from);

  inline CStreamingSessionStats& operator=(const CStreamingSessionStats& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CStreamingSessionStats(CStreamingSessionStats&& from) noexcept
    : CStreamingSessionStats() {
    *this = ::std::move(from);
  }

  inline CStreamingSessionStats& operator=(CStreamingSessionStats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CStreamingSessionStats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CStreamingSessionStats* internal_default_instance() {
    return reinterpret_cast<const CStreamingSessionStats*>(
               &_CStreamingSessionStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  void Swap(CStreamingSessionStats* other);
  friend void swap(CStreamingSessionStats& a, CStreamingSessionStats& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CStreamingSessionStats* New() const final {
    return CreateMaybeMessage<CStreamingSessionStats>(NULL);
  }

  CStreamingSessionStats* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CStreamingSessionStats>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CStreamingSessionStats& from);
  void MergeFrom(const CStreamingSessionStats& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStreamingSessionStats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float frame_loss_percentage = 1;
  bool has_frame_loss_percentage() const;
  void clear_frame_loss_percentage();
  static const int kFrameLossPercentageFieldNumber = 1;
  float frame_loss_percentage() const;
  void set_frame_loss_percentage(float value);

  // optional float average_network_time_ms = 2;
  bool has_average_network_time_ms() const;
  void clear_average_network_time_ms();
  static const int kAverageNetworkTimeMsFieldNumber = 2;
  float average_network_time_ms() const;
  void set_average_network_time_ms(float value);

  // optional float stddev_network_time_ms = 3;
  bool has_stddev_network_time_ms() const;
  void clear_stddev_network_time_ms();
  static const int kStddevNetworkTimeMsFieldNumber = 3;
  float stddev_network_time_ms() const;
  void set_stddev_network_time_ms(float value);

  // @@protoc_insertion_point(class_scope:CStreamingSessionStats)
 private:
  void set_has_frame_loss_percentage();
  void clear_has_frame_loss_percentage();
  void set_has_average_network_time_ms();
  void clear_has_average_network_time_ms();
  void set_has_stddev_network_time_ms();
  void clear_has_stddev_network_time_ms();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float frame_loss_percentage_;
  float average_network_time_ms_;
  float stddev_network_time_ms_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CDebugDumpMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CDebugDumpMsg) */ {
 public:
  CDebugDumpMsg();
  virtual ~CDebugDumpMsg();

  CDebugDumpMsg(const CDebugDumpMsg& from);

  inline CDebugDumpMsg& operator=(const CDebugDumpMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CDebugDumpMsg(CDebugDumpMsg&& from) noexcept
    : CDebugDumpMsg() {
    *this = ::std::move(from);
  }

  inline CDebugDumpMsg& operator=(CDebugDumpMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CDebugDumpMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CDebugDumpMsg* internal_default_instance() {
    return reinterpret_cast<const CDebugDumpMsg*>(
               &_CDebugDumpMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  void Swap(CDebugDumpMsg* other);
  friend void swap(CDebugDumpMsg& a, CDebugDumpMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CDebugDumpMsg* New() const final {
    return CreateMaybeMessage<CDebugDumpMsg>(NULL);
  }

  CDebugDumpMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CDebugDumpMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CDebugDumpMsg& from);
  void MergeFrom(const CDebugDumpMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CDebugDumpMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes screenshot = 1;
  bool has_screenshot() const;
  void clear_screenshot();
  static const int kScreenshotFieldNumber = 1;
  const ::std::string& screenshot() const;
  void set_screenshot(const ::std::string& value);
  #if LANG_CXX11
  void set_screenshot(::std::string&& value);
  #endif
  void set_screenshot(const char* value);
  void set_screenshot(const void* value, size_t size);
  ::std::string* mutable_screenshot();
  ::std::string* release_screenshot();
  void set_allocated_screenshot(::std::string* screenshot);

  // @@protoc_insertion_point(class_scope:CDebugDumpMsg)
 private:
  void set_has_screenshot();
  void clear_has_screenshot();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr screenshot_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CLogMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CLogMsg) */ {
 public:
  CLogMsg();
  virtual ~CLogMsg();

  CLogMsg(const CLogMsg& from);

  inline CLogMsg& operator=(const CLogMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CLogMsg(CLogMsg&& from) noexcept
    : CLogMsg() {
    *this = ::std::move(from);
  }

  inline CLogMsg& operator=(CLogMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CLogMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CLogMsg* internal_default_instance() {
    return reinterpret_cast<const CLogMsg*>(
               &_CLogMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  void Swap(CLogMsg* other);
  friend void swap(CLogMsg& a, CLogMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CLogMsg* New() const final {
    return CreateMaybeMessage<CLogMsg>(NULL);
  }

  CLogMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CLogMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CLogMsg& from);
  void MergeFrom(const CLogMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CLogMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string message = 2;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional int32 type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CLogMsg)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_message();
  void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::int32 type_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CLogUploadMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CLogUploadMsg) */ {
 public:
  CLogUploadMsg();
  virtual ~CLogUploadMsg();

  CLogUploadMsg(const CLogUploadMsg& from);

  inline CLogUploadMsg& operator=(const CLogUploadMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CLogUploadMsg(CLogUploadMsg&& from) noexcept
    : CLogUploadMsg() {
    *this = ::std::move(from);
  }

  inline CLogUploadMsg& operator=(CLogUploadMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CLogUploadMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CLogUploadMsg* internal_default_instance() {
    return reinterpret_cast<const CLogUploadMsg*>(
               &_CLogUploadMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  void Swap(CLogUploadMsg* other);
  friend void swap(CLogUploadMsg& a, CLogUploadMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CLogUploadMsg* New() const final {
    return CreateMaybeMessage<CLogUploadMsg>(NULL);
  }

  CLogUploadMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CLogUploadMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CLogUploadMsg& from);
  void MergeFrom(const CLogUploadMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CLogUploadMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes data = 3;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // optional .ELogFileType type = 1 [default = k_ELogFileSystemBoot];
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::ELogFileType type() const;
  void set_type(::ELogFileType value);

  // @@protoc_insertion_point(class_scope:CLogUploadMsg)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_data();
  void clear_has_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  int type_;
  friend struct ::protobuf_stream_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CDiscoveryPingRequest

// optional uint32 sequence = 1;
inline bool CDiscoveryPingRequest::has_sequence() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CDiscoveryPingRequest::set_has_sequence() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CDiscoveryPingRequest::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CDiscoveryPingRequest::clear_sequence() {
  sequence_ = 0u;
  clear_has_sequence();
}
inline ::google::protobuf::uint32 CDiscoveryPingRequest::sequence() const {
  // @@protoc_insertion_point(field_get:CDiscoveryPingRequest.sequence)
  return sequence_;
}
inline void CDiscoveryPingRequest::set_sequence(::google::protobuf::uint32 value) {
  set_has_sequence();
  sequence_ = value;
  // @@protoc_insertion_point(field_set:CDiscoveryPingRequest.sequence)
}

// optional uint32 packet_size_requested = 2;
inline bool CDiscoveryPingRequest::has_packet_size_requested() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CDiscoveryPingRequest::set_has_packet_size_requested() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CDiscoveryPingRequest::clear_has_packet_size_requested() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CDiscoveryPingRequest::clear_packet_size_requested() {
  packet_size_requested_ = 0u;
  clear_has_packet_size_requested();
}
inline ::google::protobuf::uint32 CDiscoveryPingRequest::packet_size_requested() const {
  // @@protoc_insertion_point(field_get:CDiscoveryPingRequest.packet_size_requested)
  return packet_size_requested_;
}
inline void CDiscoveryPingRequest::set_packet_size_requested(::google::protobuf::uint32 value) {
  set_has_packet_size_requested();
  packet_size_requested_ = value;
  // @@protoc_insertion_point(field_set:CDiscoveryPingRequest.packet_size_requested)
}

// -------------------------------------------------------------------

// CDiscoveryPingResponse

// optional uint32 sequence = 1;
inline bool CDiscoveryPingResponse::has_sequence() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CDiscoveryPingResponse::set_has_sequence() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CDiscoveryPingResponse::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CDiscoveryPingResponse::clear_sequence() {
  sequence_ = 0u;
  clear_has_sequence();
}
inline ::google::protobuf::uint32 CDiscoveryPingResponse::sequence() const {
  // @@protoc_insertion_point(field_get:CDiscoveryPingResponse.sequence)
  return sequence_;
}
inline void CDiscoveryPingResponse::set_sequence(::google::protobuf::uint32 value) {
  set_has_sequence();
  sequence_ = value;
  // @@protoc_insertion_point(field_set:CDiscoveryPingResponse.sequence)
}

// optional uint32 packet_size_received = 2;
inline bool CDiscoveryPingResponse::has_packet_size_received() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CDiscoveryPingResponse::set_has_packet_size_received() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CDiscoveryPingResponse::clear_has_packet_size_received() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CDiscoveryPingResponse::clear_packet_size_received() {
  packet_size_received_ = 0u;
  clear_has_packet_size_received();
}
inline ::google::protobuf::uint32 CDiscoveryPingResponse::packet_size_received() const {
  // @@protoc_insertion_point(field_get:CDiscoveryPingResponse.packet_size_received)
  return packet_size_received_;
}
inline void CDiscoveryPingResponse::set_packet_size_received(::google::protobuf::uint32 value) {
  set_has_packet_size_received();
  packet_size_received_ = value;
  // @@protoc_insertion_point(field_set:CDiscoveryPingResponse.packet_size_received)
}

// -------------------------------------------------------------------

// CStreamingClientHandshakeInfo

// optional int32 network_test = 2;
inline bool CStreamingClientHandshakeInfo::has_network_test() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CStreamingClientHandshakeInfo::set_has_network_test() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CStreamingClientHandshakeInfo::clear_has_network_test() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CStreamingClientHandshakeInfo::clear_network_test() {
  network_test_ = 0;
  clear_has_network_test();
}
inline ::google::protobuf::int32 CStreamingClientHandshakeInfo::network_test() const {
  // @@protoc_insertion_point(field_get:CStreamingClientHandshakeInfo.network_test)
  return network_test_;
}
inline void CStreamingClientHandshakeInfo::set_network_test(::google::protobuf::int32 value) {
  set_has_network_test();
  network_test_ = value;
  // @@protoc_insertion_point(field_set:CStreamingClientHandshakeInfo.network_test)
}

// -------------------------------------------------------------------

// CClientHandshakeMsg

// required .CStreamingClientHandshakeInfo info = 1;
inline bool CClientHandshakeMsg::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CClientHandshakeMsg::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CClientHandshakeMsg::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CClientHandshakeMsg::clear_info() {
  if (info_ != NULL) info_->Clear();
  clear_has_info();
}
inline const ::CStreamingClientHandshakeInfo& CClientHandshakeMsg::_internal_info() const {
  return *info_;
}
inline const ::CStreamingClientHandshakeInfo& CClientHandshakeMsg::info() const {
  const ::CStreamingClientHandshakeInfo* p = info_;
  // @@protoc_insertion_point(field_get:CClientHandshakeMsg.info)
  return p != NULL ? *p : *reinterpret_cast<const ::CStreamingClientHandshakeInfo*>(
      &::_CStreamingClientHandshakeInfo_default_instance_);
}
inline ::CStreamingClientHandshakeInfo* CClientHandshakeMsg::release_info() {
  // @@protoc_insertion_point(field_release:CClientHandshakeMsg.info)
  clear_has_info();
  ::CStreamingClientHandshakeInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline ::CStreamingClientHandshakeInfo* CClientHandshakeMsg::mutable_info() {
  set_has_info();
  if (info_ == NULL) {
    auto* p = CreateMaybeMessage<::CStreamingClientHandshakeInfo>(GetArenaNoVirtual());
    info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CClientHandshakeMsg.info)
  return info_;
}
inline void CClientHandshakeMsg::set_allocated_info(::CStreamingClientHandshakeInfo* info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete info_;
  }
  if (info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    set_has_info();
  } else {
    clear_has_info();
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:CClientHandshakeMsg.info)
}

// -------------------------------------------------------------------

// CStreamingServerHandshakeInfo

// optional int32 mtu = 1;
inline bool CStreamingServerHandshakeInfo::has_mtu() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CStreamingServerHandshakeInfo::set_has_mtu() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CStreamingServerHandshakeInfo::clear_has_mtu() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CStreamingServerHandshakeInfo::clear_mtu() {
  mtu_ = 0;
  clear_has_mtu();
}
inline ::google::protobuf::int32 CStreamingServerHandshakeInfo::mtu() const {
  // @@protoc_insertion_point(field_get:CStreamingServerHandshakeInfo.mtu)
  return mtu_;
}
inline void CStreamingServerHandshakeInfo::set_mtu(::google::protobuf::int32 value) {
  set_has_mtu();
  mtu_ = value;
  // @@protoc_insertion_point(field_set:CStreamingServerHandshakeInfo.mtu)
}

// -------------------------------------------------------------------

// CServerHandshakeMsg

// required .CStreamingServerHandshakeInfo info = 1;
inline bool CServerHandshakeMsg::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CServerHandshakeMsg::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CServerHandshakeMsg::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CServerHandshakeMsg::clear_info() {
  if (info_ != NULL) info_->Clear();
  clear_has_info();
}
inline const ::CStreamingServerHandshakeInfo& CServerHandshakeMsg::_internal_info() const {
  return *info_;
}
inline const ::CStreamingServerHandshakeInfo& CServerHandshakeMsg::info() const {
  const ::CStreamingServerHandshakeInfo* p = info_;
  // @@protoc_insertion_point(field_get:CServerHandshakeMsg.info)
  return p != NULL ? *p : *reinterpret_cast<const ::CStreamingServerHandshakeInfo*>(
      &::_CStreamingServerHandshakeInfo_default_instance_);
}
inline ::CStreamingServerHandshakeInfo* CServerHandshakeMsg::release_info() {
  // @@protoc_insertion_point(field_release:CServerHandshakeMsg.info)
  clear_has_info();
  ::CStreamingServerHandshakeInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline ::CStreamingServerHandshakeInfo* CServerHandshakeMsg::mutable_info() {
  set_has_info();
  if (info_ == NULL) {
    auto* p = CreateMaybeMessage<::CStreamingServerHandshakeInfo>(GetArenaNoVirtual());
    info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CServerHandshakeMsg.info)
  return info_;
}
inline void CServerHandshakeMsg::set_allocated_info(::CStreamingServerHandshakeInfo* info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete info_;
  }
  if (info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    set_has_info();
  } else {
    clear_has_info();
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:CServerHandshakeMsg.info)
}

// -------------------------------------------------------------------

// CAuthenticationRequestMsg

// optional bytes token = 1;
inline bool CAuthenticationRequestMsg::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CAuthenticationRequestMsg::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CAuthenticationRequestMsg::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CAuthenticationRequestMsg::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_token();
}
inline const ::std::string& CAuthenticationRequestMsg::token() const {
  // @@protoc_insertion_point(field_get:CAuthenticationRequestMsg.token)
  return token_.GetNoArena();
}
inline void CAuthenticationRequestMsg::set_token(const ::std::string& value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CAuthenticationRequestMsg.token)
}
#if LANG_CXX11
inline void CAuthenticationRequestMsg::set_token(::std::string&& value) {
  set_has_token();
  token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CAuthenticationRequestMsg.token)
}
#endif
inline void CAuthenticationRequestMsg::set_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CAuthenticationRequestMsg.token)
}
inline void CAuthenticationRequestMsg::set_token(const void* value, size_t size) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CAuthenticationRequestMsg.token)
}
inline ::std::string* CAuthenticationRequestMsg::mutable_token() {
  set_has_token();
  // @@protoc_insertion_point(field_mutable:CAuthenticationRequestMsg.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CAuthenticationRequestMsg::release_token() {
  // @@protoc_insertion_point(field_release:CAuthenticationRequestMsg.token)
  if (!has_token()) {
    return NULL;
  }
  clear_has_token();
  return token_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CAuthenticationRequestMsg::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    set_has_token();
  } else {
    clear_has_token();
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:CAuthenticationRequestMsg.token)
}

// optional .EStreamVersion version = 2 [default = k_EStreamVersionNone];
inline bool CAuthenticationRequestMsg::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CAuthenticationRequestMsg::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CAuthenticationRequestMsg::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CAuthenticationRequestMsg::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::EStreamVersion CAuthenticationRequestMsg::version() const {
  // @@protoc_insertion_point(field_get:CAuthenticationRequestMsg.version)
  return static_cast< ::EStreamVersion >(version_);
}
inline void CAuthenticationRequestMsg::set_version(::EStreamVersion value) {
  assert(::EStreamVersion_IsValid(value));
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:CAuthenticationRequestMsg.version)
}

// -------------------------------------------------------------------

// CAuthenticationResponseMsg

// optional .CAuthenticationResponseMsg.AuthenticationResult result = 1 [default = SUCCEEDED];
inline bool CAuthenticationResponseMsg::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CAuthenticationResponseMsg::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CAuthenticationResponseMsg::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CAuthenticationResponseMsg::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::CAuthenticationResponseMsg_AuthenticationResult CAuthenticationResponseMsg::result() const {
  // @@protoc_insertion_point(field_get:CAuthenticationResponseMsg.result)
  return static_cast< ::CAuthenticationResponseMsg_AuthenticationResult >(result_);
}
inline void CAuthenticationResponseMsg::set_result(::CAuthenticationResponseMsg_AuthenticationResult value) {
  assert(::CAuthenticationResponseMsg_AuthenticationResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:CAuthenticationResponseMsg.result)
}

// optional .EStreamVersion version = 2 [default = k_EStreamVersionNone];
inline bool CAuthenticationResponseMsg::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CAuthenticationResponseMsg::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CAuthenticationResponseMsg::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CAuthenticationResponseMsg::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::EStreamVersion CAuthenticationResponseMsg::version() const {
  // @@protoc_insertion_point(field_get:CAuthenticationResponseMsg.version)
  return static_cast< ::EStreamVersion >(version_);
}
inline void CAuthenticationResponseMsg::set_version(::EStreamVersion value) {
  assert(::EStreamVersion_IsValid(value));
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:CAuthenticationResponseMsg.version)
}

// -------------------------------------------------------------------

// CKeepAliveMsg

// -------------------------------------------------------------------

// CStartNetworkTestMsg

// optional uint32 frames = 1;
inline bool CStartNetworkTestMsg::has_frames() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CStartNetworkTestMsg::set_has_frames() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CStartNetworkTestMsg::clear_has_frames() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CStartNetworkTestMsg::clear_frames() {
  frames_ = 0u;
  clear_has_frames();
}
inline ::google::protobuf::uint32 CStartNetworkTestMsg::frames() const {
  // @@protoc_insertion_point(field_get:CStartNetworkTestMsg.frames)
  return frames_;
}
inline void CStartNetworkTestMsg::set_frames(::google::protobuf::uint32 value) {
  set_has_frames();
  frames_ = value;
  // @@protoc_insertion_point(field_set:CStartNetworkTestMsg.frames)
}

// optional uint32 framerate = 2;
inline bool CStartNetworkTestMsg::has_framerate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CStartNetworkTestMsg::set_has_framerate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CStartNetworkTestMsg::clear_has_framerate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CStartNetworkTestMsg::clear_framerate() {
  framerate_ = 0u;
  clear_has_framerate();
}
inline ::google::protobuf::uint32 CStartNetworkTestMsg::framerate() const {
  // @@protoc_insertion_point(field_get:CStartNetworkTestMsg.framerate)
  return framerate_;
}
inline void CStartNetworkTestMsg::set_framerate(::google::protobuf::uint32 value) {
  set_has_framerate();
  framerate_ = value;
  // @@protoc_insertion_point(field_set:CStartNetworkTestMsg.framerate)
}

// optional uint32 bitrate_kbps = 3;
inline bool CStartNetworkTestMsg::has_bitrate_kbps() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CStartNetworkTestMsg::set_has_bitrate_kbps() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CStartNetworkTestMsg::clear_has_bitrate_kbps() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CStartNetworkTestMsg::clear_bitrate_kbps() {
  bitrate_kbps_ = 0u;
  clear_has_bitrate_kbps();
}
inline ::google::protobuf::uint32 CStartNetworkTestMsg::bitrate_kbps() const {
  // @@protoc_insertion_point(field_get:CStartNetworkTestMsg.bitrate_kbps)
  return bitrate_kbps_;
}
inline void CStartNetworkTestMsg::set_bitrate_kbps(::google::protobuf::uint32 value) {
  set_has_bitrate_kbps();
  bitrate_kbps_ = value;
  // @@protoc_insertion_point(field_set:CStartNetworkTestMsg.bitrate_kbps)
}

// optional uint32 burst_bitrate_kbps = 4;
inline bool CStartNetworkTestMsg::has_burst_bitrate_kbps() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CStartNetworkTestMsg::set_has_burst_bitrate_kbps() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CStartNetworkTestMsg::clear_has_burst_bitrate_kbps() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CStartNetworkTestMsg::clear_burst_bitrate_kbps() {
  burst_bitrate_kbps_ = 0u;
  clear_has_burst_bitrate_kbps();
}
inline ::google::protobuf::uint32 CStartNetworkTestMsg::burst_bitrate_kbps() const {
  // @@protoc_insertion_point(field_get:CStartNetworkTestMsg.burst_bitrate_kbps)
  return burst_bitrate_kbps_;
}
inline void CStartNetworkTestMsg::set_burst_bitrate_kbps(::google::protobuf::uint32 value) {
  set_has_burst_bitrate_kbps();
  burst_bitrate_kbps_ = value;
  // @@protoc_insertion_point(field_set:CStartNetworkTestMsg.burst_bitrate_kbps)
}

// -------------------------------------------------------------------

// CStreamVideoMode

// required uint32 width = 1;
inline bool CStreamVideoMode::has_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CStreamVideoMode::set_has_width() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CStreamVideoMode::clear_has_width() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CStreamVideoMode::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 CStreamVideoMode::width() const {
  // @@protoc_insertion_point(field_get:CStreamVideoMode.width)
  return width_;
}
inline void CStreamVideoMode::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:CStreamVideoMode.width)
}

// required uint32 height = 2;
inline bool CStreamVideoMode::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CStreamVideoMode::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CStreamVideoMode::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CStreamVideoMode::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 CStreamVideoMode::height() const {
  // @@protoc_insertion_point(field_get:CStreamVideoMode.height)
  return height_;
}
inline void CStreamVideoMode::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:CStreamVideoMode.height)
}

// optional uint32 refresh_rate = 3;
inline bool CStreamVideoMode::has_refresh_rate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CStreamVideoMode::set_has_refresh_rate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CStreamVideoMode::clear_has_refresh_rate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CStreamVideoMode::clear_refresh_rate() {
  refresh_rate_ = 0u;
  clear_has_refresh_rate();
}
inline ::google::protobuf::uint32 CStreamVideoMode::refresh_rate() const {
  // @@protoc_insertion_point(field_get:CStreamVideoMode.refresh_rate)
  return refresh_rate_;
}
inline void CStreamVideoMode::set_refresh_rate(::google::protobuf::uint32 value) {
  set_has_refresh_rate();
  refresh_rate_ = value;
  // @@protoc_insertion_point(field_set:CStreamVideoMode.refresh_rate)
}

// optional uint32 refresh_rate_numerator = 4;
inline bool CStreamVideoMode::has_refresh_rate_numerator() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CStreamVideoMode::set_has_refresh_rate_numerator() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CStreamVideoMode::clear_has_refresh_rate_numerator() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CStreamVideoMode::clear_refresh_rate_numerator() {
  refresh_rate_numerator_ = 0u;
  clear_has_refresh_rate_numerator();
}
inline ::google::protobuf::uint32 CStreamVideoMode::refresh_rate_numerator() const {
  // @@protoc_insertion_point(field_get:CStreamVideoMode.refresh_rate_numerator)
  return refresh_rate_numerator_;
}
inline void CStreamVideoMode::set_refresh_rate_numerator(::google::protobuf::uint32 value) {
  set_has_refresh_rate_numerator();
  refresh_rate_numerator_ = value;
  // @@protoc_insertion_point(field_set:CStreamVideoMode.refresh_rate_numerator)
}

// optional uint32 refresh_rate_denominator = 5;
inline bool CStreamVideoMode::has_refresh_rate_denominator() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CStreamVideoMode::set_has_refresh_rate_denominator() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CStreamVideoMode::clear_has_refresh_rate_denominator() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CStreamVideoMode::clear_refresh_rate_denominator() {
  refresh_rate_denominator_ = 0u;
  clear_has_refresh_rate_denominator();
}
inline ::google::protobuf::uint32 CStreamVideoMode::refresh_rate_denominator() const {
  // @@protoc_insertion_point(field_get:CStreamVideoMode.refresh_rate_denominator)
  return refresh_rate_denominator_;
}
inline void CStreamVideoMode::set_refresh_rate_denominator(::google::protobuf::uint32 value) {
  set_has_refresh_rate_denominator();
  refresh_rate_denominator_ = value;
  // @@protoc_insertion_point(field_set:CStreamVideoMode.refresh_rate_denominator)
}

// -------------------------------------------------------------------

// CStreamingClientCaps

// optional string system_info = 1;
inline bool CStreamingClientCaps::has_system_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CStreamingClientCaps::set_has_system_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CStreamingClientCaps::clear_has_system_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CStreamingClientCaps::clear_system_info() {
  system_info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_system_info();
}
inline const ::std::string& CStreamingClientCaps::system_info() const {
  // @@protoc_insertion_point(field_get:CStreamingClientCaps.system_info)
  return system_info_.GetNoArena();
}
inline void CStreamingClientCaps::set_system_info(const ::std::string& value) {
  set_has_system_info();
  system_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CStreamingClientCaps.system_info)
}
#if LANG_CXX11
inline void CStreamingClientCaps::set_system_info(::std::string&& value) {
  set_has_system_info();
  system_info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CStreamingClientCaps.system_info)
}
#endif
inline void CStreamingClientCaps::set_system_info(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_system_info();
  system_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CStreamingClientCaps.system_info)
}
inline void CStreamingClientCaps::set_system_info(const char* value, size_t size) {
  set_has_system_info();
  system_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CStreamingClientCaps.system_info)
}
inline ::std::string* CStreamingClientCaps::mutable_system_info() {
  set_has_system_info();
  // @@protoc_insertion_point(field_mutable:CStreamingClientCaps.system_info)
  return system_info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CStreamingClientCaps::release_system_info() {
  // @@protoc_insertion_point(field_release:CStreamingClientCaps.system_info)
  if (!has_system_info()) {
    return NULL;
  }
  clear_has_system_info();
  return system_info_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CStreamingClientCaps::set_allocated_system_info(::std::string* system_info) {
  if (system_info != NULL) {
    set_has_system_info();
  } else {
    clear_has_system_info();
  }
  system_info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), system_info);
  // @@protoc_insertion_point(field_set_allocated:CStreamingClientCaps.system_info)
}

// optional bool system_can_suspend = 2;
inline bool CStreamingClientCaps::has_system_can_suspend() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CStreamingClientCaps::set_has_system_can_suspend() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CStreamingClientCaps::clear_has_system_can_suspend() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CStreamingClientCaps::clear_system_can_suspend() {
  system_can_suspend_ = false;
  clear_has_system_can_suspend();
}
inline bool CStreamingClientCaps::system_can_suspend() const {
  // @@protoc_insertion_point(field_get:CStreamingClientCaps.system_can_suspend)
  return system_can_suspend_;
}
inline void CStreamingClientCaps::set_system_can_suspend(bool value) {
  set_has_system_can_suspend();
  system_can_suspend_ = value;
  // @@protoc_insertion_point(field_set:CStreamingClientCaps.system_can_suspend)
}

// optional int32 maximum_decode_bitrate_kbps = 3;
inline bool CStreamingClientCaps::has_maximum_decode_bitrate_kbps() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CStreamingClientCaps::set_has_maximum_decode_bitrate_kbps() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CStreamingClientCaps::clear_has_maximum_decode_bitrate_kbps() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CStreamingClientCaps::clear_maximum_decode_bitrate_kbps() {
  maximum_decode_bitrate_kbps_ = 0;
  clear_has_maximum_decode_bitrate_kbps();
}
inline ::google::protobuf::int32 CStreamingClientCaps::maximum_decode_bitrate_kbps() const {
  // @@protoc_insertion_point(field_get:CStreamingClientCaps.maximum_decode_bitrate_kbps)
  return maximum_decode_bitrate_kbps_;
}
inline void CStreamingClientCaps::set_maximum_decode_bitrate_kbps(::google::protobuf::int32 value) {
  set_has_maximum_decode_bitrate_kbps();
  maximum_decode_bitrate_kbps_ = value;
  // @@protoc_insertion_point(field_set:CStreamingClientCaps.maximum_decode_bitrate_kbps)
}

// optional int32 maximum_burst_bitrate_kbps = 4;
inline bool CStreamingClientCaps::has_maximum_burst_bitrate_kbps() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CStreamingClientCaps::set_has_maximum_burst_bitrate_kbps() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CStreamingClientCaps::clear_has_maximum_burst_bitrate_kbps() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CStreamingClientCaps::clear_maximum_burst_bitrate_kbps() {
  maximum_burst_bitrate_kbps_ = 0;
  clear_has_maximum_burst_bitrate_kbps();
}
inline ::google::protobuf::int32 CStreamingClientCaps::maximum_burst_bitrate_kbps() const {
  // @@protoc_insertion_point(field_get:CStreamingClientCaps.maximum_burst_bitrate_kbps)
  return maximum_burst_bitrate_kbps_;
}
inline void CStreamingClientCaps::set_maximum_burst_bitrate_kbps(::google::protobuf::int32 value) {
  set_has_maximum_burst_bitrate_kbps();
  maximum_burst_bitrate_kbps_ = value;
  // @@protoc_insertion_point(field_set:CStreamingClientCaps.maximum_burst_bitrate_kbps)
}

// optional bool supports_video_hevc = 5;
inline bool CStreamingClientCaps::has_supports_video_hevc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CStreamingClientCaps::set_has_supports_video_hevc() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CStreamingClientCaps::clear_has_supports_video_hevc() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CStreamingClientCaps::clear_supports_video_hevc() {
  supports_video_hevc_ = false;
  clear_has_supports_video_hevc();
}
inline bool CStreamingClientCaps::supports_video_hevc() const {
  // @@protoc_insertion_point(field_get:CStreamingClientCaps.supports_video_hevc)
  return supports_video_hevc_;
}
inline void CStreamingClientCaps::set_supports_video_hevc(bool value) {
  set_has_supports_video_hevc();
  supports_video_hevc_ = value;
  // @@protoc_insertion_point(field_set:CStreamingClientCaps.supports_video_hevc)
}

// optional bool disable_steam_store = 6;
inline bool CStreamingClientCaps::has_disable_steam_store() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CStreamingClientCaps::set_has_disable_steam_store() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CStreamingClientCaps::clear_has_disable_steam_store() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CStreamingClientCaps::clear_disable_steam_store() {
  disable_steam_store_ = false;
  clear_has_disable_steam_store();
}
inline bool CStreamingClientCaps::disable_steam_store() const {
  // @@protoc_insertion_point(field_get:CStreamingClientCaps.disable_steam_store)
  return disable_steam_store_;
}
inline void CStreamingClientCaps::set_disable_steam_store(bool value) {
  set_has_disable_steam_store();
  disable_steam_store_ = value;
  // @@protoc_insertion_point(field_set:CStreamingClientCaps.disable_steam_store)
}

// optional bool disable_client_cursor = 7;
inline bool CStreamingClientCaps::has_disable_client_cursor() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CStreamingClientCaps::set_has_disable_client_cursor() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CStreamingClientCaps::clear_has_disable_client_cursor() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CStreamingClientCaps::clear_disable_client_cursor() {
  disable_client_cursor_ = false;
  clear_has_disable_client_cursor();
}
inline bool CStreamingClientCaps::disable_client_cursor() const {
  // @@protoc_insertion_point(field_get:CStreamingClientCaps.disable_client_cursor)
  return disable_client_cursor_;
}
inline void CStreamingClientCaps::set_disable_client_cursor(bool value) {
  set_has_disable_client_cursor();
  disable_client_cursor_ = value;
  // @@protoc_insertion_point(field_set:CStreamingClientCaps.disable_client_cursor)
}

// optional bool disable_intel_hardware_encoding = 8;
inline bool CStreamingClientCaps::has_disable_intel_hardware_encoding() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CStreamingClientCaps::set_has_disable_intel_hardware_encoding() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CStreamingClientCaps::clear_has_disable_intel_hardware_encoding() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CStreamingClientCaps::clear_disable_intel_hardware_encoding() {
  disable_intel_hardware_encoding_ = false;
  clear_has_disable_intel_hardware_encoding();
}
inline bool CStreamingClientCaps::disable_intel_hardware_encoding() const {
  // @@protoc_insertion_point(field_get:CStreamingClientCaps.disable_intel_hardware_encoding)
  return disable_intel_hardware_encoding_;
}
inline void CStreamingClientCaps::set_disable_intel_hardware_encoding(bool value) {
  set_has_disable_intel_hardware_encoding();
  disable_intel_hardware_encoding_ = value;
  // @@protoc_insertion_point(field_set:CStreamingClientCaps.disable_intel_hardware_encoding)
}

// optional bool disable_amd_hardware_encoding = 9;
inline bool CStreamingClientCaps::has_disable_amd_hardware_encoding() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CStreamingClientCaps::set_has_disable_amd_hardware_encoding() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CStreamingClientCaps::clear_has_disable_amd_hardware_encoding() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CStreamingClientCaps::clear_disable_amd_hardware_encoding() {
  disable_amd_hardware_encoding_ = false;
  clear_has_disable_amd_hardware_encoding();
}
inline bool CStreamingClientCaps::disable_amd_hardware_encoding() const {
  // @@protoc_insertion_point(field_get:CStreamingClientCaps.disable_amd_hardware_encoding)
  return disable_amd_hardware_encoding_;
}
inline void CStreamingClientCaps::set_disable_amd_hardware_encoding(bool value) {
  set_has_disable_amd_hardware_encoding();
  disable_amd_hardware_encoding_ = value;
  // @@protoc_insertion_point(field_set:CStreamingClientCaps.disable_amd_hardware_encoding)
}

// optional bool disable_nvidia_hardware_encoding = 10;
inline bool CStreamingClientCaps::has_disable_nvidia_hardware_encoding() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CStreamingClientCaps::set_has_disable_nvidia_hardware_encoding() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CStreamingClientCaps::clear_has_disable_nvidia_hardware_encoding() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CStreamingClientCaps::clear_disable_nvidia_hardware_encoding() {
  disable_nvidia_hardware_encoding_ = false;
  clear_has_disable_nvidia_hardware_encoding();
}
inline bool CStreamingClientCaps::disable_nvidia_hardware_encoding() const {
  // @@protoc_insertion_point(field_get:CStreamingClientCaps.disable_nvidia_hardware_encoding)
  return disable_nvidia_hardware_encoding_;
}
inline void CStreamingClientCaps::set_disable_nvidia_hardware_encoding(bool value) {
  set_has_disable_nvidia_hardware_encoding();
  disable_nvidia_hardware_encoding_ = value;
  // @@protoc_insertion_point(field_set:CStreamingClientCaps.disable_nvidia_hardware_encoding)
}

// -------------------------------------------------------------------

// CStreamingClientConfig

// optional .EStreamQualityPreference quality = 1 [default = k_EStreamQualityBalanced];
inline bool CStreamingClientConfig::has_quality() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CStreamingClientConfig::set_has_quality() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CStreamingClientConfig::clear_has_quality() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CStreamingClientConfig::clear_quality() {
  quality_ = 2;
  clear_has_quality();
}
inline ::EStreamQualityPreference CStreamingClientConfig::quality() const {
  // @@protoc_insertion_point(field_get:CStreamingClientConfig.quality)
  return static_cast< ::EStreamQualityPreference >(quality_);
}
inline void CStreamingClientConfig::set_quality(::EStreamQualityPreference value) {
  assert(::EStreamQualityPreference_IsValid(value));
  set_has_quality();
  quality_ = value;
  // @@protoc_insertion_point(field_set:CStreamingClientConfig.quality)
}

// optional uint32 maximum_resolution_x = 2;
inline bool CStreamingClientConfig::has_maximum_resolution_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CStreamingClientConfig::set_has_maximum_resolution_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CStreamingClientConfig::clear_has_maximum_resolution_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CStreamingClientConfig::clear_maximum_resolution_x() {
  maximum_resolution_x_ = 0u;
  clear_has_maximum_resolution_x();
}
inline ::google::protobuf::uint32 CStreamingClientConfig::maximum_resolution_x() const {
  // @@protoc_insertion_point(field_get:CStreamingClientConfig.maximum_resolution_x)
  return maximum_resolution_x_;
}
inline void CStreamingClientConfig::set_maximum_resolution_x(::google::protobuf::uint32 value) {
  set_has_maximum_resolution_x();
  maximum_resolution_x_ = value;
  // @@protoc_insertion_point(field_set:CStreamingClientConfig.maximum_resolution_x)
}

// optional uint32 maximum_resolution_y = 3;
inline bool CStreamingClientConfig::has_maximum_resolution_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CStreamingClientConfig::set_has_maximum_resolution_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CStreamingClientConfig::clear_has_maximum_resolution_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CStreamingClientConfig::clear_maximum_resolution_y() {
  maximum_resolution_y_ = 0u;
  clear_has_maximum_resolution_y();
}
inline ::google::protobuf::uint32 CStreamingClientConfig::maximum_resolution_y() const {
  // @@protoc_insertion_point(field_get:CStreamingClientConfig.maximum_resolution_y)
  return maximum_resolution_y_;
}
inline void CStreamingClientConfig::set_maximum_resolution_y(::google::protobuf::uint32 value) {
  set_has_maximum_resolution_y();
  maximum_resolution_y_ = value;
  // @@protoc_insertion_point(field_set:CStreamingClientConfig.maximum_resolution_y)
}

// optional uint32 maximum_framerate_numerator = 4;
inline bool CStreamingClientConfig::has_maximum_framerate_numerator() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CStreamingClientConfig::set_has_maximum_framerate_numerator() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CStreamingClientConfig::clear_has_maximum_framerate_numerator() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CStreamingClientConfig::clear_maximum_framerate_numerator() {
  maximum_framerate_numerator_ = 0u;
  clear_has_maximum_framerate_numerator();
}
inline ::google::protobuf::uint32 CStreamingClientConfig::maximum_framerate_numerator() const {
  // @@protoc_insertion_point(field_get:CStreamingClientConfig.maximum_framerate_numerator)
  return maximum_framerate_numerator_;
}
inline void CStreamingClientConfig::set_maximum_framerate_numerator(::google::protobuf::uint32 value) {
  set_has_maximum_framerate_numerator();
  maximum_framerate_numerator_ = value;
  // @@protoc_insertion_point(field_set:CStreamingClientConfig.maximum_framerate_numerator)
}

// optional uint32 maximum_framerate_denominator = 5;
inline bool CStreamingClientConfig::has_maximum_framerate_denominator() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CStreamingClientConfig::set_has_maximum_framerate_denominator() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CStreamingClientConfig::clear_has_maximum_framerate_denominator() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CStreamingClientConfig::clear_maximum_framerate_denominator() {
  maximum_framerate_denominator_ = 0u;
  clear_has_maximum_framerate_denominator();
}
inline ::google::protobuf::uint32 CStreamingClientConfig::maximum_framerate_denominator() const {
  // @@protoc_insertion_point(field_get:CStreamingClientConfig.maximum_framerate_denominator)
  return maximum_framerate_denominator_;
}
inline void CStreamingClientConfig::set_maximum_framerate_denominator(::google::protobuf::uint32 value) {
  set_has_maximum_framerate_denominator();
  maximum_framerate_denominator_ = value;
  // @@protoc_insertion_point(field_set:CStreamingClientConfig.maximum_framerate_denominator)
}

// optional int32 maximum_bitrate_kbps = 6 [default = -1];
inline bool CStreamingClientConfig::has_maximum_bitrate_kbps() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CStreamingClientConfig::set_has_maximum_bitrate_kbps() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CStreamingClientConfig::clear_has_maximum_bitrate_kbps() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CStreamingClientConfig::clear_maximum_bitrate_kbps() {
  maximum_bitrate_kbps_ = -1;
  clear_has_maximum_bitrate_kbps();
}
inline ::google::protobuf::int32 CStreamingClientConfig::maximum_bitrate_kbps() const {
  // @@protoc_insertion_point(field_get:CStreamingClientConfig.maximum_bitrate_kbps)
  return maximum_bitrate_kbps_;
}
inline void CStreamingClientConfig::set_maximum_bitrate_kbps(::google::protobuf::int32 value) {
  set_has_maximum_bitrate_kbps();
  maximum_bitrate_kbps_ = value;
  // @@protoc_insertion_point(field_set:CStreamingClientConfig.maximum_bitrate_kbps)
}

// optional bool enable_hardware_decoding = 7 [default = true];
inline bool CStreamingClientConfig::has_enable_hardware_decoding() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CStreamingClientConfig::set_has_enable_hardware_decoding() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CStreamingClientConfig::clear_has_enable_hardware_decoding() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CStreamingClientConfig::clear_enable_hardware_decoding() {
  enable_hardware_decoding_ = true;
  clear_has_enable_hardware_decoding();
}
inline bool CStreamingClientConfig::enable_hardware_decoding() const {
  // @@protoc_insertion_point(field_get:CStreamingClientConfig.enable_hardware_decoding)
  return enable_hardware_decoding_;
}
inline void CStreamingClientConfig::set_enable_hardware_decoding(bool value) {
  set_has_enable_hardware_decoding();
  enable_hardware_decoding_ = value;
  // @@protoc_insertion_point(field_set:CStreamingClientConfig.enable_hardware_decoding)
}

// optional bool enable_performance_overlay = 8 [default = false];
inline bool CStreamingClientConfig::has_enable_performance_overlay() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CStreamingClientConfig::set_has_enable_performance_overlay() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CStreamingClientConfig::clear_has_enable_performance_overlay() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CStreamingClientConfig::clear_enable_performance_overlay() {
  enable_performance_overlay_ = false;
  clear_has_enable_performance_overlay();
}
inline bool CStreamingClientConfig::enable_performance_overlay() const {
  // @@protoc_insertion_point(field_get:CStreamingClientConfig.enable_performance_overlay)
  return enable_performance_overlay_;
}
inline void CStreamingClientConfig::set_enable_performance_overlay(bool value) {
  set_has_enable_performance_overlay();
  enable_performance_overlay_ = value;
  // @@protoc_insertion_point(field_set:CStreamingClientConfig.enable_performance_overlay)
}

// optional bool enable_video_streaming = 9 [default = true];
inline bool CStreamingClientConfig::has_enable_video_streaming() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CStreamingClientConfig::set_has_enable_video_streaming() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CStreamingClientConfig::clear_has_enable_video_streaming() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CStreamingClientConfig::clear_enable_video_streaming() {
  enable_video_streaming_ = true;
  clear_has_enable_video_streaming();
}
inline bool CStreamingClientConfig::enable_video_streaming() const {
  // @@protoc_insertion_point(field_get:CStreamingClientConfig.enable_video_streaming)
  return enable_video_streaming_;
}
inline void CStreamingClientConfig::set_enable_video_streaming(bool value) {
  set_has_enable_video_streaming();
  enable_video_streaming_ = value;
  // @@protoc_insertion_point(field_set:CStreamingClientConfig.enable_video_streaming)
}

// optional bool enable_audio_streaming = 10 [default = true];
inline bool CStreamingClientConfig::has_enable_audio_streaming() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CStreamingClientConfig::set_has_enable_audio_streaming() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CStreamingClientConfig::clear_has_enable_audio_streaming() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CStreamingClientConfig::clear_enable_audio_streaming() {
  enable_audio_streaming_ = true;
  clear_has_enable_audio_streaming();
}
inline bool CStreamingClientConfig::enable_audio_streaming() const {
  // @@protoc_insertion_point(field_get:CStreamingClientConfig.enable_audio_streaming)
  return enable_audio_streaming_;
}
inline void CStreamingClientConfig::set_enable_audio_streaming(bool value) {
  set_has_enable_audio_streaming();
  enable_audio_streaming_ = value;
  // @@protoc_insertion_point(field_set:CStreamingClientConfig.enable_audio_streaming)
}

// optional bool enable_input_streaming = 11 [default = true];
inline bool CStreamingClientConfig::has_enable_input_streaming() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CStreamingClientConfig::set_has_enable_input_streaming() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CStreamingClientConfig::clear_has_enable_input_streaming() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CStreamingClientConfig::clear_enable_input_streaming() {
  enable_input_streaming_ = true;
  clear_has_enable_input_streaming();
}
inline bool CStreamingClientConfig::enable_input_streaming() const {
  // @@protoc_insertion_point(field_get:CStreamingClientConfig.enable_input_streaming)
  return enable_input_streaming_;
}
inline void CStreamingClientConfig::set_enable_input_streaming(bool value) {
  set_has_enable_input_streaming();
  enable_input_streaming_ = value;
  // @@protoc_insertion_point(field_set:CStreamingClientConfig.enable_input_streaming)
}

// optional int32 audio_channels = 12 [default = 2];
inline bool CStreamingClientConfig::has_audio_channels() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CStreamingClientConfig::set_has_audio_channels() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CStreamingClientConfig::clear_has_audio_channels() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CStreamingClientConfig::clear_audio_channels() {
  audio_channels_ = 2;
  clear_has_audio_channels();
}
inline ::google::protobuf::int32 CStreamingClientConfig::audio_channels() const {
  // @@protoc_insertion_point(field_get:CStreamingClientConfig.audio_channels)
  return audio_channels_;
}
inline void CStreamingClientConfig::set_audio_channels(::google::protobuf::int32 value) {
  set_has_audio_channels();
  audio_channels_ = value;
  // @@protoc_insertion_point(field_set:CStreamingClientConfig.audio_channels)
}

// optional bool enable_video_hevc = 13 [default = false];
inline bool CStreamingClientConfig::has_enable_video_hevc() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CStreamingClientConfig::set_has_enable_video_hevc() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CStreamingClientConfig::clear_has_enable_video_hevc() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CStreamingClientConfig::clear_enable_video_hevc() {
  enable_video_hevc_ = false;
  clear_has_enable_video_hevc();
}
inline bool CStreamingClientConfig::enable_video_hevc() const {
  // @@protoc_insertion_point(field_get:CStreamingClientConfig.enable_video_hevc)
  return enable_video_hevc_;
}
inline void CStreamingClientConfig::set_enable_video_hevc(bool value) {
  set_has_enable_video_hevc();
  enable_video_hevc_ = value;
  // @@protoc_insertion_point(field_set:CStreamingClientConfig.enable_video_hevc)
}

// -------------------------------------------------------------------

// CStreamingServerConfig

// optional bool change_desktop_resolution = 1;
inline bool CStreamingServerConfig::has_change_desktop_resolution() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CStreamingServerConfig::set_has_change_desktop_resolution() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CStreamingServerConfig::clear_has_change_desktop_resolution() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CStreamingServerConfig::clear_change_desktop_resolution() {
  change_desktop_resolution_ = false;
  clear_has_change_desktop_resolution();
}
inline bool CStreamingServerConfig::change_desktop_resolution() const {
  // @@protoc_insertion_point(field_get:CStreamingServerConfig.change_desktop_resolution)
  return change_desktop_resolution_;
}
inline void CStreamingServerConfig::set_change_desktop_resolution(bool value) {
  set_has_change_desktop_resolution();
  change_desktop_resolution_ = value;
  // @@protoc_insertion_point(field_set:CStreamingServerConfig.change_desktop_resolution)
}

// optional bool dynamically_adjust_resolution = 2;
inline bool CStreamingServerConfig::has_dynamically_adjust_resolution() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CStreamingServerConfig::set_has_dynamically_adjust_resolution() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CStreamingServerConfig::clear_has_dynamically_adjust_resolution() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CStreamingServerConfig::clear_dynamically_adjust_resolution() {
  dynamically_adjust_resolution_ = false;
  clear_has_dynamically_adjust_resolution();
}
inline bool CStreamingServerConfig::dynamically_adjust_resolution() const {
  // @@protoc_insertion_point(field_get:CStreamingServerConfig.dynamically_adjust_resolution)
  return dynamically_adjust_resolution_;
}
inline void CStreamingServerConfig::set_dynamically_adjust_resolution(bool value) {
  set_has_dynamically_adjust_resolution();
  dynamically_adjust_resolution_ = value;
  // @@protoc_insertion_point(field_set:CStreamingServerConfig.dynamically_adjust_resolution)
}

// optional bool enable_capture_nvfbc = 3;
inline bool CStreamingServerConfig::has_enable_capture_nvfbc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CStreamingServerConfig::set_has_enable_capture_nvfbc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CStreamingServerConfig::clear_has_enable_capture_nvfbc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CStreamingServerConfig::clear_enable_capture_nvfbc() {
  enable_capture_nvfbc_ = false;
  clear_has_enable_capture_nvfbc();
}
inline bool CStreamingServerConfig::enable_capture_nvfbc() const {
  // @@protoc_insertion_point(field_get:CStreamingServerConfig.enable_capture_nvfbc)
  return enable_capture_nvfbc_;
}
inline void CStreamingServerConfig::set_enable_capture_nvfbc(bool value) {
  set_has_enable_capture_nvfbc();
  enable_capture_nvfbc_ = value;
  // @@protoc_insertion_point(field_set:CStreamingServerConfig.enable_capture_nvfbc)
}

// optional bool enable_hardware_encoding_nvidia = 4;
inline bool CStreamingServerConfig::has_enable_hardware_encoding_nvidia() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CStreamingServerConfig::set_has_enable_hardware_encoding_nvidia() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CStreamingServerConfig::clear_has_enable_hardware_encoding_nvidia() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CStreamingServerConfig::clear_enable_hardware_encoding_nvidia() {
  enable_hardware_encoding_nvidia_ = false;
  clear_has_enable_hardware_encoding_nvidia();
}
inline bool CStreamingServerConfig::enable_hardware_encoding_nvidia() const {
  // @@protoc_insertion_point(field_get:CStreamingServerConfig.enable_hardware_encoding_nvidia)
  return enable_hardware_encoding_nvidia_;
}
inline void CStreamingServerConfig::set_enable_hardware_encoding_nvidia(bool value) {
  set_has_enable_hardware_encoding_nvidia();
  enable_hardware_encoding_nvidia_ = value;
  // @@protoc_insertion_point(field_set:CStreamingServerConfig.enable_hardware_encoding_nvidia)
}

// optional bool enable_hardware_encoding_amd = 5;
inline bool CStreamingServerConfig::has_enable_hardware_encoding_amd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CStreamingServerConfig::set_has_enable_hardware_encoding_amd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CStreamingServerConfig::clear_has_enable_hardware_encoding_amd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CStreamingServerConfig::clear_enable_hardware_encoding_amd() {
  enable_hardware_encoding_amd_ = false;
  clear_has_enable_hardware_encoding_amd();
}
inline bool CStreamingServerConfig::enable_hardware_encoding_amd() const {
  // @@protoc_insertion_point(field_get:CStreamingServerConfig.enable_hardware_encoding_amd)
  return enable_hardware_encoding_amd_;
}
inline void CStreamingServerConfig::set_enable_hardware_encoding_amd(bool value) {
  set_has_enable_hardware_encoding_amd();
  enable_hardware_encoding_amd_ = value;
  // @@protoc_insertion_point(field_set:CStreamingServerConfig.enable_hardware_encoding_amd)
}

// optional bool enable_hardware_encoding_intel = 6;
inline bool CStreamingServerConfig::has_enable_hardware_encoding_intel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CStreamingServerConfig::set_has_enable_hardware_encoding_intel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CStreamingServerConfig::clear_has_enable_hardware_encoding_intel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CStreamingServerConfig::clear_enable_hardware_encoding_intel() {
  enable_hardware_encoding_intel_ = false;
  clear_has_enable_hardware_encoding_intel();
}
inline bool CStreamingServerConfig::enable_hardware_encoding_intel() const {
  // @@protoc_insertion_point(field_get:CStreamingServerConfig.enable_hardware_encoding_intel)
  return enable_hardware_encoding_intel_;
}
inline void CStreamingServerConfig::set_enable_hardware_encoding_intel(bool value) {
  set_has_enable_hardware_encoding_intel();
  enable_hardware_encoding_intel_ = value;
  // @@protoc_insertion_point(field_set:CStreamingServerConfig.enable_hardware_encoding_intel)
}

// optional int32 software_encoding_threads = 7;
inline bool CStreamingServerConfig::has_software_encoding_threads() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CStreamingServerConfig::set_has_software_encoding_threads() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CStreamingServerConfig::clear_has_software_encoding_threads() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CStreamingServerConfig::clear_software_encoding_threads() {
  software_encoding_threads_ = 0;
  clear_has_software_encoding_threads();
}
inline ::google::protobuf::int32 CStreamingServerConfig::software_encoding_threads() const {
  // @@protoc_insertion_point(field_get:CStreamingServerConfig.software_encoding_threads)
  return software_encoding_threads_;
}
inline void CStreamingServerConfig::set_software_encoding_threads(::google::protobuf::int32 value) {
  set_has_software_encoding_threads();
  software_encoding_threads_ = value;
  // @@protoc_insertion_point(field_set:CStreamingServerConfig.software_encoding_threads)
}

// optional bool enable_traffic_priority = 8;
inline bool CStreamingServerConfig::has_enable_traffic_priority() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CStreamingServerConfig::set_has_enable_traffic_priority() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CStreamingServerConfig::clear_has_enable_traffic_priority() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CStreamingServerConfig::clear_enable_traffic_priority() {
  enable_traffic_priority_ = false;
  clear_has_enable_traffic_priority();
}
inline bool CStreamingServerConfig::enable_traffic_priority() const {
  // @@protoc_insertion_point(field_get:CStreamingServerConfig.enable_traffic_priority)
  return enable_traffic_priority_;
}
inline void CStreamingServerConfig::set_enable_traffic_priority(bool value) {
  set_has_enable_traffic_priority();
  enable_traffic_priority_ = value;
  // @@protoc_insertion_point(field_set:CStreamingServerConfig.enable_traffic_priority)
}

// -------------------------------------------------------------------

// CNegotiatedConfig

// optional bool reliable_data = 1;
inline bool CNegotiatedConfig::has_reliable_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CNegotiatedConfig::set_has_reliable_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CNegotiatedConfig::clear_has_reliable_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CNegotiatedConfig::clear_reliable_data() {
  reliable_data_ = false;
  clear_has_reliable_data();
}
inline bool CNegotiatedConfig::reliable_data() const {
  // @@protoc_insertion_point(field_get:CNegotiatedConfig.reliable_data)
  return reliable_data_;
}
inline void CNegotiatedConfig::set_reliable_data(bool value) {
  set_has_reliable_data();
  reliable_data_ = value;
  // @@protoc_insertion_point(field_set:CNegotiatedConfig.reliable_data)
}

// optional .EStreamAudioCodec selected_audio_codec = 2 [default = k_EStreamAudioCodecNone];
inline bool CNegotiatedConfig::has_selected_audio_codec() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CNegotiatedConfig::set_has_selected_audio_codec() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CNegotiatedConfig::clear_has_selected_audio_codec() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CNegotiatedConfig::clear_selected_audio_codec() {
  selected_audio_codec_ = 0;
  clear_has_selected_audio_codec();
}
inline ::EStreamAudioCodec CNegotiatedConfig::selected_audio_codec() const {
  // @@protoc_insertion_point(field_get:CNegotiatedConfig.selected_audio_codec)
  return static_cast< ::EStreamAudioCodec >(selected_audio_codec_);
}
inline void CNegotiatedConfig::set_selected_audio_codec(::EStreamAudioCodec value) {
  assert(::EStreamAudioCodec_IsValid(value));
  set_has_selected_audio_codec();
  selected_audio_codec_ = value;
  // @@protoc_insertion_point(field_set:CNegotiatedConfig.selected_audio_codec)
}

// optional .EStreamVideoCodec selected_video_codec = 3 [default = k_EStreamVideoCodecNone];
inline bool CNegotiatedConfig::has_selected_video_codec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CNegotiatedConfig::set_has_selected_video_codec() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CNegotiatedConfig::clear_has_selected_video_codec() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CNegotiatedConfig::clear_selected_video_codec() {
  selected_video_codec_ = 0;
  clear_has_selected_video_codec();
}
inline ::EStreamVideoCodec CNegotiatedConfig::selected_video_codec() const {
  // @@protoc_insertion_point(field_get:CNegotiatedConfig.selected_video_codec)
  return static_cast< ::EStreamVideoCodec >(selected_video_codec_);
}
inline void CNegotiatedConfig::set_selected_video_codec(::EStreamVideoCodec value) {
  assert(::EStreamVideoCodec_IsValid(value));
  set_has_selected_video_codec();
  selected_video_codec_ = value;
  // @@protoc_insertion_point(field_set:CNegotiatedConfig.selected_video_codec)
}

// repeated .CStreamVideoMode available_video_modes = 4;
inline int CNegotiatedConfig::available_video_modes_size() const {
  return available_video_modes_.size();
}
inline void CNegotiatedConfig::clear_available_video_modes() {
  available_video_modes_.Clear();
}
inline ::CStreamVideoMode* CNegotiatedConfig::mutable_available_video_modes(int index) {
  // @@protoc_insertion_point(field_mutable:CNegotiatedConfig.available_video_modes)
  return available_video_modes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::CStreamVideoMode >*
CNegotiatedConfig::mutable_available_video_modes() {
  // @@protoc_insertion_point(field_mutable_list:CNegotiatedConfig.available_video_modes)
  return &available_video_modes_;
}
inline const ::CStreamVideoMode& CNegotiatedConfig::available_video_modes(int index) const {
  // @@protoc_insertion_point(field_get:CNegotiatedConfig.available_video_modes)
  return available_video_modes_.Get(index);
}
inline ::CStreamVideoMode* CNegotiatedConfig::add_available_video_modes() {
  // @@protoc_insertion_point(field_add:CNegotiatedConfig.available_video_modes)
  return available_video_modes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CStreamVideoMode >&
CNegotiatedConfig::available_video_modes() const {
  // @@protoc_insertion_point(field_list:CNegotiatedConfig.available_video_modes)
  return available_video_modes_;
}

// optional bool enable_remote_hid = 5;
inline bool CNegotiatedConfig::has_enable_remote_hid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CNegotiatedConfig::set_has_enable_remote_hid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CNegotiatedConfig::clear_has_enable_remote_hid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CNegotiatedConfig::clear_enable_remote_hid() {
  enable_remote_hid_ = false;
  clear_has_enable_remote_hid();
}
inline bool CNegotiatedConfig::enable_remote_hid() const {
  // @@protoc_insertion_point(field_get:CNegotiatedConfig.enable_remote_hid)
  return enable_remote_hid_;
}
inline void CNegotiatedConfig::set_enable_remote_hid(bool value) {
  set_has_enable_remote_hid();
  enable_remote_hid_ = value;
  // @@protoc_insertion_point(field_set:CNegotiatedConfig.enable_remote_hid)
}

// -------------------------------------------------------------------

// CNegotiationInitMsg

// optional bool reliable_data = 1;
inline bool CNegotiationInitMsg::has_reliable_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CNegotiationInitMsg::set_has_reliable_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CNegotiationInitMsg::clear_has_reliable_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CNegotiationInitMsg::clear_reliable_data() {
  reliable_data_ = false;
  clear_has_reliable_data();
}
inline bool CNegotiationInitMsg::reliable_data() const {
  // @@protoc_insertion_point(field_get:CNegotiationInitMsg.reliable_data)
  return reliable_data_;
}
inline void CNegotiationInitMsg::set_reliable_data(bool value) {
  set_has_reliable_data();
  reliable_data_ = value;
  // @@protoc_insertion_point(field_set:CNegotiationInitMsg.reliable_data)
}

// repeated .EStreamAudioCodec supported_audio_codecs = 2;
inline int CNegotiationInitMsg::supported_audio_codecs_size() const {
  return supported_audio_codecs_.size();
}
inline void CNegotiationInitMsg::clear_supported_audio_codecs() {
  supported_audio_codecs_.Clear();
}
inline ::EStreamAudioCodec CNegotiationInitMsg::supported_audio_codecs(int index) const {
  // @@protoc_insertion_point(field_get:CNegotiationInitMsg.supported_audio_codecs)
  return static_cast< ::EStreamAudioCodec >(supported_audio_codecs_.Get(index));
}
inline void CNegotiationInitMsg::set_supported_audio_codecs(int index, ::EStreamAudioCodec value) {
  assert(::EStreamAudioCodec_IsValid(value));
  supported_audio_codecs_.Set(index, value);
  // @@protoc_insertion_point(field_set:CNegotiationInitMsg.supported_audio_codecs)
}
inline void CNegotiationInitMsg::add_supported_audio_codecs(::EStreamAudioCodec value) {
  assert(::EStreamAudioCodec_IsValid(value));
  supported_audio_codecs_.Add(value);
  // @@protoc_insertion_point(field_add:CNegotiationInitMsg.supported_audio_codecs)
}
inline const ::google::protobuf::RepeatedField<int>&
CNegotiationInitMsg::supported_audio_codecs() const {
  // @@protoc_insertion_point(field_list:CNegotiationInitMsg.supported_audio_codecs)
  return supported_audio_codecs_;
}
inline ::google::protobuf::RepeatedField<int>*
CNegotiationInitMsg::mutable_supported_audio_codecs() {
  // @@protoc_insertion_point(field_mutable_list:CNegotiationInitMsg.supported_audio_codecs)
  return &supported_audio_codecs_;
}

// repeated .EStreamVideoCodec supported_video_codecs = 3;
inline int CNegotiationInitMsg::supported_video_codecs_size() const {
  return supported_video_codecs_.size();
}
inline void CNegotiationInitMsg::clear_supported_video_codecs() {
  supported_video_codecs_.Clear();
}
inline ::EStreamVideoCodec CNegotiationInitMsg::supported_video_codecs(int index) const {
  // @@protoc_insertion_point(field_get:CNegotiationInitMsg.supported_video_codecs)
  return static_cast< ::EStreamVideoCodec >(supported_video_codecs_.Get(index));
}
inline void CNegotiationInitMsg::set_supported_video_codecs(int index, ::EStreamVideoCodec value) {
  assert(::EStreamVideoCodec_IsValid(value));
  supported_video_codecs_.Set(index, value);
  // @@protoc_insertion_point(field_set:CNegotiationInitMsg.supported_video_codecs)
}
inline void CNegotiationInitMsg::add_supported_video_codecs(::EStreamVideoCodec value) {
  assert(::EStreamVideoCodec_IsValid(value));
  supported_video_codecs_.Add(value);
  // @@protoc_insertion_point(field_add:CNegotiationInitMsg.supported_video_codecs)
}
inline const ::google::protobuf::RepeatedField<int>&
CNegotiationInitMsg::supported_video_codecs() const {
  // @@protoc_insertion_point(field_list:CNegotiationInitMsg.supported_video_codecs)
  return supported_video_codecs_;
}
inline ::google::protobuf::RepeatedField<int>*
CNegotiationInitMsg::mutable_supported_video_codecs() {
  // @@protoc_insertion_point(field_mutable_list:CNegotiationInitMsg.supported_video_codecs)
  return &supported_video_codecs_;
}

// optional bool supports_remote_hid = 4;
inline bool CNegotiationInitMsg::has_supports_remote_hid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CNegotiationInitMsg::set_has_supports_remote_hid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CNegotiationInitMsg::clear_has_supports_remote_hid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CNegotiationInitMsg::clear_supports_remote_hid() {
  supports_remote_hid_ = false;
  clear_has_supports_remote_hid();
}
inline bool CNegotiationInitMsg::supports_remote_hid() const {
  // @@protoc_insertion_point(field_get:CNegotiationInitMsg.supports_remote_hid)
  return supports_remote_hid_;
}
inline void CNegotiationInitMsg::set_supports_remote_hid(bool value) {
  set_has_supports_remote_hid();
  supports_remote_hid_ = value;
  // @@protoc_insertion_point(field_set:CNegotiationInitMsg.supports_remote_hid)
}

// -------------------------------------------------------------------

// CNegotiationSetConfigMsg

// required .CNegotiatedConfig config = 1;
inline bool CNegotiationSetConfigMsg::has_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CNegotiationSetConfigMsg::set_has_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CNegotiationSetConfigMsg::clear_has_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CNegotiationSetConfigMsg::clear_config() {
  if (config_ != NULL) config_->Clear();
  clear_has_config();
}
inline const ::CNegotiatedConfig& CNegotiationSetConfigMsg::_internal_config() const {
  return *config_;
}
inline const ::CNegotiatedConfig& CNegotiationSetConfigMsg::config() const {
  const ::CNegotiatedConfig* p = config_;
  // @@protoc_insertion_point(field_get:CNegotiationSetConfigMsg.config)
  return p != NULL ? *p : *reinterpret_cast<const ::CNegotiatedConfig*>(
      &::_CNegotiatedConfig_default_instance_);
}
inline ::CNegotiatedConfig* CNegotiationSetConfigMsg::release_config() {
  // @@protoc_insertion_point(field_release:CNegotiationSetConfigMsg.config)
  clear_has_config();
  ::CNegotiatedConfig* temp = config_;
  config_ = NULL;
  return temp;
}
inline ::CNegotiatedConfig* CNegotiationSetConfigMsg::mutable_config() {
  set_has_config();
  if (config_ == NULL) {
    auto* p = CreateMaybeMessage<::CNegotiatedConfig>(GetArenaNoVirtual());
    config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CNegotiationSetConfigMsg.config)
  return config_;
}
inline void CNegotiationSetConfigMsg::set_allocated_config(::CNegotiatedConfig* config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete config_;
  }
  if (config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    set_has_config();
  } else {
    clear_has_config();
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:CNegotiationSetConfigMsg.config)
}

// optional .CStreamingClientConfig streaming_client_config = 2;
inline bool CNegotiationSetConfigMsg::has_streaming_client_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CNegotiationSetConfigMsg::set_has_streaming_client_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CNegotiationSetConfigMsg::clear_has_streaming_client_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CNegotiationSetConfigMsg::clear_streaming_client_config() {
  if (streaming_client_config_ != NULL) streaming_client_config_->Clear();
  clear_has_streaming_client_config();
}
inline const ::CStreamingClientConfig& CNegotiationSetConfigMsg::_internal_streaming_client_config() const {
  return *streaming_client_config_;
}
inline const ::CStreamingClientConfig& CNegotiationSetConfigMsg::streaming_client_config() const {
  const ::CStreamingClientConfig* p = streaming_client_config_;
  // @@protoc_insertion_point(field_get:CNegotiationSetConfigMsg.streaming_client_config)
  return p != NULL ? *p : *reinterpret_cast<const ::CStreamingClientConfig*>(
      &::_CStreamingClientConfig_default_instance_);
}
inline ::CStreamingClientConfig* CNegotiationSetConfigMsg::release_streaming_client_config() {
  // @@protoc_insertion_point(field_release:CNegotiationSetConfigMsg.streaming_client_config)
  clear_has_streaming_client_config();
  ::CStreamingClientConfig* temp = streaming_client_config_;
  streaming_client_config_ = NULL;
  return temp;
}
inline ::CStreamingClientConfig* CNegotiationSetConfigMsg::mutable_streaming_client_config() {
  set_has_streaming_client_config();
  if (streaming_client_config_ == NULL) {
    auto* p = CreateMaybeMessage<::CStreamingClientConfig>(GetArenaNoVirtual());
    streaming_client_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CNegotiationSetConfigMsg.streaming_client_config)
  return streaming_client_config_;
}
inline void CNegotiationSetConfigMsg::set_allocated_streaming_client_config(::CStreamingClientConfig* streaming_client_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete streaming_client_config_;
  }
  if (streaming_client_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      streaming_client_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, streaming_client_config, submessage_arena);
    }
    set_has_streaming_client_config();
  } else {
    clear_has_streaming_client_config();
  }
  streaming_client_config_ = streaming_client_config;
  // @@protoc_insertion_point(field_set_allocated:CNegotiationSetConfigMsg.streaming_client_config)
}

// optional .CStreamingClientCaps streaming_client_caps = 3;
inline bool CNegotiationSetConfigMsg::has_streaming_client_caps() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CNegotiationSetConfigMsg::set_has_streaming_client_caps() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CNegotiationSetConfigMsg::clear_has_streaming_client_caps() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CNegotiationSetConfigMsg::clear_streaming_client_caps() {
  if (streaming_client_caps_ != NULL) streaming_client_caps_->Clear();
  clear_has_streaming_client_caps();
}
inline const ::CStreamingClientCaps& CNegotiationSetConfigMsg::_internal_streaming_client_caps() const {
  return *streaming_client_caps_;
}
inline const ::CStreamingClientCaps& CNegotiationSetConfigMsg::streaming_client_caps() const {
  const ::CStreamingClientCaps* p = streaming_client_caps_;
  // @@protoc_insertion_point(field_get:CNegotiationSetConfigMsg.streaming_client_caps)
  return p != NULL ? *p : *reinterpret_cast<const ::CStreamingClientCaps*>(
      &::_CStreamingClientCaps_default_instance_);
}
inline ::CStreamingClientCaps* CNegotiationSetConfigMsg::release_streaming_client_caps() {
  // @@protoc_insertion_point(field_release:CNegotiationSetConfigMsg.streaming_client_caps)
  clear_has_streaming_client_caps();
  ::CStreamingClientCaps* temp = streaming_client_caps_;
  streaming_client_caps_ = NULL;
  return temp;
}
inline ::CStreamingClientCaps* CNegotiationSetConfigMsg::mutable_streaming_client_caps() {
  set_has_streaming_client_caps();
  if (streaming_client_caps_ == NULL) {
    auto* p = CreateMaybeMessage<::CStreamingClientCaps>(GetArenaNoVirtual());
    streaming_client_caps_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CNegotiationSetConfigMsg.streaming_client_caps)
  return streaming_client_caps_;
}
inline void CNegotiationSetConfigMsg::set_allocated_streaming_client_caps(::CStreamingClientCaps* streaming_client_caps) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete streaming_client_caps_;
  }
  if (streaming_client_caps) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      streaming_client_caps = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, streaming_client_caps, submessage_arena);
    }
    set_has_streaming_client_caps();
  } else {
    clear_has_streaming_client_caps();
  }
  streaming_client_caps_ = streaming_client_caps;
  // @@protoc_insertion_point(field_set_allocated:CNegotiationSetConfigMsg.streaming_client_caps)
}

// -------------------------------------------------------------------

// CNegotiationCompleteMsg

// -------------------------------------------------------------------

// CStartAudioDataMsg

// required uint32 channel = 2;
inline bool CStartAudioDataMsg::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CStartAudioDataMsg::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CStartAudioDataMsg::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CStartAudioDataMsg::clear_channel() {
  channel_ = 0u;
  clear_has_channel();
}
inline ::google::protobuf::uint32 CStartAudioDataMsg::channel() const {
  // @@protoc_insertion_point(field_get:CStartAudioDataMsg.channel)
  return channel_;
}
inline void CStartAudioDataMsg::set_channel(::google::protobuf::uint32 value) {
  set_has_channel();
  channel_ = value;
  // @@protoc_insertion_point(field_set:CStartAudioDataMsg.channel)
}

// optional .EStreamAudioCodec codec = 3 [default = k_EStreamAudioCodecNone];
inline bool CStartAudioDataMsg::has_codec() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CStartAudioDataMsg::set_has_codec() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CStartAudioDataMsg::clear_has_codec() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CStartAudioDataMsg::clear_codec() {
  codec_ = 0;
  clear_has_codec();
}
inline ::EStreamAudioCodec CStartAudioDataMsg::codec() const {
  // @@protoc_insertion_point(field_get:CStartAudioDataMsg.codec)
  return static_cast< ::EStreamAudioCodec >(codec_);
}
inline void CStartAudioDataMsg::set_codec(::EStreamAudioCodec value) {
  assert(::EStreamAudioCodec_IsValid(value));
  set_has_codec();
  codec_ = value;
  // @@protoc_insertion_point(field_set:CStartAudioDataMsg.codec)
}

// optional bytes codec_data = 4;
inline bool CStartAudioDataMsg::has_codec_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CStartAudioDataMsg::set_has_codec_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CStartAudioDataMsg::clear_has_codec_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CStartAudioDataMsg::clear_codec_data() {
  codec_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_codec_data();
}
inline const ::std::string& CStartAudioDataMsg::codec_data() const {
  // @@protoc_insertion_point(field_get:CStartAudioDataMsg.codec_data)
  return codec_data_.GetNoArena();
}
inline void CStartAudioDataMsg::set_codec_data(const ::std::string& value) {
  set_has_codec_data();
  codec_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CStartAudioDataMsg.codec_data)
}
#if LANG_CXX11
inline void CStartAudioDataMsg::set_codec_data(::std::string&& value) {
  set_has_codec_data();
  codec_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CStartAudioDataMsg.codec_data)
}
#endif
inline void CStartAudioDataMsg::set_codec_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_codec_data();
  codec_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CStartAudioDataMsg.codec_data)
}
inline void CStartAudioDataMsg::set_codec_data(const void* value, size_t size) {
  set_has_codec_data();
  codec_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CStartAudioDataMsg.codec_data)
}
inline ::std::string* CStartAudioDataMsg::mutable_codec_data() {
  set_has_codec_data();
  // @@protoc_insertion_point(field_mutable:CStartAudioDataMsg.codec_data)
  return codec_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CStartAudioDataMsg::release_codec_data() {
  // @@protoc_insertion_point(field_release:CStartAudioDataMsg.codec_data)
  if (!has_codec_data()) {
    return NULL;
  }
  clear_has_codec_data();
  return codec_data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CStartAudioDataMsg::set_allocated_codec_data(::std::string* codec_data) {
  if (codec_data != NULL) {
    set_has_codec_data();
  } else {
    clear_has_codec_data();
  }
  codec_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), codec_data);
  // @@protoc_insertion_point(field_set_allocated:CStartAudioDataMsg.codec_data)
}

// optional uint32 frequency = 5;
inline bool CStartAudioDataMsg::has_frequency() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CStartAudioDataMsg::set_has_frequency() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CStartAudioDataMsg::clear_has_frequency() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CStartAudioDataMsg::clear_frequency() {
  frequency_ = 0u;
  clear_has_frequency();
}
inline ::google::protobuf::uint32 CStartAudioDataMsg::frequency() const {
  // @@protoc_insertion_point(field_get:CStartAudioDataMsg.frequency)
  return frequency_;
}
inline void CStartAudioDataMsg::set_frequency(::google::protobuf::uint32 value) {
  set_has_frequency();
  frequency_ = value;
  // @@protoc_insertion_point(field_set:CStartAudioDataMsg.frequency)
}

// optional uint32 channels = 6;
inline bool CStartAudioDataMsg::has_channels() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CStartAudioDataMsg::set_has_channels() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CStartAudioDataMsg::clear_has_channels() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CStartAudioDataMsg::clear_channels() {
  channels_ = 0u;
  clear_has_channels();
}
inline ::google::protobuf::uint32 CStartAudioDataMsg::channels() const {
  // @@protoc_insertion_point(field_get:CStartAudioDataMsg.channels)
  return channels_;
}
inline void CStartAudioDataMsg::set_channels(::google::protobuf::uint32 value) {
  set_has_channels();
  channels_ = value;
  // @@protoc_insertion_point(field_set:CStartAudioDataMsg.channels)
}

// -------------------------------------------------------------------

// CStopAudioDataMsg

// -------------------------------------------------------------------

// CStartVideoDataMsg

// required uint32 channel = 1;
inline bool CStartVideoDataMsg::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CStartVideoDataMsg::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CStartVideoDataMsg::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CStartVideoDataMsg::clear_channel() {
  channel_ = 0u;
  clear_has_channel();
}
inline ::google::protobuf::uint32 CStartVideoDataMsg::channel() const {
  // @@protoc_insertion_point(field_get:CStartVideoDataMsg.channel)
  return channel_;
}
inline void CStartVideoDataMsg::set_channel(::google::protobuf::uint32 value) {
  set_has_channel();
  channel_ = value;
  // @@protoc_insertion_point(field_set:CStartVideoDataMsg.channel)
}

// optional .EStreamVideoCodec codec = 2 [default = k_EStreamVideoCodecNone];
inline bool CStartVideoDataMsg::has_codec() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CStartVideoDataMsg::set_has_codec() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CStartVideoDataMsg::clear_has_codec() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CStartVideoDataMsg::clear_codec() {
  codec_ = 0;
  clear_has_codec();
}
inline ::EStreamVideoCodec CStartVideoDataMsg::codec() const {
  // @@protoc_insertion_point(field_get:CStartVideoDataMsg.codec)
  return static_cast< ::EStreamVideoCodec >(codec_);
}
inline void CStartVideoDataMsg::set_codec(::EStreamVideoCodec value) {
  assert(::EStreamVideoCodec_IsValid(value));
  set_has_codec();
  codec_ = value;
  // @@protoc_insertion_point(field_set:CStartVideoDataMsg.codec)
}

// optional bytes codec_data = 3;
inline bool CStartVideoDataMsg::has_codec_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CStartVideoDataMsg::set_has_codec_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CStartVideoDataMsg::clear_has_codec_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CStartVideoDataMsg::clear_codec_data() {
  codec_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_codec_data();
}
inline const ::std::string& CStartVideoDataMsg::codec_data() const {
  // @@protoc_insertion_point(field_get:CStartVideoDataMsg.codec_data)
  return codec_data_.GetNoArena();
}
inline void CStartVideoDataMsg::set_codec_data(const ::std::string& value) {
  set_has_codec_data();
  codec_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CStartVideoDataMsg.codec_data)
}
#if LANG_CXX11
inline void CStartVideoDataMsg::set_codec_data(::std::string&& value) {
  set_has_codec_data();
  codec_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CStartVideoDataMsg.codec_data)
}
#endif
inline void CStartVideoDataMsg::set_codec_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_codec_data();
  codec_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CStartVideoDataMsg.codec_data)
}
inline void CStartVideoDataMsg::set_codec_data(const void* value, size_t size) {
  set_has_codec_data();
  codec_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CStartVideoDataMsg.codec_data)
}
inline ::std::string* CStartVideoDataMsg::mutable_codec_data() {
  set_has_codec_data();
  // @@protoc_insertion_point(field_mutable:CStartVideoDataMsg.codec_data)
  return codec_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CStartVideoDataMsg::release_codec_data() {
  // @@protoc_insertion_point(field_release:CStartVideoDataMsg.codec_data)
  if (!has_codec_data()) {
    return NULL;
  }
  clear_has_codec_data();
  return codec_data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CStartVideoDataMsg::set_allocated_codec_data(::std::string* codec_data) {
  if (codec_data != NULL) {
    set_has_codec_data();
  } else {
    clear_has_codec_data();
  }
  codec_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), codec_data);
  // @@protoc_insertion_point(field_set_allocated:CStartVideoDataMsg.codec_data)
}

// optional uint32 width = 4;
inline bool CStartVideoDataMsg::has_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CStartVideoDataMsg::set_has_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CStartVideoDataMsg::clear_has_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CStartVideoDataMsg::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 CStartVideoDataMsg::width() const {
  // @@protoc_insertion_point(field_get:CStartVideoDataMsg.width)
  return width_;
}
inline void CStartVideoDataMsg::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:CStartVideoDataMsg.width)
}

// optional uint32 height = 5;
inline bool CStartVideoDataMsg::has_height() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CStartVideoDataMsg::set_has_height() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CStartVideoDataMsg::clear_has_height() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CStartVideoDataMsg::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 CStartVideoDataMsg::height() const {
  // @@protoc_insertion_point(field_get:CStartVideoDataMsg.height)
  return height_;
}
inline void CStartVideoDataMsg::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:CStartVideoDataMsg.height)
}

// -------------------------------------------------------------------

// CStopVideoDataMsg

// -------------------------------------------------------------------

// CInputLatencyTestMsg

// required uint32 input_mark = 1;
inline bool CInputLatencyTestMsg::has_input_mark() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CInputLatencyTestMsg::set_has_input_mark() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CInputLatencyTestMsg::clear_has_input_mark() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CInputLatencyTestMsg::clear_input_mark() {
  input_mark_ = 0u;
  clear_has_input_mark();
}
inline ::google::protobuf::uint32 CInputLatencyTestMsg::input_mark() const {
  // @@protoc_insertion_point(field_get:CInputLatencyTestMsg.input_mark)
  return input_mark_;
}
inline void CInputLatencyTestMsg::set_input_mark(::google::protobuf::uint32 value) {
  set_has_input_mark();
  input_mark_ = value;
  // @@protoc_insertion_point(field_set:CInputLatencyTestMsg.input_mark)
}

// optional uint32 color = 2;
inline bool CInputLatencyTestMsg::has_color() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CInputLatencyTestMsg::set_has_color() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CInputLatencyTestMsg::clear_has_color() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CInputLatencyTestMsg::clear_color() {
  color_ = 0u;
  clear_has_color();
}
inline ::google::protobuf::uint32 CInputLatencyTestMsg::color() const {
  // @@protoc_insertion_point(field_get:CInputLatencyTestMsg.color)
  return color_;
}
inline void CInputLatencyTestMsg::set_color(::google::protobuf::uint32 value) {
  set_has_color();
  color_ = value;
  // @@protoc_insertion_point(field_set:CInputLatencyTestMsg.color)
}

// -------------------------------------------------------------------

// CInputMouseMotionMsg

// optional uint32 input_mark = 1;
inline bool CInputMouseMotionMsg::has_input_mark() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CInputMouseMotionMsg::set_has_input_mark() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CInputMouseMotionMsg::clear_has_input_mark() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CInputMouseMotionMsg::clear_input_mark() {
  input_mark_ = 0u;
  clear_has_input_mark();
}
inline ::google::protobuf::uint32 CInputMouseMotionMsg::input_mark() const {
  // @@protoc_insertion_point(field_get:CInputMouseMotionMsg.input_mark)
  return input_mark_;
}
inline void CInputMouseMotionMsg::set_input_mark(::google::protobuf::uint32 value) {
  set_has_input_mark();
  input_mark_ = value;
  // @@protoc_insertion_point(field_set:CInputMouseMotionMsg.input_mark)
}

// optional float x_normalized = 2;
inline bool CInputMouseMotionMsg::has_x_normalized() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CInputMouseMotionMsg::set_has_x_normalized() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CInputMouseMotionMsg::clear_has_x_normalized() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CInputMouseMotionMsg::clear_x_normalized() {
  x_normalized_ = 0;
  clear_has_x_normalized();
}
inline float CInputMouseMotionMsg::x_normalized() const {
  // @@protoc_insertion_point(field_get:CInputMouseMotionMsg.x_normalized)
  return x_normalized_;
}
inline void CInputMouseMotionMsg::set_x_normalized(float value) {
  set_has_x_normalized();
  x_normalized_ = value;
  // @@protoc_insertion_point(field_set:CInputMouseMotionMsg.x_normalized)
}

// optional float y_normalized = 3;
inline bool CInputMouseMotionMsg::has_y_normalized() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CInputMouseMotionMsg::set_has_y_normalized() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CInputMouseMotionMsg::clear_has_y_normalized() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CInputMouseMotionMsg::clear_y_normalized() {
  y_normalized_ = 0;
  clear_has_y_normalized();
}
inline float CInputMouseMotionMsg::y_normalized() const {
  // @@protoc_insertion_point(field_get:CInputMouseMotionMsg.y_normalized)
  return y_normalized_;
}
inline void CInputMouseMotionMsg::set_y_normalized(float value) {
  set_has_y_normalized();
  y_normalized_ = value;
  // @@protoc_insertion_point(field_set:CInputMouseMotionMsg.y_normalized)
}

// optional int32 dx = 4;
inline bool CInputMouseMotionMsg::has_dx() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CInputMouseMotionMsg::set_has_dx() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CInputMouseMotionMsg::clear_has_dx() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CInputMouseMotionMsg::clear_dx() {
  dx_ = 0;
  clear_has_dx();
}
inline ::google::protobuf::int32 CInputMouseMotionMsg::dx() const {
  // @@protoc_insertion_point(field_get:CInputMouseMotionMsg.dx)
  return dx_;
}
inline void CInputMouseMotionMsg::set_dx(::google::protobuf::int32 value) {
  set_has_dx();
  dx_ = value;
  // @@protoc_insertion_point(field_set:CInputMouseMotionMsg.dx)
}

// optional int32 dy = 5;
inline bool CInputMouseMotionMsg::has_dy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CInputMouseMotionMsg::set_has_dy() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CInputMouseMotionMsg::clear_has_dy() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CInputMouseMotionMsg::clear_dy() {
  dy_ = 0;
  clear_has_dy();
}
inline ::google::protobuf::int32 CInputMouseMotionMsg::dy() const {
  // @@protoc_insertion_point(field_get:CInputMouseMotionMsg.dy)
  return dy_;
}
inline void CInputMouseMotionMsg::set_dy(::google::protobuf::int32 value) {
  set_has_dy();
  dy_ = value;
  // @@protoc_insertion_point(field_set:CInputMouseMotionMsg.dy)
}

// -------------------------------------------------------------------

// CInputMouseWheelMsg

// optional uint32 input_mark = 1;
inline bool CInputMouseWheelMsg::has_input_mark() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CInputMouseWheelMsg::set_has_input_mark() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CInputMouseWheelMsg::clear_has_input_mark() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CInputMouseWheelMsg::clear_input_mark() {
  input_mark_ = 0u;
  clear_has_input_mark();
}
inline ::google::protobuf::uint32 CInputMouseWheelMsg::input_mark() const {
  // @@protoc_insertion_point(field_get:CInputMouseWheelMsg.input_mark)
  return input_mark_;
}
inline void CInputMouseWheelMsg::set_input_mark(::google::protobuf::uint32 value) {
  set_has_input_mark();
  input_mark_ = value;
  // @@protoc_insertion_point(field_set:CInputMouseWheelMsg.input_mark)
}

// required .EStreamMouseWheelDirection direction = 2 [default = k_EStreamMouseWheelUp];
inline bool CInputMouseWheelMsg::has_direction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CInputMouseWheelMsg::set_has_direction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CInputMouseWheelMsg::clear_has_direction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CInputMouseWheelMsg::clear_direction() {
  direction_ = 120;
  clear_has_direction();
}
inline ::EStreamMouseWheelDirection CInputMouseWheelMsg::direction() const {
  // @@protoc_insertion_point(field_get:CInputMouseWheelMsg.direction)
  return static_cast< ::EStreamMouseWheelDirection >(direction_);
}
inline void CInputMouseWheelMsg::set_direction(::EStreamMouseWheelDirection value) {
  assert(::EStreamMouseWheelDirection_IsValid(value));
  set_has_direction();
  direction_ = value;
  // @@protoc_insertion_point(field_set:CInputMouseWheelMsg.direction)
}

// -------------------------------------------------------------------

// CInputMouseDownMsg

// optional uint32 input_mark = 1;
inline bool CInputMouseDownMsg::has_input_mark() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CInputMouseDownMsg::set_has_input_mark() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CInputMouseDownMsg::clear_has_input_mark() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CInputMouseDownMsg::clear_input_mark() {
  input_mark_ = 0u;
  clear_has_input_mark();
}
inline ::google::protobuf::uint32 CInputMouseDownMsg::input_mark() const {
  // @@protoc_insertion_point(field_get:CInputMouseDownMsg.input_mark)
  return input_mark_;
}
inline void CInputMouseDownMsg::set_input_mark(::google::protobuf::uint32 value) {
  set_has_input_mark();
  input_mark_ = value;
  // @@protoc_insertion_point(field_set:CInputMouseDownMsg.input_mark)
}

// required .EStreamMouseButton button = 2 [default = k_EStreamMouseButtonLeft];
inline bool CInputMouseDownMsg::has_button() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CInputMouseDownMsg::set_has_button() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CInputMouseDownMsg::clear_has_button() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CInputMouseDownMsg::clear_button() {
  button_ = 1;
  clear_has_button();
}
inline ::EStreamMouseButton CInputMouseDownMsg::button() const {
  // @@protoc_insertion_point(field_get:CInputMouseDownMsg.button)
  return static_cast< ::EStreamMouseButton >(button_);
}
inline void CInputMouseDownMsg::set_button(::EStreamMouseButton value) {
  assert(::EStreamMouseButton_IsValid(value));
  set_has_button();
  button_ = value;
  // @@protoc_insertion_point(field_set:CInputMouseDownMsg.button)
}

// -------------------------------------------------------------------

// CInputMouseUpMsg

// optional uint32 input_mark = 1;
inline bool CInputMouseUpMsg::has_input_mark() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CInputMouseUpMsg::set_has_input_mark() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CInputMouseUpMsg::clear_has_input_mark() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CInputMouseUpMsg::clear_input_mark() {
  input_mark_ = 0u;
  clear_has_input_mark();
}
inline ::google::protobuf::uint32 CInputMouseUpMsg::input_mark() const {
  // @@protoc_insertion_point(field_get:CInputMouseUpMsg.input_mark)
  return input_mark_;
}
inline void CInputMouseUpMsg::set_input_mark(::google::protobuf::uint32 value) {
  set_has_input_mark();
  input_mark_ = value;
  // @@protoc_insertion_point(field_set:CInputMouseUpMsg.input_mark)
}

// required .EStreamMouseButton button = 2 [default = k_EStreamMouseButtonLeft];
inline bool CInputMouseUpMsg::has_button() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CInputMouseUpMsg::set_has_button() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CInputMouseUpMsg::clear_has_button() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CInputMouseUpMsg::clear_button() {
  button_ = 1;
  clear_has_button();
}
inline ::EStreamMouseButton CInputMouseUpMsg::button() const {
  // @@protoc_insertion_point(field_get:CInputMouseUpMsg.button)
  return static_cast< ::EStreamMouseButton >(button_);
}
inline void CInputMouseUpMsg::set_button(::EStreamMouseButton value) {
  assert(::EStreamMouseButton_IsValid(value));
  set_has_button();
  button_ = value;
  // @@protoc_insertion_point(field_set:CInputMouseUpMsg.button)
}

// -------------------------------------------------------------------

// CInputKeyDownMsg

// optional uint32 input_mark = 1;
inline bool CInputKeyDownMsg::has_input_mark() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CInputKeyDownMsg::set_has_input_mark() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CInputKeyDownMsg::clear_has_input_mark() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CInputKeyDownMsg::clear_input_mark() {
  input_mark_ = 0u;
  clear_has_input_mark();
}
inline ::google::protobuf::uint32 CInputKeyDownMsg::input_mark() const {
  // @@protoc_insertion_point(field_get:CInputKeyDownMsg.input_mark)
  return input_mark_;
}
inline void CInputKeyDownMsg::set_input_mark(::google::protobuf::uint32 value) {
  set_has_input_mark();
  input_mark_ = value;
  // @@protoc_insertion_point(field_set:CInputKeyDownMsg.input_mark)
}

// required uint32 scancode = 2;
inline bool CInputKeyDownMsg::has_scancode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CInputKeyDownMsg::set_has_scancode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CInputKeyDownMsg::clear_has_scancode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CInputKeyDownMsg::clear_scancode() {
  scancode_ = 0u;
  clear_has_scancode();
}
inline ::google::protobuf::uint32 CInputKeyDownMsg::scancode() const {
  // @@protoc_insertion_point(field_get:CInputKeyDownMsg.scancode)
  return scancode_;
}
inline void CInputKeyDownMsg::set_scancode(::google::protobuf::uint32 value) {
  set_has_scancode();
  scancode_ = value;
  // @@protoc_insertion_point(field_set:CInputKeyDownMsg.scancode)
}

// -------------------------------------------------------------------

// CInputKeyUpMsg

// optional uint32 input_mark = 1;
inline bool CInputKeyUpMsg::has_input_mark() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CInputKeyUpMsg::set_has_input_mark() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CInputKeyUpMsg::clear_has_input_mark() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CInputKeyUpMsg::clear_input_mark() {
  input_mark_ = 0u;
  clear_has_input_mark();
}
inline ::google::protobuf::uint32 CInputKeyUpMsg::input_mark() const {
  // @@protoc_insertion_point(field_get:CInputKeyUpMsg.input_mark)
  return input_mark_;
}
inline void CInputKeyUpMsg::set_input_mark(::google::protobuf::uint32 value) {
  set_has_input_mark();
  input_mark_ = value;
  // @@protoc_insertion_point(field_set:CInputKeyUpMsg.input_mark)
}

// required uint32 scancode = 2;
inline bool CInputKeyUpMsg::has_scancode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CInputKeyUpMsg::set_has_scancode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CInputKeyUpMsg::clear_has_scancode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CInputKeyUpMsg::clear_scancode() {
  scancode_ = 0u;
  clear_has_scancode();
}
inline ::google::protobuf::uint32 CInputKeyUpMsg::scancode() const {
  // @@protoc_insertion_point(field_get:CInputKeyUpMsg.scancode)
  return scancode_;
}
inline void CInputKeyUpMsg::set_scancode(::google::protobuf::uint32 value) {
  set_has_scancode();
  scancode_ = value;
  // @@protoc_insertion_point(field_set:CInputKeyUpMsg.scancode)
}

// -------------------------------------------------------------------

// CInputTextMsg

// optional uint32 input_mark = 1;
inline bool CInputTextMsg::has_input_mark() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CInputTextMsg::set_has_input_mark() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CInputTextMsg::clear_has_input_mark() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CInputTextMsg::clear_input_mark() {
  input_mark_ = 0u;
  clear_has_input_mark();
}
inline ::google::protobuf::uint32 CInputTextMsg::input_mark() const {
  // @@protoc_insertion_point(field_get:CInputTextMsg.input_mark)
  return input_mark_;
}
inline void CInputTextMsg::set_input_mark(::google::protobuf::uint32 value) {
  set_has_input_mark();
  input_mark_ = value;
  // @@protoc_insertion_point(field_set:CInputTextMsg.input_mark)
}

// required string text_utf8 = 2;
inline bool CInputTextMsg::has_text_utf8() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CInputTextMsg::set_has_text_utf8() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CInputTextMsg::clear_has_text_utf8() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CInputTextMsg::clear_text_utf8() {
  text_utf8_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text_utf8();
}
inline const ::std::string& CInputTextMsg::text_utf8() const {
  // @@protoc_insertion_point(field_get:CInputTextMsg.text_utf8)
  return text_utf8_.GetNoArena();
}
inline void CInputTextMsg::set_text_utf8(const ::std::string& value) {
  set_has_text_utf8();
  text_utf8_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CInputTextMsg.text_utf8)
}
#if LANG_CXX11
inline void CInputTextMsg::set_text_utf8(::std::string&& value) {
  set_has_text_utf8();
  text_utf8_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CInputTextMsg.text_utf8)
}
#endif
inline void CInputTextMsg::set_text_utf8(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text_utf8();
  text_utf8_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CInputTextMsg.text_utf8)
}
inline void CInputTextMsg::set_text_utf8(const char* value, size_t size) {
  set_has_text_utf8();
  text_utf8_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CInputTextMsg.text_utf8)
}
inline ::std::string* CInputTextMsg::mutable_text_utf8() {
  set_has_text_utf8();
  // @@protoc_insertion_point(field_mutable:CInputTextMsg.text_utf8)
  return text_utf8_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CInputTextMsg::release_text_utf8() {
  // @@protoc_insertion_point(field_release:CInputTextMsg.text_utf8)
  if (!has_text_utf8()) {
    return NULL;
  }
  clear_has_text_utf8();
  return text_utf8_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CInputTextMsg::set_allocated_text_utf8(::std::string* text_utf8) {
  if (text_utf8 != NULL) {
    set_has_text_utf8();
  } else {
    clear_has_text_utf8();
  }
  text_utf8_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text_utf8);
  // @@protoc_insertion_point(field_set_allocated:CInputTextMsg.text_utf8)
}

// -------------------------------------------------------------------

// CSetTitleMsg

// optional string text = 1;
inline bool CSetTitleMsg::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSetTitleMsg::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSetTitleMsg::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSetTitleMsg::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& CSetTitleMsg::text() const {
  // @@protoc_insertion_point(field_get:CSetTitleMsg.text)
  return text_.GetNoArena();
}
inline void CSetTitleMsg::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CSetTitleMsg.text)
}
#if LANG_CXX11
inline void CSetTitleMsg::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CSetTitleMsg.text)
}
#endif
inline void CSetTitleMsg::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CSetTitleMsg.text)
}
inline void CSetTitleMsg::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CSetTitleMsg.text)
}
inline ::std::string* CSetTitleMsg::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:CSetTitleMsg.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CSetTitleMsg::release_text() {
  // @@protoc_insertion_point(field_release:CSetTitleMsg.text)
  if (!has_text()) {
    return NULL;
  }
  clear_has_text();
  return text_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CSetTitleMsg::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:CSetTitleMsg.text)
}

// -------------------------------------------------------------------

// CSetIconMsg

// optional int32 width = 1;
inline bool CSetIconMsg::has_width() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSetIconMsg::set_has_width() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSetIconMsg::clear_has_width() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSetIconMsg::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 CSetIconMsg::width() const {
  // @@protoc_insertion_point(field_get:CSetIconMsg.width)
  return width_;
}
inline void CSetIconMsg::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:CSetIconMsg.width)
}

// optional int32 height = 2;
inline bool CSetIconMsg::has_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSetIconMsg::set_has_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSetIconMsg::clear_has_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSetIconMsg::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 CSetIconMsg::height() const {
  // @@protoc_insertion_point(field_get:CSetIconMsg.height)
  return height_;
}
inline void CSetIconMsg::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:CSetIconMsg.height)
}

// optional bytes image = 3;
inline bool CSetIconMsg::has_image() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSetIconMsg::set_has_image() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSetIconMsg::clear_has_image() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSetIconMsg::clear_image() {
  image_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_image();
}
inline const ::std::string& CSetIconMsg::image() const {
  // @@protoc_insertion_point(field_get:CSetIconMsg.image)
  return image_.GetNoArena();
}
inline void CSetIconMsg::set_image(const ::std::string& value) {
  set_has_image();
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CSetIconMsg.image)
}
#if LANG_CXX11
inline void CSetIconMsg::set_image(::std::string&& value) {
  set_has_image();
  image_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CSetIconMsg.image)
}
#endif
inline void CSetIconMsg::set_image(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_image();
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CSetIconMsg.image)
}
inline void CSetIconMsg::set_image(const void* value, size_t size) {
  set_has_image();
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CSetIconMsg.image)
}
inline ::std::string* CSetIconMsg::mutable_image() {
  set_has_image();
  // @@protoc_insertion_point(field_mutable:CSetIconMsg.image)
  return image_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CSetIconMsg::release_image() {
  // @@protoc_insertion_point(field_release:CSetIconMsg.image)
  if (!has_image()) {
    return NULL;
  }
  clear_has_image();
  return image_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CSetIconMsg::set_allocated_image(::std::string* image) {
  if (image != NULL) {
    set_has_image();
  } else {
    clear_has_image();
  }
  image_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), image);
  // @@protoc_insertion_point(field_set_allocated:CSetIconMsg.image)
}

// -------------------------------------------------------------------

// CShowCursorMsg

// optional float x_normalized = 1;
inline bool CShowCursorMsg::has_x_normalized() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CShowCursorMsg::set_has_x_normalized() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CShowCursorMsg::clear_has_x_normalized() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CShowCursorMsg::clear_x_normalized() {
  x_normalized_ = 0;
  clear_has_x_normalized();
}
inline float CShowCursorMsg::x_normalized() const {
  // @@protoc_insertion_point(field_get:CShowCursorMsg.x_normalized)
  return x_normalized_;
}
inline void CShowCursorMsg::set_x_normalized(float value) {
  set_has_x_normalized();
  x_normalized_ = value;
  // @@protoc_insertion_point(field_set:CShowCursorMsg.x_normalized)
}

// optional float y_normalized = 2;
inline bool CShowCursorMsg::has_y_normalized() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CShowCursorMsg::set_has_y_normalized() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CShowCursorMsg::clear_has_y_normalized() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CShowCursorMsg::clear_y_normalized() {
  y_normalized_ = 0;
  clear_has_y_normalized();
}
inline float CShowCursorMsg::y_normalized() const {
  // @@protoc_insertion_point(field_get:CShowCursorMsg.y_normalized)
  return y_normalized_;
}
inline void CShowCursorMsg::set_y_normalized(float value) {
  set_has_y_normalized();
  y_normalized_ = value;
  // @@protoc_insertion_point(field_set:CShowCursorMsg.y_normalized)
}

// -------------------------------------------------------------------

// CHideCursorMsg

// -------------------------------------------------------------------

// CSetCursorMsg

// required uint64 cursor_id = 1;
inline bool CSetCursorMsg::has_cursor_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSetCursorMsg::set_has_cursor_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSetCursorMsg::clear_has_cursor_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSetCursorMsg::clear_cursor_id() {
  cursor_id_ = GOOGLE_ULONGLONG(0);
  clear_has_cursor_id();
}
inline ::google::protobuf::uint64 CSetCursorMsg::cursor_id() const {
  // @@protoc_insertion_point(field_get:CSetCursorMsg.cursor_id)
  return cursor_id_;
}
inline void CSetCursorMsg::set_cursor_id(::google::protobuf::uint64 value) {
  set_has_cursor_id();
  cursor_id_ = value;
  // @@protoc_insertion_point(field_set:CSetCursorMsg.cursor_id)
}

// -------------------------------------------------------------------

// CGetCursorImageMsg

// required uint64 cursor_id = 1;
inline bool CGetCursorImageMsg::has_cursor_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGetCursorImageMsg::set_has_cursor_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGetCursorImageMsg::clear_has_cursor_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGetCursorImageMsg::clear_cursor_id() {
  cursor_id_ = GOOGLE_ULONGLONG(0);
  clear_has_cursor_id();
}
inline ::google::protobuf::uint64 CGetCursorImageMsg::cursor_id() const {
  // @@protoc_insertion_point(field_get:CGetCursorImageMsg.cursor_id)
  return cursor_id_;
}
inline void CGetCursorImageMsg::set_cursor_id(::google::protobuf::uint64 value) {
  set_has_cursor_id();
  cursor_id_ = value;
  // @@protoc_insertion_point(field_set:CGetCursorImageMsg.cursor_id)
}

// -------------------------------------------------------------------

// CSetCursorImageMsg

// required uint64 cursor_id = 1;
inline bool CSetCursorImageMsg::has_cursor_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSetCursorImageMsg::set_has_cursor_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSetCursorImageMsg::clear_has_cursor_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSetCursorImageMsg::clear_cursor_id() {
  cursor_id_ = GOOGLE_ULONGLONG(0);
  clear_has_cursor_id();
}
inline ::google::protobuf::uint64 CSetCursorImageMsg::cursor_id() const {
  // @@protoc_insertion_point(field_get:CSetCursorImageMsg.cursor_id)
  return cursor_id_;
}
inline void CSetCursorImageMsg::set_cursor_id(::google::protobuf::uint64 value) {
  set_has_cursor_id();
  cursor_id_ = value;
  // @@protoc_insertion_point(field_set:CSetCursorImageMsg.cursor_id)
}

// optional int32 width = 2;
inline bool CSetCursorImageMsg::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSetCursorImageMsg::set_has_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSetCursorImageMsg::clear_has_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSetCursorImageMsg::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 CSetCursorImageMsg::width() const {
  // @@protoc_insertion_point(field_get:CSetCursorImageMsg.width)
  return width_;
}
inline void CSetCursorImageMsg::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:CSetCursorImageMsg.width)
}

// optional int32 height = 3;
inline bool CSetCursorImageMsg::has_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSetCursorImageMsg::set_has_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSetCursorImageMsg::clear_has_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSetCursorImageMsg::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 CSetCursorImageMsg::height() const {
  // @@protoc_insertion_point(field_get:CSetCursorImageMsg.height)
  return height_;
}
inline void CSetCursorImageMsg::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:CSetCursorImageMsg.height)
}

// optional int32 hot_x = 4;
inline bool CSetCursorImageMsg::has_hot_x() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSetCursorImageMsg::set_has_hot_x() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSetCursorImageMsg::clear_has_hot_x() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSetCursorImageMsg::clear_hot_x() {
  hot_x_ = 0;
  clear_has_hot_x();
}
inline ::google::protobuf::int32 CSetCursorImageMsg::hot_x() const {
  // @@protoc_insertion_point(field_get:CSetCursorImageMsg.hot_x)
  return hot_x_;
}
inline void CSetCursorImageMsg::set_hot_x(::google::protobuf::int32 value) {
  set_has_hot_x();
  hot_x_ = value;
  // @@protoc_insertion_point(field_set:CSetCursorImageMsg.hot_x)
}

// optional int32 hot_y = 5;
inline bool CSetCursorImageMsg::has_hot_y() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSetCursorImageMsg::set_has_hot_y() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSetCursorImageMsg::clear_has_hot_y() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSetCursorImageMsg::clear_hot_y() {
  hot_y_ = 0;
  clear_has_hot_y();
}
inline ::google::protobuf::int32 CSetCursorImageMsg::hot_y() const {
  // @@protoc_insertion_point(field_get:CSetCursorImageMsg.hot_y)
  return hot_y_;
}
inline void CSetCursorImageMsg::set_hot_y(::google::protobuf::int32 value) {
  set_has_hot_y();
  hot_y_ = value;
  // @@protoc_insertion_point(field_set:CSetCursorImageMsg.hot_y)
}

// optional bytes image = 6;
inline bool CSetCursorImageMsg::has_image() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSetCursorImageMsg::set_has_image() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSetCursorImageMsg::clear_has_image() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSetCursorImageMsg::clear_image() {
  image_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_image();
}
inline const ::std::string& CSetCursorImageMsg::image() const {
  // @@protoc_insertion_point(field_get:CSetCursorImageMsg.image)
  return image_.GetNoArena();
}
inline void CSetCursorImageMsg::set_image(const ::std::string& value) {
  set_has_image();
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CSetCursorImageMsg.image)
}
#if LANG_CXX11
inline void CSetCursorImageMsg::set_image(::std::string&& value) {
  set_has_image();
  image_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CSetCursorImageMsg.image)
}
#endif
inline void CSetCursorImageMsg::set_image(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_image();
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CSetCursorImageMsg.image)
}
inline void CSetCursorImageMsg::set_image(const void* value, size_t size) {
  set_has_image();
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CSetCursorImageMsg.image)
}
inline ::std::string* CSetCursorImageMsg::mutable_image() {
  set_has_image();
  // @@protoc_insertion_point(field_mutable:CSetCursorImageMsg.image)
  return image_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CSetCursorImageMsg::release_image() {
  // @@protoc_insertion_point(field_release:CSetCursorImageMsg.image)
  if (!has_image()) {
    return NULL;
  }
  clear_has_image();
  return image_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CSetCursorImageMsg::set_allocated_image(::std::string* image) {
  if (image != NULL) {
    set_has_image();
  } else {
    clear_has_image();
  }
  image_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), image);
  // @@protoc_insertion_point(field_set_allocated:CSetCursorImageMsg.image)
}

// -------------------------------------------------------------------

// CVideoDecoderInfoMsg

// optional string info = 1;
inline bool CVideoDecoderInfoMsg::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CVideoDecoderInfoMsg::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CVideoDecoderInfoMsg::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CVideoDecoderInfoMsg::clear_info() {
  info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_info();
}
inline const ::std::string& CVideoDecoderInfoMsg::info() const {
  // @@protoc_insertion_point(field_get:CVideoDecoderInfoMsg.info)
  return info_.GetNoArena();
}
inline void CVideoDecoderInfoMsg::set_info(const ::std::string& value) {
  set_has_info();
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CVideoDecoderInfoMsg.info)
}
#if LANG_CXX11
inline void CVideoDecoderInfoMsg::set_info(::std::string&& value) {
  set_has_info();
  info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CVideoDecoderInfoMsg.info)
}
#endif
inline void CVideoDecoderInfoMsg::set_info(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_info();
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CVideoDecoderInfoMsg.info)
}
inline void CVideoDecoderInfoMsg::set_info(const char* value, size_t size) {
  set_has_info();
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CVideoDecoderInfoMsg.info)
}
inline ::std::string* CVideoDecoderInfoMsg::mutable_info() {
  set_has_info();
  // @@protoc_insertion_point(field_mutable:CVideoDecoderInfoMsg.info)
  return info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CVideoDecoderInfoMsg::release_info() {
  // @@protoc_insertion_point(field_release:CVideoDecoderInfoMsg.info)
  if (!has_info()) {
    return NULL;
  }
  clear_has_info();
  return info_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CVideoDecoderInfoMsg::set_allocated_info(::std::string* info) {
  if (info != NULL) {
    set_has_info();
  } else {
    clear_has_info();
  }
  info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), info);
  // @@protoc_insertion_point(field_set_allocated:CVideoDecoderInfoMsg.info)
}

// optional int32 threads = 2;
inline bool CVideoDecoderInfoMsg::has_threads() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CVideoDecoderInfoMsg::set_has_threads() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CVideoDecoderInfoMsg::clear_has_threads() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CVideoDecoderInfoMsg::clear_threads() {
  threads_ = 0;
  clear_has_threads();
}
inline ::google::protobuf::int32 CVideoDecoderInfoMsg::threads() const {
  // @@protoc_insertion_point(field_get:CVideoDecoderInfoMsg.threads)
  return threads_;
}
inline void CVideoDecoderInfoMsg::set_threads(::google::protobuf::int32 value) {
  set_has_threads();
  threads_ = value;
  // @@protoc_insertion_point(field_set:CVideoDecoderInfoMsg.threads)
}

// -------------------------------------------------------------------

// CVideoEncoderInfoMsg

// optional string info = 1;
inline bool CVideoEncoderInfoMsg::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CVideoEncoderInfoMsg::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CVideoEncoderInfoMsg::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CVideoEncoderInfoMsg::clear_info() {
  info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_info();
}
inline const ::std::string& CVideoEncoderInfoMsg::info() const {
  // @@protoc_insertion_point(field_get:CVideoEncoderInfoMsg.info)
  return info_.GetNoArena();
}
inline void CVideoEncoderInfoMsg::set_info(const ::std::string& value) {
  set_has_info();
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CVideoEncoderInfoMsg.info)
}
#if LANG_CXX11
inline void CVideoEncoderInfoMsg::set_info(::std::string&& value) {
  set_has_info();
  info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CVideoEncoderInfoMsg.info)
}
#endif
inline void CVideoEncoderInfoMsg::set_info(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_info();
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CVideoEncoderInfoMsg.info)
}
inline void CVideoEncoderInfoMsg::set_info(const char* value, size_t size) {
  set_has_info();
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CVideoEncoderInfoMsg.info)
}
inline ::std::string* CVideoEncoderInfoMsg::mutable_info() {
  set_has_info();
  // @@protoc_insertion_point(field_mutable:CVideoEncoderInfoMsg.info)
  return info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CVideoEncoderInfoMsg::release_info() {
  // @@protoc_insertion_point(field_release:CVideoEncoderInfoMsg.info)
  if (!has_info()) {
    return NULL;
  }
  clear_has_info();
  return info_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CVideoEncoderInfoMsg::set_allocated_info(::std::string* info) {
  if (info != NULL) {
    set_has_info();
  } else {
    clear_has_info();
  }
  info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), info);
  // @@protoc_insertion_point(field_set_allocated:CVideoEncoderInfoMsg.info)
}

// -------------------------------------------------------------------

// CQuitRequest

// -------------------------------------------------------------------

// CDeleteCursorMsg

// required uint64 cursor_id = 1;
inline bool CDeleteCursorMsg::has_cursor_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CDeleteCursorMsg::set_has_cursor_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CDeleteCursorMsg::clear_has_cursor_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CDeleteCursorMsg::clear_cursor_id() {
  cursor_id_ = GOOGLE_ULONGLONG(0);
  clear_has_cursor_id();
}
inline ::google::protobuf::uint64 CDeleteCursorMsg::cursor_id() const {
  // @@protoc_insertion_point(field_get:CDeleteCursorMsg.cursor_id)
  return cursor_id_;
}
inline void CDeleteCursorMsg::set_cursor_id(::google::protobuf::uint64 value) {
  set_has_cursor_id();
  cursor_id_ = value;
  // @@protoc_insertion_point(field_set:CDeleteCursorMsg.cursor_id)
}

// -------------------------------------------------------------------

// CSetStreamingClientConfig

// required .CStreamingClientConfig config = 1;
inline bool CSetStreamingClientConfig::has_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSetStreamingClientConfig::set_has_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSetStreamingClientConfig::clear_has_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSetStreamingClientConfig::clear_config() {
  if (config_ != NULL) config_->Clear();
  clear_has_config();
}
inline const ::CStreamingClientConfig& CSetStreamingClientConfig::_internal_config() const {
  return *config_;
}
inline const ::CStreamingClientConfig& CSetStreamingClientConfig::config() const {
  const ::CStreamingClientConfig* p = config_;
  // @@protoc_insertion_point(field_get:CSetStreamingClientConfig.config)
  return p != NULL ? *p : *reinterpret_cast<const ::CStreamingClientConfig*>(
      &::_CStreamingClientConfig_default_instance_);
}
inline ::CStreamingClientConfig* CSetStreamingClientConfig::release_config() {
  // @@protoc_insertion_point(field_release:CSetStreamingClientConfig.config)
  clear_has_config();
  ::CStreamingClientConfig* temp = config_;
  config_ = NULL;
  return temp;
}
inline ::CStreamingClientConfig* CSetStreamingClientConfig::mutable_config() {
  set_has_config();
  if (config_ == NULL) {
    auto* p = CreateMaybeMessage<::CStreamingClientConfig>(GetArenaNoVirtual());
    config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CSetStreamingClientConfig.config)
  return config_;
}
inline void CSetStreamingClientConfig::set_allocated_config(::CStreamingClientConfig* config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete config_;
  }
  if (config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    set_has_config();
  } else {
    clear_has_config();
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:CSetStreamingClientConfig.config)
}

// -------------------------------------------------------------------

// CSetQoSMsg

// required bool use_qos = 1;
inline bool CSetQoSMsg::has_use_qos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSetQoSMsg::set_has_use_qos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSetQoSMsg::clear_has_use_qos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSetQoSMsg::clear_use_qos() {
  use_qos_ = false;
  clear_has_use_qos();
}
inline bool CSetQoSMsg::use_qos() const {
  // @@protoc_insertion_point(field_get:CSetQoSMsg.use_qos)
  return use_qos_;
}
inline void CSetQoSMsg::set_use_qos(bool value) {
  set_has_use_qos();
  use_qos_ = value;
  // @@protoc_insertion_point(field_set:CSetQoSMsg.use_qos)
}

// -------------------------------------------------------------------

// CSetTargetFramerateMsg

// required uint32 framerate = 1;
inline bool CSetTargetFramerateMsg::has_framerate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSetTargetFramerateMsg::set_has_framerate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSetTargetFramerateMsg::clear_has_framerate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSetTargetFramerateMsg::clear_framerate() {
  framerate_ = 0u;
  clear_has_framerate();
}
inline ::google::protobuf::uint32 CSetTargetFramerateMsg::framerate() const {
  // @@protoc_insertion_point(field_get:CSetTargetFramerateMsg.framerate)
  return framerate_;
}
inline void CSetTargetFramerateMsg::set_framerate(::google::protobuf::uint32 value) {
  set_has_framerate();
  framerate_ = value;
  // @@protoc_insertion_point(field_set:CSetTargetFramerateMsg.framerate)
}

// optional uint32 reasons = 2;
inline bool CSetTargetFramerateMsg::has_reasons() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSetTargetFramerateMsg::set_has_reasons() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSetTargetFramerateMsg::clear_has_reasons() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSetTargetFramerateMsg::clear_reasons() {
  reasons_ = 0u;
  clear_has_reasons();
}
inline ::google::protobuf::uint32 CSetTargetFramerateMsg::reasons() const {
  // @@protoc_insertion_point(field_get:CSetTargetFramerateMsg.reasons)
  return reasons_;
}
inline void CSetTargetFramerateMsg::set_reasons(::google::protobuf::uint32 value) {
  set_has_reasons();
  reasons_ = value;
  // @@protoc_insertion_point(field_set:CSetTargetFramerateMsg.reasons)
}

// optional uint32 framerate_numerator = 3;
inline bool CSetTargetFramerateMsg::has_framerate_numerator() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSetTargetFramerateMsg::set_has_framerate_numerator() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSetTargetFramerateMsg::clear_has_framerate_numerator() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSetTargetFramerateMsg::clear_framerate_numerator() {
  framerate_numerator_ = 0u;
  clear_has_framerate_numerator();
}
inline ::google::protobuf::uint32 CSetTargetFramerateMsg::framerate_numerator() const {
  // @@protoc_insertion_point(field_get:CSetTargetFramerateMsg.framerate_numerator)
  return framerate_numerator_;
}
inline void CSetTargetFramerateMsg::set_framerate_numerator(::google::protobuf::uint32 value) {
  set_has_framerate_numerator();
  framerate_numerator_ = value;
  // @@protoc_insertion_point(field_set:CSetTargetFramerateMsg.framerate_numerator)
}

// optional uint32 framerate_denominator = 4;
inline bool CSetTargetFramerateMsg::has_framerate_denominator() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSetTargetFramerateMsg::set_has_framerate_denominator() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSetTargetFramerateMsg::clear_has_framerate_denominator() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSetTargetFramerateMsg::clear_framerate_denominator() {
  framerate_denominator_ = 0u;
  clear_has_framerate_denominator();
}
inline ::google::protobuf::uint32 CSetTargetFramerateMsg::framerate_denominator() const {
  // @@protoc_insertion_point(field_get:CSetTargetFramerateMsg.framerate_denominator)
  return framerate_denominator_;
}
inline void CSetTargetFramerateMsg::set_framerate_denominator(::google::protobuf::uint32 value) {
  set_has_framerate_denominator();
  framerate_denominator_ = value;
  // @@protoc_insertion_point(field_set:CSetTargetFramerateMsg.framerate_denominator)
}

// -------------------------------------------------------------------

// CSetTargetBitrateMsg

// required int32 bitrate = 1;
inline bool CSetTargetBitrateMsg::has_bitrate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSetTargetBitrateMsg::set_has_bitrate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSetTargetBitrateMsg::clear_has_bitrate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSetTargetBitrateMsg::clear_bitrate() {
  bitrate_ = 0;
  clear_has_bitrate();
}
inline ::google::protobuf::int32 CSetTargetBitrateMsg::bitrate() const {
  // @@protoc_insertion_point(field_get:CSetTargetBitrateMsg.bitrate)
  return bitrate_;
}
inline void CSetTargetBitrateMsg::set_bitrate(::google::protobuf::int32 value) {
  set_has_bitrate();
  bitrate_ = value;
  // @@protoc_insertion_point(field_set:CSetTargetBitrateMsg.bitrate)
}

// -------------------------------------------------------------------

// COverlayEnabledMsg

// required bool enabled = 1;
inline bool COverlayEnabledMsg::has_enabled() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void COverlayEnabledMsg::set_has_enabled() {
  _has_bits_[0] |= 0x00000001u;
}
inline void COverlayEnabledMsg::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void COverlayEnabledMsg::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool COverlayEnabledMsg::enabled() const {
  // @@protoc_insertion_point(field_get:COverlayEnabledMsg.enabled)
  return enabled_;
}
inline void COverlayEnabledMsg::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
  // @@protoc_insertion_point(field_set:COverlayEnabledMsg.enabled)
}

// -------------------------------------------------------------------

// CSetGammaRampMsg

// optional bytes gamma_ramp = 1;
inline bool CSetGammaRampMsg::has_gamma_ramp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSetGammaRampMsg::set_has_gamma_ramp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSetGammaRampMsg::clear_has_gamma_ramp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSetGammaRampMsg::clear_gamma_ramp() {
  gamma_ramp_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_gamma_ramp();
}
inline const ::std::string& CSetGammaRampMsg::gamma_ramp() const {
  // @@protoc_insertion_point(field_get:CSetGammaRampMsg.gamma_ramp)
  return gamma_ramp_.GetNoArena();
}
inline void CSetGammaRampMsg::set_gamma_ramp(const ::std::string& value) {
  set_has_gamma_ramp();
  gamma_ramp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CSetGammaRampMsg.gamma_ramp)
}
#if LANG_CXX11
inline void CSetGammaRampMsg::set_gamma_ramp(::std::string&& value) {
  set_has_gamma_ramp();
  gamma_ramp_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CSetGammaRampMsg.gamma_ramp)
}
#endif
inline void CSetGammaRampMsg::set_gamma_ramp(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_gamma_ramp();
  gamma_ramp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CSetGammaRampMsg.gamma_ramp)
}
inline void CSetGammaRampMsg::set_gamma_ramp(const void* value, size_t size) {
  set_has_gamma_ramp();
  gamma_ramp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CSetGammaRampMsg.gamma_ramp)
}
inline ::std::string* CSetGammaRampMsg::mutable_gamma_ramp() {
  set_has_gamma_ramp();
  // @@protoc_insertion_point(field_mutable:CSetGammaRampMsg.gamma_ramp)
  return gamma_ramp_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CSetGammaRampMsg::release_gamma_ramp() {
  // @@protoc_insertion_point(field_release:CSetGammaRampMsg.gamma_ramp)
  if (!has_gamma_ramp()) {
    return NULL;
  }
  clear_has_gamma_ramp();
  return gamma_ramp_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CSetGammaRampMsg::set_allocated_gamma_ramp(::std::string* gamma_ramp) {
  if (gamma_ramp != NULL) {
    set_has_gamma_ramp();
  } else {
    clear_has_gamma_ramp();
  }
  gamma_ramp_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gamma_ramp);
  // @@protoc_insertion_point(field_set_allocated:CSetGammaRampMsg.gamma_ramp)
}

// -------------------------------------------------------------------

// CSetActivityMsg

// optional .EStreamActivity activity = 1 [default = k_EStreamActivityIdle];
inline bool CSetActivityMsg::has_activity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSetActivityMsg::set_has_activity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSetActivityMsg::clear_has_activity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSetActivityMsg::clear_activity() {
  activity_ = 1;
  clear_has_activity();
}
inline ::EStreamActivity CSetActivityMsg::activity() const {
  // @@protoc_insertion_point(field_get:CSetActivityMsg.activity)
  return static_cast< ::EStreamActivity >(activity_);
}
inline void CSetActivityMsg::set_activity(::EStreamActivity value) {
  assert(::EStreamActivity_IsValid(value));
  set_has_activity();
  activity_ = value;
  // @@protoc_insertion_point(field_set:CSetActivityMsg.activity)
}

// -------------------------------------------------------------------

// CSystemSuspendMsg

// -------------------------------------------------------------------

// CVirtualHereRequestMsg

// optional string hostname = 1;
inline bool CVirtualHereRequestMsg::has_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CVirtualHereRequestMsg::set_has_hostname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CVirtualHereRequestMsg::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CVirtualHereRequestMsg::clear_hostname() {
  hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hostname();
}
inline const ::std::string& CVirtualHereRequestMsg::hostname() const {
  // @@protoc_insertion_point(field_get:CVirtualHereRequestMsg.hostname)
  return hostname_.GetNoArena();
}
inline void CVirtualHereRequestMsg::set_hostname(const ::std::string& value) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CVirtualHereRequestMsg.hostname)
}
#if LANG_CXX11
inline void CVirtualHereRequestMsg::set_hostname(::std::string&& value) {
  set_has_hostname();
  hostname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CVirtualHereRequestMsg.hostname)
}
#endif
inline void CVirtualHereRequestMsg::set_hostname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CVirtualHereRequestMsg.hostname)
}
inline void CVirtualHereRequestMsg::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CVirtualHereRequestMsg.hostname)
}
inline ::std::string* CVirtualHereRequestMsg::mutable_hostname() {
  set_has_hostname();
  // @@protoc_insertion_point(field_mutable:CVirtualHereRequestMsg.hostname)
  return hostname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CVirtualHereRequestMsg::release_hostname() {
  // @@protoc_insertion_point(field_release:CVirtualHereRequestMsg.hostname)
  if (!has_hostname()) {
    return NULL;
  }
  clear_has_hostname();
  return hostname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CVirtualHereRequestMsg::set_allocated_hostname(::std::string* hostname) {
  if (hostname != NULL) {
    set_has_hostname();
  } else {
    clear_has_hostname();
  }
  hostname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostname);
  // @@protoc_insertion_point(field_set_allocated:CVirtualHereRequestMsg.hostname)
}

// -------------------------------------------------------------------

// CVirtualHereReadyMsg

// optional uint32 licensed_device_count = 1;
inline bool CVirtualHereReadyMsg::has_licensed_device_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CVirtualHereReadyMsg::set_has_licensed_device_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CVirtualHereReadyMsg::clear_has_licensed_device_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CVirtualHereReadyMsg::clear_licensed_device_count() {
  licensed_device_count_ = 0u;
  clear_has_licensed_device_count();
}
inline ::google::protobuf::uint32 CVirtualHereReadyMsg::licensed_device_count() const {
  // @@protoc_insertion_point(field_get:CVirtualHereReadyMsg.licensed_device_count)
  return licensed_device_count_;
}
inline void CVirtualHereReadyMsg::set_licensed_device_count(::google::protobuf::uint32 value) {
  set_has_licensed_device_count();
  licensed_device_count_ = value;
  // @@protoc_insertion_point(field_set:CVirtualHereReadyMsg.licensed_device_count)
}

// -------------------------------------------------------------------

// CVirtualHereShareDeviceMsg

// optional string device_address = 1;
inline bool CVirtualHereShareDeviceMsg::has_device_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CVirtualHereShareDeviceMsg::set_has_device_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CVirtualHereShareDeviceMsg::clear_has_device_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CVirtualHereShareDeviceMsg::clear_device_address() {
  device_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_device_address();
}
inline const ::std::string& CVirtualHereShareDeviceMsg::device_address() const {
  // @@protoc_insertion_point(field_get:CVirtualHereShareDeviceMsg.device_address)
  return device_address_.GetNoArena();
}
inline void CVirtualHereShareDeviceMsg::set_device_address(const ::std::string& value) {
  set_has_device_address();
  device_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CVirtualHereShareDeviceMsg.device_address)
}
#if LANG_CXX11
inline void CVirtualHereShareDeviceMsg::set_device_address(::std::string&& value) {
  set_has_device_address();
  device_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CVirtualHereShareDeviceMsg.device_address)
}
#endif
inline void CVirtualHereShareDeviceMsg::set_device_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_device_address();
  device_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CVirtualHereShareDeviceMsg.device_address)
}
inline void CVirtualHereShareDeviceMsg::set_device_address(const char* value, size_t size) {
  set_has_device_address();
  device_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CVirtualHereShareDeviceMsg.device_address)
}
inline ::std::string* CVirtualHereShareDeviceMsg::mutable_device_address() {
  set_has_device_address();
  // @@protoc_insertion_point(field_mutable:CVirtualHereShareDeviceMsg.device_address)
  return device_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CVirtualHereShareDeviceMsg::release_device_address() {
  // @@protoc_insertion_point(field_release:CVirtualHereShareDeviceMsg.device_address)
  if (!has_device_address()) {
    return NULL;
  }
  clear_has_device_address();
  return device_address_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CVirtualHereShareDeviceMsg::set_allocated_device_address(::std::string* device_address) {
  if (device_address != NULL) {
    set_has_device_address();
  } else {
    clear_has_device_address();
  }
  device_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_address);
  // @@protoc_insertion_point(field_set_allocated:CVirtualHereShareDeviceMsg.device_address)
}

// -------------------------------------------------------------------

// CSetSpectatorModeMsg

// optional bool enabled = 1;
inline bool CSetSpectatorModeMsg::has_enabled() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSetSpectatorModeMsg::set_has_enabled() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSetSpectatorModeMsg::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSetSpectatorModeMsg::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool CSetSpectatorModeMsg::enabled() const {
  // @@protoc_insertion_point(field_get:CSetSpectatorModeMsg.enabled)
  return enabled_;
}
inline void CSetSpectatorModeMsg::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
  // @@protoc_insertion_point(field_set:CSetSpectatorModeMsg.enabled)
}

// -------------------------------------------------------------------

// CRemoteHIDMsg

// optional bytes data = 1;
inline bool CRemoteHIDMsg::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CRemoteHIDMsg::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CRemoteHIDMsg::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CRemoteHIDMsg::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& CRemoteHIDMsg::data() const {
  // @@protoc_insertion_point(field_get:CRemoteHIDMsg.data)
  return data_.GetNoArena();
}
inline void CRemoteHIDMsg::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CRemoteHIDMsg.data)
}
#if LANG_CXX11
inline void CRemoteHIDMsg::set_data(::std::string&& value) {
  set_has_data();
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CRemoteHIDMsg.data)
}
#endif
inline void CRemoteHIDMsg::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CRemoteHIDMsg.data)
}
inline void CRemoteHIDMsg::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CRemoteHIDMsg.data)
}
inline ::std::string* CRemoteHIDMsg::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:CRemoteHIDMsg.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CRemoteHIDMsg::release_data() {
  // @@protoc_insertion_point(field_release:CRemoteHIDMsg.data)
  if (!has_data()) {
    return NULL;
  }
  clear_has_data();
  return data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CRemoteHIDMsg::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:CRemoteHIDMsg.data)
}

// -------------------------------------------------------------------

// CTouchConfigActiveMsg

// optional uint32 appid = 1;
inline bool CTouchConfigActiveMsg::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CTouchConfigActiveMsg::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CTouchConfigActiveMsg::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CTouchConfigActiveMsg::clear_appid() {
  appid_ = 0u;
  clear_has_appid();
}
inline ::google::protobuf::uint32 CTouchConfigActiveMsg::appid() const {
  // @@protoc_insertion_point(field_get:CTouchConfigActiveMsg.appid)
  return appid_;
}
inline void CTouchConfigActiveMsg::set_appid(::google::protobuf::uint32 value) {
  set_has_appid();
  appid_ = value;
  // @@protoc_insertion_point(field_set:CTouchConfigActiveMsg.appid)
}

// optional uint32 revision = 2;
inline bool CTouchConfigActiveMsg::has_revision() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CTouchConfigActiveMsg::set_has_revision() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CTouchConfigActiveMsg::clear_has_revision() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CTouchConfigActiveMsg::clear_revision() {
  revision_ = 0u;
  clear_has_revision();
}
inline ::google::protobuf::uint32 CTouchConfigActiveMsg::revision() const {
  // @@protoc_insertion_point(field_get:CTouchConfigActiveMsg.revision)
  return revision_;
}
inline void CTouchConfigActiveMsg::set_revision(::google::protobuf::uint32 value) {
  set_has_revision();
  revision_ = value;
  // @@protoc_insertion_point(field_set:CTouchConfigActiveMsg.revision)
}

// -------------------------------------------------------------------

// CGetTouchConfigDataMsg

// optional uint32 appid = 1;
inline bool CGetTouchConfigDataMsg::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGetTouchConfigDataMsg::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGetTouchConfigDataMsg::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGetTouchConfigDataMsg::clear_appid() {
  appid_ = 0u;
  clear_has_appid();
}
inline ::google::protobuf::uint32 CGetTouchConfigDataMsg::appid() const {
  // @@protoc_insertion_point(field_get:CGetTouchConfigDataMsg.appid)
  return appid_;
}
inline void CGetTouchConfigDataMsg::set_appid(::google::protobuf::uint32 value) {
  set_has_appid();
  appid_ = value;
  // @@protoc_insertion_point(field_set:CGetTouchConfigDataMsg.appid)
}

// -------------------------------------------------------------------

// CSetTouchConfigDataMsg

// optional uint32 appid = 1;
inline bool CSetTouchConfigDataMsg::has_appid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSetTouchConfigDataMsg::set_has_appid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSetTouchConfigDataMsg::clear_has_appid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSetTouchConfigDataMsg::clear_appid() {
  appid_ = 0u;
  clear_has_appid();
}
inline ::google::protobuf::uint32 CSetTouchConfigDataMsg::appid() const {
  // @@protoc_insertion_point(field_get:CSetTouchConfigDataMsg.appid)
  return appid_;
}
inline void CSetTouchConfigDataMsg::set_appid(::google::protobuf::uint32 value) {
  set_has_appid();
  appid_ = value;
  // @@protoc_insertion_point(field_set:CSetTouchConfigDataMsg.appid)
}

// optional uint32 revision = 2;
inline bool CSetTouchConfigDataMsg::has_revision() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSetTouchConfigDataMsg::set_has_revision() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSetTouchConfigDataMsg::clear_has_revision() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSetTouchConfigDataMsg::clear_revision() {
  revision_ = 0u;
  clear_has_revision();
}
inline ::google::protobuf::uint32 CSetTouchConfigDataMsg::revision() const {
  // @@protoc_insertion_point(field_get:CSetTouchConfigDataMsg.revision)
  return revision_;
}
inline void CSetTouchConfigDataMsg::set_revision(::google::protobuf::uint32 value) {
  set_has_revision();
  revision_ = value;
  // @@protoc_insertion_point(field_set:CSetTouchConfigDataMsg.revision)
}

// optional bytes data = 3;
inline bool CSetTouchConfigDataMsg::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSetTouchConfigDataMsg::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSetTouchConfigDataMsg::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSetTouchConfigDataMsg::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& CSetTouchConfigDataMsg::data() const {
  // @@protoc_insertion_point(field_get:CSetTouchConfigDataMsg.data)
  return data_.GetNoArena();
}
inline void CSetTouchConfigDataMsg::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CSetTouchConfigDataMsg.data)
}
#if LANG_CXX11
inline void CSetTouchConfigDataMsg::set_data(::std::string&& value) {
  set_has_data();
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CSetTouchConfigDataMsg.data)
}
#endif
inline void CSetTouchConfigDataMsg::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CSetTouchConfigDataMsg.data)
}
inline void CSetTouchConfigDataMsg::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CSetTouchConfigDataMsg.data)
}
inline ::std::string* CSetTouchConfigDataMsg::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:CSetTouchConfigDataMsg.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CSetTouchConfigDataMsg::release_data() {
  // @@protoc_insertion_point(field_release:CSetTouchConfigDataMsg.data)
  if (!has_data()) {
    return NULL;
  }
  clear_has_data();
  return data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CSetTouchConfigDataMsg::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:CSetTouchConfigDataMsg.data)
}

// optional bytes layout = 4;
inline bool CSetTouchConfigDataMsg::has_layout() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSetTouchConfigDataMsg::set_has_layout() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSetTouchConfigDataMsg::clear_has_layout() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSetTouchConfigDataMsg::clear_layout() {
  layout_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_layout();
}
inline const ::std::string& CSetTouchConfigDataMsg::layout() const {
  // @@protoc_insertion_point(field_get:CSetTouchConfigDataMsg.layout)
  return layout_.GetNoArena();
}
inline void CSetTouchConfigDataMsg::set_layout(const ::std::string& value) {
  set_has_layout();
  layout_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CSetTouchConfigDataMsg.layout)
}
#if LANG_CXX11
inline void CSetTouchConfigDataMsg::set_layout(::std::string&& value) {
  set_has_layout();
  layout_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CSetTouchConfigDataMsg.layout)
}
#endif
inline void CSetTouchConfigDataMsg::set_layout(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_layout();
  layout_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CSetTouchConfigDataMsg.layout)
}
inline void CSetTouchConfigDataMsg::set_layout(const void* value, size_t size) {
  set_has_layout();
  layout_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CSetTouchConfigDataMsg.layout)
}
inline ::std::string* CSetTouchConfigDataMsg::mutable_layout() {
  set_has_layout();
  // @@protoc_insertion_point(field_mutable:CSetTouchConfigDataMsg.layout)
  return layout_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CSetTouchConfigDataMsg::release_layout() {
  // @@protoc_insertion_point(field_release:CSetTouchConfigDataMsg.layout)
  if (!has_layout()) {
    return NULL;
  }
  clear_has_layout();
  return layout_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CSetTouchConfigDataMsg::set_allocated_layout(::std::string* layout) {
  if (layout != NULL) {
    set_has_layout();
  } else {
    clear_has_layout();
  }
  layout_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), layout);
  // @@protoc_insertion_point(field_set_allocated:CSetTouchConfigDataMsg.layout)
}

// -------------------------------------------------------------------

// CSaveTouchConfigLayoutMsg

// optional uint32 appid = 1;
inline bool CSaveTouchConfigLayoutMsg::has_appid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSaveTouchConfigLayoutMsg::set_has_appid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSaveTouchConfigLayoutMsg::clear_has_appid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSaveTouchConfigLayoutMsg::clear_appid() {
  appid_ = 0u;
  clear_has_appid();
}
inline ::google::protobuf::uint32 CSaveTouchConfigLayoutMsg::appid() const {
  // @@protoc_insertion_point(field_get:CSaveTouchConfigLayoutMsg.appid)
  return appid_;
}
inline void CSaveTouchConfigLayoutMsg::set_appid(::google::protobuf::uint32 value) {
  set_has_appid();
  appid_ = value;
  // @@protoc_insertion_point(field_set:CSaveTouchConfigLayoutMsg.appid)
}

// optional bytes layout = 4;
inline bool CSaveTouchConfigLayoutMsg::has_layout() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSaveTouchConfigLayoutMsg::set_has_layout() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSaveTouchConfigLayoutMsg::clear_has_layout() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSaveTouchConfigLayoutMsg::clear_layout() {
  layout_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_layout();
}
inline const ::std::string& CSaveTouchConfigLayoutMsg::layout() const {
  // @@protoc_insertion_point(field_get:CSaveTouchConfigLayoutMsg.layout)
  return layout_.GetNoArena();
}
inline void CSaveTouchConfigLayoutMsg::set_layout(const ::std::string& value) {
  set_has_layout();
  layout_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CSaveTouchConfigLayoutMsg.layout)
}
#if LANG_CXX11
inline void CSaveTouchConfigLayoutMsg::set_layout(::std::string&& value) {
  set_has_layout();
  layout_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CSaveTouchConfigLayoutMsg.layout)
}
#endif
inline void CSaveTouchConfigLayoutMsg::set_layout(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_layout();
  layout_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CSaveTouchConfigLayoutMsg.layout)
}
inline void CSaveTouchConfigLayoutMsg::set_layout(const void* value, size_t size) {
  set_has_layout();
  layout_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CSaveTouchConfigLayoutMsg.layout)
}
inline ::std::string* CSaveTouchConfigLayoutMsg::mutable_layout() {
  set_has_layout();
  // @@protoc_insertion_point(field_mutable:CSaveTouchConfigLayoutMsg.layout)
  return layout_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CSaveTouchConfigLayoutMsg::release_layout() {
  // @@protoc_insertion_point(field_release:CSaveTouchConfigLayoutMsg.layout)
  if (!has_layout()) {
    return NULL;
  }
  clear_has_layout();
  return layout_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CSaveTouchConfigLayoutMsg::set_allocated_layout(::std::string* layout) {
  if (layout != NULL) {
    set_has_layout();
  } else {
    clear_has_layout();
  }
  layout_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), layout);
  // @@protoc_insertion_point(field_set_allocated:CSaveTouchConfigLayoutMsg.layout)
}

// -------------------------------------------------------------------

// CTouchActionSetActiveMsg

// optional uint32 appid = 1;
inline bool CTouchActionSetActiveMsg::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CTouchActionSetActiveMsg::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CTouchActionSetActiveMsg::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CTouchActionSetActiveMsg::clear_appid() {
  appid_ = 0u;
  clear_has_appid();
}
inline ::google::protobuf::uint32 CTouchActionSetActiveMsg::appid() const {
  // @@protoc_insertion_point(field_get:CTouchActionSetActiveMsg.appid)
  return appid_;
}
inline void CTouchActionSetActiveMsg::set_appid(::google::protobuf::uint32 value) {
  set_has_appid();
  appid_ = value;
  // @@protoc_insertion_point(field_set:CTouchActionSetActiveMsg.appid)
}

// optional int32 actionset_id = 2;
inline bool CTouchActionSetActiveMsg::has_actionset_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CTouchActionSetActiveMsg::set_has_actionset_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CTouchActionSetActiveMsg::clear_has_actionset_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CTouchActionSetActiveMsg::clear_actionset_id() {
  actionset_id_ = 0;
  clear_has_actionset_id();
}
inline ::google::protobuf::int32 CTouchActionSetActiveMsg::actionset_id() const {
  // @@protoc_insertion_point(field_get:CTouchActionSetActiveMsg.actionset_id)
  return actionset_id_;
}
inline void CTouchActionSetActiveMsg::set_actionset_id(::google::protobuf::int32 value) {
  set_has_actionset_id();
  actionset_id_ = value;
  // @@protoc_insertion_point(field_set:CTouchActionSetActiveMsg.actionset_id)
}

// -------------------------------------------------------------------

// CGetTouchIconDataMsg

// optional uint32 appid = 1;
inline bool CGetTouchIconDataMsg::has_appid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CGetTouchIconDataMsg::set_has_appid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CGetTouchIconDataMsg::clear_has_appid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CGetTouchIconDataMsg::clear_appid() {
  appid_ = 0u;
  clear_has_appid();
}
inline ::google::protobuf::uint32 CGetTouchIconDataMsg::appid() const {
  // @@protoc_insertion_point(field_get:CGetTouchIconDataMsg.appid)
  return appid_;
}
inline void CGetTouchIconDataMsg::set_appid(::google::protobuf::uint32 value) {
  set_has_appid();
  appid_ = value;
  // @@protoc_insertion_point(field_set:CGetTouchIconDataMsg.appid)
}

// optional string icon = 2;
inline bool CGetTouchIconDataMsg::has_icon() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CGetTouchIconDataMsg::set_has_icon() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CGetTouchIconDataMsg::clear_has_icon() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CGetTouchIconDataMsg::clear_icon() {
  icon_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_icon();
}
inline const ::std::string& CGetTouchIconDataMsg::icon() const {
  // @@protoc_insertion_point(field_get:CGetTouchIconDataMsg.icon)
  return icon_.GetNoArena();
}
inline void CGetTouchIconDataMsg::set_icon(const ::std::string& value) {
  set_has_icon();
  icon_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CGetTouchIconDataMsg.icon)
}
#if LANG_CXX11
inline void CGetTouchIconDataMsg::set_icon(::std::string&& value) {
  set_has_icon();
  icon_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CGetTouchIconDataMsg.icon)
}
#endif
inline void CGetTouchIconDataMsg::set_icon(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_icon();
  icon_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CGetTouchIconDataMsg.icon)
}
inline void CGetTouchIconDataMsg::set_icon(const char* value, size_t size) {
  set_has_icon();
  icon_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CGetTouchIconDataMsg.icon)
}
inline ::std::string* CGetTouchIconDataMsg::mutable_icon() {
  set_has_icon();
  // @@protoc_insertion_point(field_mutable:CGetTouchIconDataMsg.icon)
  return icon_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CGetTouchIconDataMsg::release_icon() {
  // @@protoc_insertion_point(field_release:CGetTouchIconDataMsg.icon)
  if (!has_icon()) {
    return NULL;
  }
  clear_has_icon();
  return icon_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CGetTouchIconDataMsg::set_allocated_icon(::std::string* icon) {
  if (icon != NULL) {
    set_has_icon();
  } else {
    clear_has_icon();
  }
  icon_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), icon);
  // @@protoc_insertion_point(field_set_allocated:CGetTouchIconDataMsg.icon)
}

// -------------------------------------------------------------------

// CSetTouchIconDataMsg

// optional uint32 appid = 1;
inline bool CSetTouchIconDataMsg::has_appid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSetTouchIconDataMsg::set_has_appid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSetTouchIconDataMsg::clear_has_appid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSetTouchIconDataMsg::clear_appid() {
  appid_ = 0u;
  clear_has_appid();
}
inline ::google::protobuf::uint32 CSetTouchIconDataMsg::appid() const {
  // @@protoc_insertion_point(field_get:CSetTouchIconDataMsg.appid)
  return appid_;
}
inline void CSetTouchIconDataMsg::set_appid(::google::protobuf::uint32 value) {
  set_has_appid();
  appid_ = value;
  // @@protoc_insertion_point(field_set:CSetTouchIconDataMsg.appid)
}

// optional string icon = 2;
inline bool CSetTouchIconDataMsg::has_icon() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSetTouchIconDataMsg::set_has_icon() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSetTouchIconDataMsg::clear_has_icon() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSetTouchIconDataMsg::clear_icon() {
  icon_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_icon();
}
inline const ::std::string& CSetTouchIconDataMsg::icon() const {
  // @@protoc_insertion_point(field_get:CSetTouchIconDataMsg.icon)
  return icon_.GetNoArena();
}
inline void CSetTouchIconDataMsg::set_icon(const ::std::string& value) {
  set_has_icon();
  icon_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CSetTouchIconDataMsg.icon)
}
#if LANG_CXX11
inline void CSetTouchIconDataMsg::set_icon(::std::string&& value) {
  set_has_icon();
  icon_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CSetTouchIconDataMsg.icon)
}
#endif
inline void CSetTouchIconDataMsg::set_icon(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_icon();
  icon_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CSetTouchIconDataMsg.icon)
}
inline void CSetTouchIconDataMsg::set_icon(const char* value, size_t size) {
  set_has_icon();
  icon_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CSetTouchIconDataMsg.icon)
}
inline ::std::string* CSetTouchIconDataMsg::mutable_icon() {
  set_has_icon();
  // @@protoc_insertion_point(field_mutable:CSetTouchIconDataMsg.icon)
  return icon_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CSetTouchIconDataMsg::release_icon() {
  // @@protoc_insertion_point(field_release:CSetTouchIconDataMsg.icon)
  if (!has_icon()) {
    return NULL;
  }
  clear_has_icon();
  return icon_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CSetTouchIconDataMsg::set_allocated_icon(::std::string* icon) {
  if (icon != NULL) {
    set_has_icon();
  } else {
    clear_has_icon();
  }
  icon_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), icon);
  // @@protoc_insertion_point(field_set_allocated:CSetTouchIconDataMsg.icon)
}

// optional bytes data = 3;
inline bool CSetTouchIconDataMsg::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSetTouchIconDataMsg::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSetTouchIconDataMsg::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSetTouchIconDataMsg::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& CSetTouchIconDataMsg::data() const {
  // @@protoc_insertion_point(field_get:CSetTouchIconDataMsg.data)
  return data_.GetNoArena();
}
inline void CSetTouchIconDataMsg::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CSetTouchIconDataMsg.data)
}
#if LANG_CXX11
inline void CSetTouchIconDataMsg::set_data(::std::string&& value) {
  set_has_data();
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CSetTouchIconDataMsg.data)
}
#endif
inline void CSetTouchIconDataMsg::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CSetTouchIconDataMsg.data)
}
inline void CSetTouchIconDataMsg::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CSetTouchIconDataMsg.data)
}
inline ::std::string* CSetTouchIconDataMsg::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:CSetTouchIconDataMsg.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CSetTouchIconDataMsg::release_data() {
  // @@protoc_insertion_point(field_release:CSetTouchIconDataMsg.data)
  if (!has_data()) {
    return NULL;
  }
  clear_has_data();
  return data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CSetTouchIconDataMsg::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:CSetTouchIconDataMsg.data)
}

// -------------------------------------------------------------------

// CStreamDataLostMsg

// repeated uint32 packets = 1;
inline int CStreamDataLostMsg::packets_size() const {
  return packets_.size();
}
inline void CStreamDataLostMsg::clear_packets() {
  packets_.Clear();
}
inline ::google::protobuf::uint32 CStreamDataLostMsg::packets(int index) const {
  // @@protoc_insertion_point(field_get:CStreamDataLostMsg.packets)
  return packets_.Get(index);
}
inline void CStreamDataLostMsg::set_packets(int index, ::google::protobuf::uint32 value) {
  packets_.Set(index, value);
  // @@protoc_insertion_point(field_set:CStreamDataLostMsg.packets)
}
inline void CStreamDataLostMsg::add_packets(::google::protobuf::uint32 value) {
  packets_.Add(value);
  // @@protoc_insertion_point(field_add:CStreamDataLostMsg.packets)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CStreamDataLostMsg::packets() const {
  // @@protoc_insertion_point(field_list:CStreamDataLostMsg.packets)
  return packets_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CStreamDataLostMsg::mutable_packets() {
  // @@protoc_insertion_point(field_mutable_list:CStreamDataLostMsg.packets)
  return &packets_;
}

// -------------------------------------------------------------------

// CAudioFormat

// required .EAudioFormat format = 1 [default = k_EAudioFormatNone];
inline bool CAudioFormat::has_format() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CAudioFormat::set_has_format() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CAudioFormat::clear_has_format() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CAudioFormat::clear_format() {
  format_ = 0;
  clear_has_format();
}
inline ::EAudioFormat CAudioFormat::format() const {
  // @@protoc_insertion_point(field_get:CAudioFormat.format)
  return static_cast< ::EAudioFormat >(format_);
}
inline void CAudioFormat::set_format(::EAudioFormat value) {
  assert(::EAudioFormat_IsValid(value));
  set_has_format();
  format_ = value;
  // @@protoc_insertion_point(field_set:CAudioFormat.format)
}

// optional uint32 frequency = 2;
inline bool CAudioFormat::has_frequency() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CAudioFormat::set_has_frequency() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CAudioFormat::clear_has_frequency() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CAudioFormat::clear_frequency() {
  frequency_ = 0u;
  clear_has_frequency();
}
inline ::google::protobuf::uint32 CAudioFormat::frequency() const {
  // @@protoc_insertion_point(field_get:CAudioFormat.frequency)
  return frequency_;
}
inline void CAudioFormat::set_frequency(::google::protobuf::uint32 value) {
  set_has_frequency();
  frequency_ = value;
  // @@protoc_insertion_point(field_set:CAudioFormat.frequency)
}

// optional uint32 channels = 3;
inline bool CAudioFormat::has_channels() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CAudioFormat::set_has_channels() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CAudioFormat::clear_has_channels() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CAudioFormat::clear_channels() {
  channels_ = 0u;
  clear_has_channels();
}
inline ::google::protobuf::uint32 CAudioFormat::channels() const {
  // @@protoc_insertion_point(field_get:CAudioFormat.channels)
  return channels_;
}
inline void CAudioFormat::set_channels(::google::protobuf::uint32 value) {
  set_has_channels();
  channels_ = value;
  // @@protoc_insertion_point(field_set:CAudioFormat.channels)
}

// -------------------------------------------------------------------

// CVideoFormat

// required .EVideoFormat format = 1 [default = k_EVideoFormatNone];
inline bool CVideoFormat::has_format() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CVideoFormat::set_has_format() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CVideoFormat::clear_has_format() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CVideoFormat::clear_format() {
  format_ = 0;
  clear_has_format();
}
inline ::EVideoFormat CVideoFormat::format() const {
  // @@protoc_insertion_point(field_get:CVideoFormat.format)
  return static_cast< ::EVideoFormat >(format_);
}
inline void CVideoFormat::set_format(::EVideoFormat value) {
  assert(::EVideoFormat_IsValid(value));
  set_has_format();
  format_ = value;
  // @@protoc_insertion_point(field_set:CVideoFormat.format)
}

// optional uint32 width = 2;
inline bool CVideoFormat::has_width() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CVideoFormat::set_has_width() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CVideoFormat::clear_has_width() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CVideoFormat::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 CVideoFormat::width() const {
  // @@protoc_insertion_point(field_get:CVideoFormat.width)
  return width_;
}
inline void CVideoFormat::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:CVideoFormat.width)
}

// optional uint32 height = 3;
inline bool CVideoFormat::has_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CVideoFormat::set_has_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CVideoFormat::clear_has_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CVideoFormat::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 CVideoFormat::height() const {
  // @@protoc_insertion_point(field_get:CVideoFormat.height)
  return height_;
}
inline void CVideoFormat::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:CVideoFormat.height)
}

// -------------------------------------------------------------------

// CFrameEvent

// required .EStreamFrameEvent event_id = 1 [default = k_EStreamInputEventStart];
inline bool CFrameEvent::has_event_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CFrameEvent::set_has_event_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CFrameEvent::clear_has_event_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CFrameEvent::clear_event_id() {
  event_id_ = 0;
  clear_has_event_id();
}
inline ::EStreamFrameEvent CFrameEvent::event_id() const {
  // @@protoc_insertion_point(field_get:CFrameEvent.event_id)
  return static_cast< ::EStreamFrameEvent >(event_id_);
}
inline void CFrameEvent::set_event_id(::EStreamFrameEvent value) {
  assert(::EStreamFrameEvent_IsValid(value));
  set_has_event_id();
  event_id_ = value;
  // @@protoc_insertion_point(field_set:CFrameEvent.event_id)
}

// required uint32 timestamp = 2;
inline bool CFrameEvent::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CFrameEvent::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CFrameEvent::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CFrameEvent::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 CFrameEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:CFrameEvent.timestamp)
  return timestamp_;
}
inline void CFrameEvent::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:CFrameEvent.timestamp)
}

// -------------------------------------------------------------------

// CFrameStats

// required uint32 frame_id = 1;
inline bool CFrameStats::has_frame_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CFrameStats::set_has_frame_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CFrameStats::clear_has_frame_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CFrameStats::clear_frame_id() {
  frame_id_ = 0u;
  clear_has_frame_id();
}
inline ::google::protobuf::uint32 CFrameStats::frame_id() const {
  // @@protoc_insertion_point(field_get:CFrameStats.frame_id)
  return frame_id_;
}
inline void CFrameStats::set_frame_id(::google::protobuf::uint32 value) {
  set_has_frame_id();
  frame_id_ = value;
  // @@protoc_insertion_point(field_set:CFrameStats.frame_id)
}

// optional uint32 input_mark = 2;
inline bool CFrameStats::has_input_mark() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CFrameStats::set_has_input_mark() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CFrameStats::clear_has_input_mark() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CFrameStats::clear_input_mark() {
  input_mark_ = 0u;
  clear_has_input_mark();
}
inline ::google::protobuf::uint32 CFrameStats::input_mark() const {
  // @@protoc_insertion_point(field_get:CFrameStats.input_mark)
  return input_mark_;
}
inline void CFrameStats::set_input_mark(::google::protobuf::uint32 value) {
  set_has_input_mark();
  input_mark_ = value;
  // @@protoc_insertion_point(field_set:CFrameStats.input_mark)
}

// repeated .CFrameEvent events = 3;
inline int CFrameStats::events_size() const {
  return events_.size();
}
inline void CFrameStats::clear_events() {
  events_.Clear();
}
inline ::CFrameEvent* CFrameStats::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:CFrameStats.events)
  return events_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::CFrameEvent >*
CFrameStats::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:CFrameStats.events)
  return &events_;
}
inline const ::CFrameEvent& CFrameStats::events(int index) const {
  // @@protoc_insertion_point(field_get:CFrameStats.events)
  return events_.Get(index);
}
inline ::CFrameEvent* CFrameStats::add_events() {
  // @@protoc_insertion_point(field_add:CFrameStats.events)
  return events_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CFrameEvent >&
CFrameStats::events() const {
  // @@protoc_insertion_point(field_list:CFrameStats.events)
  return events_;
}

// required .EStreamFrameResult result = 4 [default = k_EStreamFrameResultPending];
inline bool CFrameStats::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CFrameStats::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CFrameStats::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CFrameStats::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::EStreamFrameResult CFrameStats::result() const {
  // @@protoc_insertion_point(field_get:CFrameStats.result)
  return static_cast< ::EStreamFrameResult >(result_);
}
inline void CFrameStats::set_result(::EStreamFrameResult value) {
  assert(::EStreamFrameResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:CFrameStats.result)
}

// optional float frame_start_delta = 5;
inline bool CFrameStats::has_frame_start_delta() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CFrameStats::set_has_frame_start_delta() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CFrameStats::clear_has_frame_start_delta() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CFrameStats::clear_frame_start_delta() {
  frame_start_delta_ = 0;
  clear_has_frame_start_delta();
}
inline float CFrameStats::frame_start_delta() const {
  // @@protoc_insertion_point(field_get:CFrameStats.frame_start_delta)
  return frame_start_delta_;
}
inline void CFrameStats::set_frame_start_delta(float value) {
  set_has_frame_start_delta();
  frame_start_delta_ = value;
  // @@protoc_insertion_point(field_set:CFrameStats.frame_start_delta)
}

// optional float frame_display_delta = 6;
inline bool CFrameStats::has_frame_display_delta() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CFrameStats::set_has_frame_display_delta() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CFrameStats::clear_has_frame_display_delta() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CFrameStats::clear_frame_display_delta() {
  frame_display_delta_ = 0;
  clear_has_frame_display_delta();
}
inline float CFrameStats::frame_display_delta() const {
  // @@protoc_insertion_point(field_get:CFrameStats.frame_display_delta)
  return frame_display_delta_;
}
inline void CFrameStats::set_frame_display_delta(float value) {
  set_has_frame_display_delta();
  frame_display_delta_ = value;
  // @@protoc_insertion_point(field_set:CFrameStats.frame_display_delta)
}

// optional float ping_time = 7;
inline bool CFrameStats::has_ping_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CFrameStats::set_has_ping_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CFrameStats::clear_has_ping_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CFrameStats::clear_ping_time() {
  ping_time_ = 0;
  clear_has_ping_time();
}
inline float CFrameStats::ping_time() const {
  // @@protoc_insertion_point(field_get:CFrameStats.ping_time)
  return ping_time_;
}
inline void CFrameStats::set_ping_time(float value) {
  set_has_ping_time();
  ping_time_ = value;
  // @@protoc_insertion_point(field_set:CFrameStats.ping_time)
}

// optional float server_bitrate = 8;
inline bool CFrameStats::has_server_bitrate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CFrameStats::set_has_server_bitrate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CFrameStats::clear_has_server_bitrate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CFrameStats::clear_server_bitrate() {
  server_bitrate_ = 0;
  clear_has_server_bitrate();
}
inline float CFrameStats::server_bitrate() const {
  // @@protoc_insertion_point(field_get:CFrameStats.server_bitrate)
  return server_bitrate_;
}
inline void CFrameStats::set_server_bitrate(float value) {
  set_has_server_bitrate();
  server_bitrate_ = value;
  // @@protoc_insertion_point(field_set:CFrameStats.server_bitrate)
}

// optional float client_bitrate = 9;
inline bool CFrameStats::has_client_bitrate() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CFrameStats::set_has_client_bitrate() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CFrameStats::clear_has_client_bitrate() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CFrameStats::clear_client_bitrate() {
  client_bitrate_ = 0;
  clear_has_client_bitrate();
}
inline float CFrameStats::client_bitrate() const {
  // @@protoc_insertion_point(field_get:CFrameStats.client_bitrate)
  return client_bitrate_;
}
inline void CFrameStats::set_client_bitrate(float value) {
  set_has_client_bitrate();
  client_bitrate_ = value;
  // @@protoc_insertion_point(field_set:CFrameStats.client_bitrate)
}

// optional float link_bandwidth = 10;
inline bool CFrameStats::has_link_bandwidth() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CFrameStats::set_has_link_bandwidth() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CFrameStats::clear_has_link_bandwidth() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CFrameStats::clear_link_bandwidth() {
  link_bandwidth_ = 0;
  clear_has_link_bandwidth();
}
inline float CFrameStats::link_bandwidth() const {
  // @@protoc_insertion_point(field_get:CFrameStats.link_bandwidth)
  return link_bandwidth_;
}
inline void CFrameStats::set_link_bandwidth(float value) {
  set_has_link_bandwidth();
  link_bandwidth_ = value;
  // @@protoc_insertion_point(field_set:CFrameStats.link_bandwidth)
}

// optional float packet_loss = 11;
inline bool CFrameStats::has_packet_loss() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CFrameStats::set_has_packet_loss() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CFrameStats::clear_has_packet_loss() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CFrameStats::clear_packet_loss() {
  packet_loss_ = 0;
  clear_has_packet_loss();
}
inline float CFrameStats::packet_loss() const {
  // @@protoc_insertion_point(field_get:CFrameStats.packet_loss)
  return packet_loss_;
}
inline void CFrameStats::set_packet_loss(float value) {
  set_has_packet_loss();
  packet_loss_ = value;
  // @@protoc_insertion_point(field_set:CFrameStats.packet_loss)
}

// optional uint32 frame_size = 12;
inline bool CFrameStats::has_frame_size() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CFrameStats::set_has_frame_size() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CFrameStats::clear_has_frame_size() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CFrameStats::clear_frame_size() {
  frame_size_ = 0u;
  clear_has_frame_size();
}
inline ::google::protobuf::uint32 CFrameStats::frame_size() const {
  // @@protoc_insertion_point(field_get:CFrameStats.frame_size)
  return frame_size_;
}
inline void CFrameStats::set_frame_size(::google::protobuf::uint32 value) {
  set_has_frame_size();
  frame_size_ = value;
  // @@protoc_insertion_point(field_set:CFrameStats.frame_size)
}

// -------------------------------------------------------------------

// CFrameStatAccumulatedValue

// required .EFrameAccumulatedStat stat_type = 1 [default = k_EFrameStatFPS];
inline bool CFrameStatAccumulatedValue::has_stat_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CFrameStatAccumulatedValue::set_has_stat_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CFrameStatAccumulatedValue::clear_has_stat_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CFrameStatAccumulatedValue::clear_stat_type() {
  stat_type_ = 0;
  clear_has_stat_type();
}
inline ::EFrameAccumulatedStat CFrameStatAccumulatedValue::stat_type() const {
  // @@protoc_insertion_point(field_get:CFrameStatAccumulatedValue.stat_type)
  return static_cast< ::EFrameAccumulatedStat >(stat_type_);
}
inline void CFrameStatAccumulatedValue::set_stat_type(::EFrameAccumulatedStat value) {
  assert(::EFrameAccumulatedStat_IsValid(value));
  set_has_stat_type();
  stat_type_ = value;
  // @@protoc_insertion_point(field_set:CFrameStatAccumulatedValue.stat_type)
}

// required int32 count = 2;
inline bool CFrameStatAccumulatedValue::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CFrameStatAccumulatedValue::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CFrameStatAccumulatedValue::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CFrameStatAccumulatedValue::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 CFrameStatAccumulatedValue::count() const {
  // @@protoc_insertion_point(field_get:CFrameStatAccumulatedValue.count)
  return count_;
}
inline void CFrameStatAccumulatedValue::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:CFrameStatAccumulatedValue.count)
}

// required float average = 3;
inline bool CFrameStatAccumulatedValue::has_average() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CFrameStatAccumulatedValue::set_has_average() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CFrameStatAccumulatedValue::clear_has_average() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CFrameStatAccumulatedValue::clear_average() {
  average_ = 0;
  clear_has_average();
}
inline float CFrameStatAccumulatedValue::average() const {
  // @@protoc_insertion_point(field_get:CFrameStatAccumulatedValue.average)
  return average_;
}
inline void CFrameStatAccumulatedValue::set_average(float value) {
  set_has_average();
  average_ = value;
  // @@protoc_insertion_point(field_set:CFrameStatAccumulatedValue.average)
}

// optional float stddev = 4;
inline bool CFrameStatAccumulatedValue::has_stddev() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CFrameStatAccumulatedValue::set_has_stddev() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CFrameStatAccumulatedValue::clear_has_stddev() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CFrameStatAccumulatedValue::clear_stddev() {
  stddev_ = 0;
  clear_has_stddev();
}
inline float CFrameStatAccumulatedValue::stddev() const {
  // @@protoc_insertion_point(field_get:CFrameStatAccumulatedValue.stddev)
  return stddev_;
}
inline void CFrameStatAccumulatedValue::set_stddev(float value) {
  set_has_stddev();
  stddev_ = value;
  // @@protoc_insertion_point(field_set:CFrameStatAccumulatedValue.stddev)
}

// -------------------------------------------------------------------

// CFrameStatsListMsg

// required .EStreamingDataType data_type = 1 [default = k_EStreamingAudioData];
inline bool CFrameStatsListMsg::has_data_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CFrameStatsListMsg::set_has_data_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CFrameStatsListMsg::clear_has_data_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CFrameStatsListMsg::clear_data_type() {
  data_type_ = 0;
  clear_has_data_type();
}
inline ::EStreamingDataType CFrameStatsListMsg::data_type() const {
  // @@protoc_insertion_point(field_get:CFrameStatsListMsg.data_type)
  return static_cast< ::EStreamingDataType >(data_type_);
}
inline void CFrameStatsListMsg::set_data_type(::EStreamingDataType value) {
  assert(::EStreamingDataType_IsValid(value));
  set_has_data_type();
  data_type_ = value;
  // @@protoc_insertion_point(field_set:CFrameStatsListMsg.data_type)
}

// repeated .CFrameStats stats = 2;
inline int CFrameStatsListMsg::stats_size() const {
  return stats_.size();
}
inline void CFrameStatsListMsg::clear_stats() {
  stats_.Clear();
}
inline ::CFrameStats* CFrameStatsListMsg::mutable_stats(int index) {
  // @@protoc_insertion_point(field_mutable:CFrameStatsListMsg.stats)
  return stats_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::CFrameStats >*
CFrameStatsListMsg::mutable_stats() {
  // @@protoc_insertion_point(field_mutable_list:CFrameStatsListMsg.stats)
  return &stats_;
}
inline const ::CFrameStats& CFrameStatsListMsg::stats(int index) const {
  // @@protoc_insertion_point(field_get:CFrameStatsListMsg.stats)
  return stats_.Get(index);
}
inline ::CFrameStats* CFrameStatsListMsg::add_stats() {
  // @@protoc_insertion_point(field_add:CFrameStatsListMsg.stats)
  return stats_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CFrameStats >&
CFrameStatsListMsg::stats() const {
  // @@protoc_insertion_point(field_list:CFrameStatsListMsg.stats)
  return stats_;
}

// repeated .CFrameStatAccumulatedValue accumulated_stats = 3;
inline int CFrameStatsListMsg::accumulated_stats_size() const {
  return accumulated_stats_.size();
}
inline void CFrameStatsListMsg::clear_accumulated_stats() {
  accumulated_stats_.Clear();
}
inline ::CFrameStatAccumulatedValue* CFrameStatsListMsg::mutable_accumulated_stats(int index) {
  // @@protoc_insertion_point(field_mutable:CFrameStatsListMsg.accumulated_stats)
  return accumulated_stats_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::CFrameStatAccumulatedValue >*
CFrameStatsListMsg::mutable_accumulated_stats() {
  // @@protoc_insertion_point(field_mutable_list:CFrameStatsListMsg.accumulated_stats)
  return &accumulated_stats_;
}
inline const ::CFrameStatAccumulatedValue& CFrameStatsListMsg::accumulated_stats(int index) const {
  // @@protoc_insertion_point(field_get:CFrameStatsListMsg.accumulated_stats)
  return accumulated_stats_.Get(index);
}
inline ::CFrameStatAccumulatedValue* CFrameStatsListMsg::add_accumulated_stats() {
  // @@protoc_insertion_point(field_add:CFrameStatsListMsg.accumulated_stats)
  return accumulated_stats_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CFrameStatAccumulatedValue >&
CFrameStatsListMsg::accumulated_stats() const {
  // @@protoc_insertion_point(field_list:CFrameStatsListMsg.accumulated_stats)
  return accumulated_stats_;
}

// required int32 latest_frame_id = 4;
inline bool CFrameStatsListMsg::has_latest_frame_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CFrameStatsListMsg::set_has_latest_frame_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CFrameStatsListMsg::clear_has_latest_frame_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CFrameStatsListMsg::clear_latest_frame_id() {
  latest_frame_id_ = 0;
  clear_has_latest_frame_id();
}
inline ::google::protobuf::int32 CFrameStatsListMsg::latest_frame_id() const {
  // @@protoc_insertion_point(field_get:CFrameStatsListMsg.latest_frame_id)
  return latest_frame_id_;
}
inline void CFrameStatsListMsg::set_latest_frame_id(::google::protobuf::int32 value) {
  set_has_latest_frame_id();
  latest_frame_id_ = value;
  // @@protoc_insertion_point(field_set:CFrameStatsListMsg.latest_frame_id)
}

// -------------------------------------------------------------------

// CStreamingSessionStats

// optional float frame_loss_percentage = 1;
inline bool CStreamingSessionStats::has_frame_loss_percentage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CStreamingSessionStats::set_has_frame_loss_percentage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CStreamingSessionStats::clear_has_frame_loss_percentage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CStreamingSessionStats::clear_frame_loss_percentage() {
  frame_loss_percentage_ = 0;
  clear_has_frame_loss_percentage();
}
inline float CStreamingSessionStats::frame_loss_percentage() const {
  // @@protoc_insertion_point(field_get:CStreamingSessionStats.frame_loss_percentage)
  return frame_loss_percentage_;
}
inline void CStreamingSessionStats::set_frame_loss_percentage(float value) {
  set_has_frame_loss_percentage();
  frame_loss_percentage_ = value;
  // @@protoc_insertion_point(field_set:CStreamingSessionStats.frame_loss_percentage)
}

// optional float average_network_time_ms = 2;
inline bool CStreamingSessionStats::has_average_network_time_ms() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CStreamingSessionStats::set_has_average_network_time_ms() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CStreamingSessionStats::clear_has_average_network_time_ms() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CStreamingSessionStats::clear_average_network_time_ms() {
  average_network_time_ms_ = 0;
  clear_has_average_network_time_ms();
}
inline float CStreamingSessionStats::average_network_time_ms() const {
  // @@protoc_insertion_point(field_get:CStreamingSessionStats.average_network_time_ms)
  return average_network_time_ms_;
}
inline void CStreamingSessionStats::set_average_network_time_ms(float value) {
  set_has_average_network_time_ms();
  average_network_time_ms_ = value;
  // @@protoc_insertion_point(field_set:CStreamingSessionStats.average_network_time_ms)
}

// optional float stddev_network_time_ms = 3;
inline bool CStreamingSessionStats::has_stddev_network_time_ms() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CStreamingSessionStats::set_has_stddev_network_time_ms() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CStreamingSessionStats::clear_has_stddev_network_time_ms() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CStreamingSessionStats::clear_stddev_network_time_ms() {
  stddev_network_time_ms_ = 0;
  clear_has_stddev_network_time_ms();
}
inline float CStreamingSessionStats::stddev_network_time_ms() const {
  // @@protoc_insertion_point(field_get:CStreamingSessionStats.stddev_network_time_ms)
  return stddev_network_time_ms_;
}
inline void CStreamingSessionStats::set_stddev_network_time_ms(float value) {
  set_has_stddev_network_time_ms();
  stddev_network_time_ms_ = value;
  // @@protoc_insertion_point(field_set:CStreamingSessionStats.stddev_network_time_ms)
}

// -------------------------------------------------------------------

// CDebugDumpMsg

// optional bytes screenshot = 1;
inline bool CDebugDumpMsg::has_screenshot() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CDebugDumpMsg::set_has_screenshot() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CDebugDumpMsg::clear_has_screenshot() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CDebugDumpMsg::clear_screenshot() {
  screenshot_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_screenshot();
}
inline const ::std::string& CDebugDumpMsg::screenshot() const {
  // @@protoc_insertion_point(field_get:CDebugDumpMsg.screenshot)
  return screenshot_.GetNoArena();
}
inline void CDebugDumpMsg::set_screenshot(const ::std::string& value) {
  set_has_screenshot();
  screenshot_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CDebugDumpMsg.screenshot)
}
#if LANG_CXX11
inline void CDebugDumpMsg::set_screenshot(::std::string&& value) {
  set_has_screenshot();
  screenshot_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CDebugDumpMsg.screenshot)
}
#endif
inline void CDebugDumpMsg::set_screenshot(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_screenshot();
  screenshot_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CDebugDumpMsg.screenshot)
}
inline void CDebugDumpMsg::set_screenshot(const void* value, size_t size) {
  set_has_screenshot();
  screenshot_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CDebugDumpMsg.screenshot)
}
inline ::std::string* CDebugDumpMsg::mutable_screenshot() {
  set_has_screenshot();
  // @@protoc_insertion_point(field_mutable:CDebugDumpMsg.screenshot)
  return screenshot_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CDebugDumpMsg::release_screenshot() {
  // @@protoc_insertion_point(field_release:CDebugDumpMsg.screenshot)
  if (!has_screenshot()) {
    return NULL;
  }
  clear_has_screenshot();
  return screenshot_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CDebugDumpMsg::set_allocated_screenshot(::std::string* screenshot) {
  if (screenshot != NULL) {
    set_has_screenshot();
  } else {
    clear_has_screenshot();
  }
  screenshot_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), screenshot);
  // @@protoc_insertion_point(field_set_allocated:CDebugDumpMsg.screenshot)
}

// -------------------------------------------------------------------

// CLogMsg

// optional int32 type = 1;
inline bool CLogMsg::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CLogMsg::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CLogMsg::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CLogMsg::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 CLogMsg::type() const {
  // @@protoc_insertion_point(field_get:CLogMsg.type)
  return type_;
}
inline void CLogMsg::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:CLogMsg.type)
}

// optional string message = 2;
inline bool CLogMsg::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CLogMsg::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CLogMsg::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CLogMsg::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& CLogMsg::message() const {
  // @@protoc_insertion_point(field_get:CLogMsg.message)
  return message_.GetNoArena();
}
inline void CLogMsg::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CLogMsg.message)
}
#if LANG_CXX11
inline void CLogMsg::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CLogMsg.message)
}
#endif
inline void CLogMsg::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CLogMsg.message)
}
inline void CLogMsg::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CLogMsg.message)
}
inline ::std::string* CLogMsg::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:CLogMsg.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CLogMsg::release_message() {
  // @@protoc_insertion_point(field_release:CLogMsg.message)
  if (!has_message()) {
    return NULL;
  }
  clear_has_message();
  return message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CLogMsg::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:CLogMsg.message)
}

// -------------------------------------------------------------------

// CLogUploadMsg

// optional .ELogFileType type = 1 [default = k_ELogFileSystemBoot];
inline bool CLogUploadMsg::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CLogUploadMsg::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CLogUploadMsg::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CLogUploadMsg::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::ELogFileType CLogUploadMsg::type() const {
  // @@protoc_insertion_point(field_get:CLogUploadMsg.type)
  return static_cast< ::ELogFileType >(type_);
}
inline void CLogUploadMsg::set_type(::ELogFileType value) {
  assert(::ELogFileType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:CLogUploadMsg.type)
}

// optional bytes data = 3;
inline bool CLogUploadMsg::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CLogUploadMsg::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CLogUploadMsg::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CLogUploadMsg::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& CLogUploadMsg::data() const {
  // @@protoc_insertion_point(field_get:CLogUploadMsg.data)
  return data_.GetNoArena();
}
inline void CLogUploadMsg::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CLogUploadMsg.data)
}
#if LANG_CXX11
inline void CLogUploadMsg::set_data(::std::string&& value) {
  set_has_data();
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CLogUploadMsg.data)
}
#endif
inline void CLogUploadMsg::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CLogUploadMsg.data)
}
inline void CLogUploadMsg::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CLogUploadMsg.data)
}
inline ::std::string* CLogUploadMsg::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:CLogUploadMsg.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CLogUploadMsg::release_data() {
  // @@protoc_insertion_point(field_release:CLogUploadMsg.data)
  if (!has_data()) {
    return NULL;
  }
  clear_has_data();
  return data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CLogUploadMsg::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:CLogUploadMsg.data)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::CAuthenticationResponseMsg_AuthenticationResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CAuthenticationResponseMsg_AuthenticationResult>() {
  return ::CAuthenticationResponseMsg_AuthenticationResult_descriptor();
}
template <> struct is_proto_enum< ::EStreamChannel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamChannel>() {
  return ::EStreamChannel_descriptor();
}
template <> struct is_proto_enum< ::EStreamDiscoveryMessage> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamDiscoveryMessage>() {
  return ::EStreamDiscoveryMessage_descriptor();
}
template <> struct is_proto_enum< ::EStreamControlMessage> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamControlMessage>() {
  return ::EStreamControlMessage_descriptor();
}
template <> struct is_proto_enum< ::EStreamVersion> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamVersion>() {
  return ::EStreamVersion_descriptor();
}
template <> struct is_proto_enum< ::EStreamAudioCodec> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamAudioCodec>() {
  return ::EStreamAudioCodec_descriptor();
}
template <> struct is_proto_enum< ::EStreamVideoCodec> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamVideoCodec>() {
  return ::EStreamVideoCodec_descriptor();
}
template <> struct is_proto_enum< ::EStreamQualityPreference> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamQualityPreference>() {
  return ::EStreamQualityPreference_descriptor();
}
template <> struct is_proto_enum< ::EStreamBitrate> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamBitrate>() {
  return ::EStreamBitrate_descriptor();
}
template <> struct is_proto_enum< ::EStreamingDataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamingDataType>() {
  return ::EStreamingDataType_descriptor();
}
template <> struct is_proto_enum< ::EStreamMouseButton> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamMouseButton>() {
  return ::EStreamMouseButton_descriptor();
}
template <> struct is_proto_enum< ::EStreamMouseWheelDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamMouseWheelDirection>() {
  return ::EStreamMouseWheelDirection_descriptor();
}
template <> struct is_proto_enum< ::EStreamGamepadInputType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamGamepadInputType>() {
  return ::EStreamGamepadInputType_descriptor();
}
template <> struct is_proto_enum< ::EStreamFramerateLimiter> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamFramerateLimiter>() {
  return ::EStreamFramerateLimiter_descriptor();
}
template <> struct is_proto_enum< ::EStreamActivity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamActivity>() {
  return ::EStreamActivity_descriptor();
}
template <> struct is_proto_enum< ::EStreamDataMessage> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamDataMessage>() {
  return ::EStreamDataMessage_descriptor();
}
template <> struct is_proto_enum< ::EAudioFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EAudioFormat>() {
  return ::EAudioFormat_descriptor();
}
template <> struct is_proto_enum< ::EVideoFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EVideoFormat>() {
  return ::EVideoFormat_descriptor();
}
template <> struct is_proto_enum< ::EStreamStatsMessage> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamStatsMessage>() {
  return ::EStreamStatsMessage_descriptor();
}
template <> struct is_proto_enum< ::EStreamFrameEvent> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamFrameEvent>() {
  return ::EStreamFrameEvent_descriptor();
}
template <> struct is_proto_enum< ::EStreamFrameResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamFrameResult>() {
  return ::EStreamFrameResult_descriptor();
}
template <> struct is_proto_enum< ::EFrameAccumulatedStat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EFrameAccumulatedStat>() {
  return ::EFrameAccumulatedStat_descriptor();
}
template <> struct is_proto_enum< ::ELogFileType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ELogFileType>() {
  return ::ELogFileType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_stream_2eproto
